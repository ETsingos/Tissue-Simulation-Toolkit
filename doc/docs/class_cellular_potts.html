<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: CellularPotts Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_cellular_potts-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">CellularPotts Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2266433b8633c8694679385e6a2dafc0" id="r_a2266433b8633c8694679385e6a2dafc0"><td class="memItemLeft" align="right" valign="top"><a id="a2266433b8633c8694679385e6a2dafc0" name="a2266433b8633c8694679385e6a2dafc0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNbhx</b> (int i)</td></tr>
<tr class="separator:a2266433b8633c8694679385e6a2dafc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c12f43d17a927d8cb48f98df772d961" id="r_a7c12f43d17a927d8cb48f98df772d961"><td class="memItemLeft" align="right" valign="top"><a id="a7c12f43d17a927d8cb48f98df772d961" name="a7c12f43d17a927d8cb48f98df772d961"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNbhy</b> (int i)</td></tr>
<tr class="separator:a7c12f43d17a927d8cb48f98df772d961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097de27a408be042f2c5c413b2049efa" id="r_a097de27a408be042f2c5c413b2049efa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a097de27a408be042f2c5c413b2049efa">GetMatrixLevel</a> (int x, int y)</td></tr>
<tr class="memdesc:a097de27a408be042f2c5c413b2049efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the level of matrix.  <br /></td></tr>
<tr class="separator:a097de27a408be042f2c5c413b2049efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe4d50600de429a184627ee7baf1079" id="r_a9fe4d50600de429a184627ee7baf1079"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a9fe4d50600de429a184627ee7baf1079">GetActLevel</a> (int x, int y)</td></tr>
<tr class="memdesc:a9fe4d50600de429a184627ee7baf1079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the level of act.  <br /></td></tr>
<tr class="separator:a9fe4d50600de429a184627ee7baf1079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dc236b8000f1f9ed6c878b8e73b93d" id="r_a47dc236b8000f1f9ed6c878b8e73b93d"><td class="memItemLeft" align="right" valign="top"><a id="a47dc236b8000f1f9ed6c878b8e73b93d" name="a47dc236b8000f1f9ed6c878b8e73b93d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CellularPotts</b> (std::vector&lt; <a class="el" href="class_cell.html">Cell</a> &gt; *cells, const int sizex=200, const int sizey=200)</td></tr>
<tr class="memdesc:a47dc236b8000f1f9ed6c878b8e73b93d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a CA field. This should be done in "Dish". <br /></td></tr>
<tr class="separator:a47dc236b8000f1f9ed6c878b8e73b93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cd87909d465133cdecc1d80f4347fd" id="r_af7cd87909d465133cdecc1d80f4347fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#af7cd87909d465133cdecc1d80f4347fd">InitialiseEdgeList</a> (void)</td></tr>
<tr class="memdesc:af7cd87909d465133cdecc1d80f4347fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialises the edgelist at the beginning of a simulation.  <br /></td></tr>
<tr class="separator:af7cd87909d465133cdecc1d80f4347fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669103985248ae144731f7c94724822b" id="r_a669103985248ae144731f7c94724822b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a669103985248ae144731f7c94724822b">AllocateSigma</a> (int sx, int sy)</td></tr>
<tr class="memdesc:a669103985248ae144731f7c94724822b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates data for the sigma array.  <br /></td></tr>
<tr class="separator:a669103985248ae144731f7c94724822b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1769e2ae406b86f7ca3f1dc65b038823" id="r_a1769e2ae406b86f7ca3f1dc65b038823"><td class="memItemLeft" align="right" valign="top"><a id="a1769e2ae406b86f7ca3f1dc65b038823" name="a1769e2ae406b86f7ca3f1dc65b038823"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>AllocateMatrix</b> (<a class="el" href="class_dish.html">Dish</a> &amp;beast)</td></tr>
<tr class="memdesc:a1769e2ae406b86f7ca3f1dc65b038823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates data for the matrix array. <br /></td></tr>
<tr class="separator:a1769e2ae406b86f7ca3f1dc65b038823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747d71d26a03ced7b61f6a43cc8dbdbb" id="r_a747d71d26a03ced7b61f6a43cc8dbdbb"><td class="memItemLeft" align="right" valign="top">int **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a747d71d26a03ced7b61f6a43cc8dbdbb">SearchNandPlot</a> (<a class="el" href="class_graphics.html">Graphics</a> *g=0, bool get_neighbours=true)</td></tr>
<tr class="memdesc:a747d71d26a03ced7b61f6a43cc8dbdbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plots the dish to the screen or to a movie and searches the neighbours.  <br /></td></tr>
<tr class="separator:a747d71d26a03ced7b61f6a43cc8dbdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f6adf742a518ad543ca5d144278926" id="r_a11f6adf742a518ad543ca5d144278926"><td class="memItemLeft" align="right" valign="top"><a id="a11f6adf742a518ad543ca5d144278926" name="a11f6adf742a518ad543ca5d144278926"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Plot</b> (<a class="el" href="class_graphics.html">Graphics</a> *g)</td></tr>
<tr class="memdesc:a11f6adf742a518ad543ca5d144278926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plot the dish to <a class="el" href="class_graphics.html" title="API for Graphics windows.">Graphics</a> window g. <br /></td></tr>
<tr class="separator:a11f6adf742a518ad543ca5d144278926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bec6a234220d4fbaf04f9ed3a5be27" id="r_ad3bec6a234220d4fbaf04f9ed3a5be27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#ad3bec6a234220d4fbaf04f9ed3a5be27">PlotIsing</a> (<a class="el" href="class_graphics.html">Graphics</a> *g, int mag)</td></tr>
<tr class="memdesc:ad3bec6a234220d4fbaf04f9ed3a5be27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special plotting for Ising model Only plot lines between the two states.  <br /></td></tr>
<tr class="separator:ad3bec6a234220d4fbaf04f9ed3a5be27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08a62100c3e36d67a10892442148e9d" id="r_af08a62100c3e36d67a10892442148e9d"><td class="memItemLeft" align="right" valign="top"><a id="af08a62100c3e36d67a10892442148e9d" name="af08a62100c3e36d67a10892442148e9d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SearchNandPlotClear</b> (<a class="el" href="class_graphics.html">Graphics</a> *g=0)</td></tr>
<tr class="memdesc:af08a62100c3e36d67a10892442148e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plot the neighbours between cells. <br /></td></tr>
<tr class="separator:af08a62100c3e36d67a10892442148e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e386f5813077b558c7f72d0d78712af" id="r_a4e386f5813077b558c7f72d0d78712af"><td class="memItemLeft" align="right" valign="top">int **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a4e386f5813077b558c7f72d0d78712af">SearchNeighboursMatrix</a> ()</td></tr>
<tr class="memdesc:a4e386f5813077b558c7f72d0d78712af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the neighbour matrix of cells.  <br /></td></tr>
<tr class="separator:a4e386f5813077b558c7f72d0d78712af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad621be8ea38deccef8d6060bddd19f41" id="r_ad621be8ea38deccef8d6060bddd19f41"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#ad621be8ea38deccef8d6060bddd19f41">GetNewPerimeterIfXYWereAdded</a> (int sxyp, int x, int y)</td></tr>
<tr class="memdesc:ad621be8ea38deccef8d6060bddd19f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get perimeter if new pixel is added.  <br /></td></tr>
<tr class="separator:ad621be8ea38deccef8d6060bddd19f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1568580d7a946eace7fe975939636f" id="r_a2c1568580d7a946eace7fe975939636f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a2c1568580d7a946eace7fe975939636f">GetNewPerimeterIfXYWereRemoved</a> (int sxy, int x, int y)</td></tr>
<tr class="memdesc:a2c1568580d7a946eace7fe975939636f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get perimeter if pixel is removed.  <br /></td></tr>
<tr class="separator:a2c1568580d7a946eace7fe975939636f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add752b19c71fe9f3a8d7802b18863262" id="r_add752b19c71fe9f3a8d7802b18863262"><td class="memItemLeft" align="right" valign="top"><a id="add752b19c71fe9f3a8d7802b18863262" name="add752b19c71fe9f3a8d7802b18863262"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetTargetPerimeter</b> (int tau, int value)</td></tr>
<tr class="memdesc:add752b19c71fe9f3a8d7802b18863262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the target perimeter. <br /></td></tr>
<tr class="separator:add752b19c71fe9f3a8d7802b18863262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d62050c4038cb0409b08886b73308a6" id="r_a2d62050c4038cb0409b08886b73308a6"><td class="memItemLeft" align="right" valign="top"><a id="a2d62050c4038cb0409b08886b73308a6" name="a2d62050c4038cb0409b08886b73308a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetLambdaPerimeter</b> (int tau, int value)</td></tr>
<tr class="memdesc:a2d62050c4038cb0409b08886b73308a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the strength of the perimeter constraint. <br /></td></tr>
<tr class="separator:a2d62050c4038cb0409b08886b73308a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d146d7fc39551025cfa59ab3fe5843" id="r_a95d146d7fc39551025cfa59ab3fe5843"><td class="memItemLeft" align="right" valign="top"><a id="a95d146d7fc39551025cfa59ab3fe5843" name="a95d146d7fc39551025cfa59ab3fe5843"></a>
int **&#160;</td><td class="memItemRight" valign="bottom"><b>SearchNeighbours</b> (void)</td></tr>
<tr class="memdesc:a95d146d7fc39551025cfa59ab3fe5843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the cells' neighbours without plotting. <br /></td></tr>
<tr class="separator:a95d146d7fc39551025cfa59ab3fe5843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4baf392d90a705fdce8231be2a2e67" id="r_a1f4baf392d90a705fdce8231be2a2e67"><td class="memItemLeft" align="right" valign="top"><a id="a1f4baf392d90a705fdce8231be2a2e67" name="a1f4baf392d90a705fdce8231be2a2e67"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Mass</b> (void)</td></tr>
<tr class="memdesc:a1f4baf392d90a705fdce8231be2a2e67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total area occupied by the cells. <br /></td></tr>
<tr class="separator:a1f4baf392d90a705fdce8231be2a2e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e46579d90f9f861b407933ed67c77df" id="r_a6e46579d90f9f861b407933ed67c77df"><td class="memItemLeft" align="right" valign="top"><a id="a6e46579d90f9f861b407933ed67c77df" name="a6e46579d90f9f861b407933ed67c77df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>FindBoundingBox</b> (void)</td></tr>
<tr class="memdesc:a6e46579d90f9f861b407933ed67c77df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a bounding box that contains all cells Currently has no output. <br /></td></tr>
<tr class="separator:a6e46579d90f9f861b407933ed67c77df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0866b5925006bafd9c492fcd52302415" id="r_a0866b5925006bafd9c492fcd52302415"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a0866b5925006bafd9c492fcd52302415">PlotSigma</a> (<a class="el" href="class_graphics.html">Graphics</a> *g, int mag=2)</td></tr>
<tr class="memdesc:a0866b5925006bafd9c492fcd52302415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plot the cells according to their cell identity, not their type. The black lines are omitted.  <br /></td></tr>
<tr class="separator:a0866b5925006bafd9c492fcd52302415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb159c2b9095666fa7fca2dcce71dd2" id="r_abeb159c2b9095666fa7fca2dcce71dd2"><td class="memItemLeft" align="right" valign="top"><a id="abeb159c2b9095666fa7fca2dcce71dd2" name="abeb159c2b9095666fa7fca2dcce71dd2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DivideCells</b> (void)</td></tr>
<tr class="memdesc:abeb159c2b9095666fa7fca2dcce71dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide all cells. Divide along cell elongation axis. <br /></td></tr>
<tr class="separator:abeb159c2b9095666fa7fca2dcce71dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651a2d70d4dd58ce00eaec5ce483c5a5" id="r_a651a2d70d4dd58ce00eaec5ce483c5a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a651a2d70d4dd58ce00eaec5ce483c5a5">DivideCells</a> (std::vector&lt; bool &gt; which_cells)</td></tr>
<tr class="separator:a651a2d70d4dd58ce00eaec5ce483c5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5e73910b835fee1171c1fa6c220f73" id="r_a9d5e73910b835fee1171c1fa6c220f73"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a9d5e73910b835fee1171c1fa6c220f73">AmoebaeMove</a> (<a class="el" href="class_p_d_e.html">PDE</a> *PDEfield=0, bool <a class="el" href="class_cellular_potts.html#a626a7d57e20559085dd7d6cb8d523865">anneal</a>=false)</td></tr>
<tr class="memdesc:a9d5e73910b835fee1171c1fa6c220f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monte Carlo Step. Returns summed energy change.  <br /></td></tr>
<tr class="separator:a9d5e73910b835fee1171c1fa6c220f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ba4646f7a09b99a6d1b138103fa4b6" id="r_a19ba4646f7a09b99a6d1b138103fa4b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a19ba4646f7a09b99a6d1b138103fa4b6">Act_AmoebaeMove</a> (<a class="el" href="class_p_d_e.html">PDE</a> *PDEfield)</td></tr>
<tr class="separator:a19ba4646f7a09b99a6d1b138103fa4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b82f8fb894878d242defd1883da849" id="r_a74b82f8fb894878d242defd1883da849"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a74b82f8fb894878d242defd1883da849">KawasakiMove</a> (<a class="el" href="class_p_d_e.html">PDE</a> *PDEfield=0)</td></tr>
<tr class="memdesc:a74b82f8fb894878d242defd1883da849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monte Carlo Step. Returns summed energy change.  <br /></td></tr>
<tr class="separator:a74b82f8fb894878d242defd1883da849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080c719d169997556834fdc0dbe247a6" id="r_a080c719d169997556834fdc0dbe247a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a080c719d169997556834fdc0dbe247a6">IsingMove</a> (<a class="el" href="class_p_d_e.html">PDE</a> *PDEfield=0)</td></tr>
<tr class="memdesc:a080c719d169997556834fdc0dbe247a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monte Carlo Step. Returns summed energy change.  <br /></td></tr>
<tr class="separator:a080c719d169997556834fdc0dbe247a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e3eb01edd9531cc0f2ee43e3cfe581" id="r_a83e3eb01edd9531cc0f2ee43e3cfe581"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a83e3eb01edd9531cc0f2ee43e3cfe581">PottsMove</a> (<a class="el" href="class_p_d_e.html">PDE</a> *PDEfield=0)</td></tr>
<tr class="memdesc:a83e3eb01edd9531cc0f2ee43e3cfe581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monte Carlo Step. Returns summed energy change.  <br /></td></tr>
<tr class="separator:a83e3eb01edd9531cc0f2ee43e3cfe581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394d1982f7eb760c2ad0e4a119f2b354" id="r_a394d1982f7eb760c2ad0e4a119f2b354"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a394d1982f7eb760c2ad0e4a119f2b354">PottsNeighbourMove</a> (<a class="el" href="class_p_d_e.html">PDE</a> *PDEfield)</td></tr>
<tr class="memdesc:a394d1982f7eb760c2ad0e4a119f2b354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Monte Carlo Step. Returns summed energy change.  <br /></td></tr>
<tr class="separator:a394d1982f7eb760c2ad0e4a119f2b354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d005dd4af63755bc57cf097ec09b02" id="r_a92d005dd4af63755bc57cf097ec09b02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_cell_e_c_m_interactions.html">CellECMInteractions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a92d005dd4af63755bc57cf097ec09b02">GetCellECMInteractions</a> () const</td></tr>
<tr class="separator:a92d005dd4af63755bc57cf097ec09b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704dfea7f85ca5939899e617266a2b39" id="r_a704dfea7f85ca5939899e617266a2b39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a704dfea7f85ca5939899e617266a2b39">ResetCellECMInteractions</a> ()</td></tr>
<tr class="separator:a704dfea7f85ca5939899e617266a2b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae795cc3226bd4711986861b4c072e6" id="r_a4ae795cc3226bd4711986861b4c072e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a4ae795cc3226bd4711986861b4c072e6">SetECMBoundaryState</a> (<a class="el" href="struct_e_c_m_boundary_state.html">ECMBoundaryState</a> const &amp;ecm_boundary_state)</td></tr>
<tr class="separator:a4ae795cc3226bd4711986861b4c072e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0057e535a3050503d8c598df752be81d" id="r_a0057e535a3050503d8c598df752be81d"><td class="memItemLeft" align="right" valign="top"><a id="a0057e535a3050503d8c598df752be81d" name="a0057e535a3050503d8c598df752be81d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReadZygotePicture</b> (void)</td></tr>
<tr class="memdesc:a0057e535a3050503d8c598df752be81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read initial cell shape from XPM file. Reads the initial cell shape from an include xpm picture called "ZYGXPM(ZYGOTE)", and it allocates enough cells for it to the <a class="el" href="class_dish.html" title="The virtual Petri dish. Hosts the cells with states and the CA-plane.">Dish</a>. <br /></td></tr>
<tr class="separator:a0057e535a3050503d8c598df752be81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9566d64c6641303e85c5eef9ae341183" id="r_a9566d64c6641303e85c5eef9ae341183"><td class="memItemLeft" align="right" valign="top"><a id="a9566d64c6641303e85c5eef9ae341183" name="a9566d64c6641303e85c5eef9ae341183"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ConstructInitCells</b> (<a class="el" href="class_dish.html">Dish</a> &amp;beast)</td></tr>
<tr class="memdesc:a9566d64c6641303e85c5eef9ae341183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct initial cells Construct the cells from the sigma-field. <br /></td></tr>
<tr class="separator:a9566d64c6641303e85c5eef9ae341183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d48cf8ec7e117e3328958806aa9fb6" id="r_ad9d48cf8ec7e117e3328958806aa9fb6"><td class="memItemLeft" align="right" valign="top"><a id="ad9d48cf8ec7e117e3328958806aa9fb6" name="ad9d48cf8ec7e117e3328958806aa9fb6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Time</b> () const</td></tr>
<tr class="memdesc:ad9d48cf8ec7e117e3328958806aa9fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of completed Monte Carlo steps. <br /></td></tr>
<tr class="separator:ad9d48cf8ec7e117e3328958806aa9fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38fa7580abae7d2663c180bebf60e87f" id="r_a38fa7580abae7d2663c180bebf60e87f"><td class="memItemLeft" align="right" valign="top"><a id="a38fa7580abae7d2663c180bebf60e87f" name="a38fa7580abae7d2663c180bebf60e87f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>ZygoteArea</b> () const</td></tr>
<tr class="separator:a38fa7580abae7d2663c180bebf60e87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9603962bcbae57b0fff53e0e381a8f" id="r_aac9603962bcbae57b0fff53e0e381a8f"><td class="memItemLeft" align="right" valign="top"><a id="aac9603962bcbae57b0fff53e0e381a8f" name="aac9603962bcbae57b0fff53e0e381a8f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SizeX</b> () const</td></tr>
<tr class="memdesc:aac9603962bcbae57b0fff53e0e381a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the horizontal size of the CA plane. <br /></td></tr>
<tr class="separator:aac9603962bcbae57b0fff53e0e381a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3a3165333e6136ac2f1abe1bf0429b" id="r_a8f3a3165333e6136ac2f1abe1bf0429b"><td class="memItemLeft" align="right" valign="top"><a id="a8f3a3165333e6136ac2f1abe1bf0429b" name="a8f3a3165333e6136ac2f1abe1bf0429b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>SizeY</b> () const</td></tr>
<tr class="memdesc:a8f3a3165333e6136ac2f1abe1bf0429b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vertical size of the CA plane. <br /></td></tr>
<tr class="separator:a8f3a3165333e6136ac2f1abe1bf0429b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bbce2aae8baeead6cf173dd3d81d02" id="r_af5bbce2aae8baeead6cf173dd3d81d02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#af5bbce2aae8baeead6cf173dd3d81d02">Sigma</a> (const int x, const int y) const</td></tr>
<tr class="memdesc:af5bbce2aae8baeead6cf173dd3d81d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of lattice site (x,y).  <br /></td></tr>
<tr class="separator:af5bbce2aae8baeead6cf173dd3d81d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefc69293247deaa78666c863e1ab4df" id="r_abefc69293247deaa78666c863e1ab4df"><td class="memItemLeft" align="right" valign="top"><a id="abefc69293247deaa78666c863e1ab4df" name="abefc69293247deaa78666c863e1ab4df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Replace</b> (<a class="el" href="class_graphics.html">Graphics</a> *g)</td></tr>
<tr class="separator:abefc69293247deaa78666c863e1ab4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19115b49e9c77e81835938a2f7a00f80" id="r_a19115b49e9c77e81835938a2f7a00f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_dir.html">Dir</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a19115b49e9c77e81835938a2f7a00f80">FindCellDirections</a> (void) const</td></tr>
<tr class="separator:a19115b49e9c77e81835938a2f7a00f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568014835d075361e62ec6d2489a7db3" id="r_a568014835d075361e62ec6d2489a7db3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a568014835d075361e62ec6d2489a7db3">ThrowInCells</a> (int n, int cellsize)</td></tr>
<tr class="memdesc:a568014835d075361e62ec6d2489a7db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the CA plane with n circular cells fitting in a cellsize^2 square.  <br /></td></tr>
<tr class="separator:a568014835d075361e62ec6d2489a7db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa7d7a5ba27ae620ed66f5eb9564257" id="r_adaa7d7a5ba27ae620ed66f5eb9564257"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#adaa7d7a5ba27ae620ed66f5eb9564257">GrowInCells</a> (int n_cells, int cellsize, double subfield=1., int posx=-1, int posy=-1)</td></tr>
<tr class="memdesc:adaa7d7a5ba27ae620ed66f5eb9564257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the subfield in which eden growth takes place.  <br /></td></tr>
<tr class="separator:adaa7d7a5ba27ae620ed66f5eb9564257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffb2aad630eaaff5a07b78a810c5c0a" id="r_a6ffb2aad630eaaff5a07b78a810c5c0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a6ffb2aad630eaaff5a07b78a810c5c0a">GrowInCells</a> (int n_cells, int cell_size, int sx, int sy, int offset_x, int offset_y)</td></tr>
<tr class="memdesc:a6ffb2aad630eaaff5a07b78a810c5c0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the CA plane with n cells using an Eden growth algorithm.  <br /></td></tr>
<tr class="separator:a6ffb2aad630eaaff5a07b78a810c5c0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7493532f148c65d960e65a8c131590" id="r_a4e7493532f148c65d960e65a8c131590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a4e7493532f148c65d960e65a8c131590">RandomSpins</a> (double prob)</td></tr>
<tr class="memdesc:a4e7493532f148c65d960e65a8c131590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise cpm field with a random sigma of 0 or 1 of every pixel.  <br /></td></tr>
<tr class="separator:a4e7493532f148c65d960e65a8c131590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe734e8295788f92fcc21f4188a83dde" id="r_abe734e8295788f92fcc21f4188a83dde"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#abe734e8295788f92fcc21f4188a83dde">SquareCell</a> (int sig, int cx, int cy, int size)</td></tr>
<tr class="memdesc:abe734e8295788f92fcc21f4188a83dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a square cell.  <br /></td></tr>
<tr class="separator:abe734e8295788f92fcc21f4188a83dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9de13dc0bbb4919a570be2658faa79" id="r_afb9de13dc0bbb4919a570be2658faa79"><td class="memItemLeft" align="right" valign="top"><a id="afb9de13dc0bbb4919a570be2658faa79" name="afb9de13dc0bbb4919a570be2658faa79"></a>
<a class="el" href="class_cell.html">Cell</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>AddCell</b> (<a class="el" href="class_dish.html">Dish</a> &amp;beast)</td></tr>
<tr class="memdesc:afb9de13dc0bbb4919a570be2658faa79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new <a class="el" href="class_cell.html">Cell</a> and returns a reference to it. <br /></td></tr>
<tr class="separator:afb9de13dc0bbb4919a570be2658faa79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce57d56c6e561ded805e13851d06c63" id="r_a3ce57d56c6e561ded805e13851d06c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a3ce57d56c6e561ded805e13851d06c63">ShowDirections</a> (<a class="el" href="class_graphics.html">Graphics</a> &amp;g, const <a class="el" href="class_dir.html">Dir</a> *celldir) const</td></tr>
<tr class="memdesc:a3ce57d56c6e561ded805e13851d06c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display the division planes returned by FindCellDirections.  <br /></td></tr>
<tr class="separator:a3ce57d56c6e561ded805e13851d06c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987a69c9442d905d298493f74dba79f2" id="r_a987a69c9442d905d298493f74dba79f2"><td class="memItemLeft" align="right" valign="top"><a id="a987a69c9442d905d298493f74dba79f2" name="a987a69c9442d905d298493f74dba79f2"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>MeanCellArea</b> (void) const</td></tr>
<tr class="memdesc:a987a69c9442d905d298493f74dba79f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mean area of the cells. <br /></td></tr>
<tr class="separator:a987a69c9442d905d298493f74dba79f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae05936dbf37d5469fe3d88dc365d3e9" id="r_aae05936dbf37d5469fe3d88dc365d3e9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#aae05936dbf37d5469fe3d88dc365d3e9">CellDensity</a> (void) const</td></tr>
<tr class="memdesc:aae05936dbf37d5469fe3d88dc365d3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cell density.  <br /></td></tr>
<tr class="separator:aae05936dbf37d5469fe3d88dc365d3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fead3fd912c9175edb9f06c4e198cb" id="r_a67fead3fd912c9175edb9f06c4e198cb"><td class="memItemLeft" align="right" valign="top"><a id="a67fead3fd912c9175edb9f06c4e198cb" name="a67fead3fd912c9175edb9f06c4e198cb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ResetTargetLengths</b> (void)</td></tr>
<tr class="memdesc:a67fead3fd912c9175edb9f06c4e198cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target lengths of all cells to the value given in parameter file. <br /></td></tr>
<tr class="separator:a67fead3fd912c9175edb9f06c4e198cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb31aaed8dbbfb3b075fc21e2d666c12" id="r_acb31aaed8dbbfb3b075fc21e2d666c12"><td class="memItemLeft" align="right" valign="top"><a id="acb31aaed8dbbfb3b075fc21e2d666c12" name="acb31aaed8dbbfb3b075fc21e2d666c12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetRandomTypes</b> (void)</td></tr>
<tr class="memdesc:acb31aaed8dbbfb3b075fc21e2d666c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give each cell a random cell type. The number of cell types is defined by the J parameter file. (See Jtable in parameter file). <br /></td></tr>
<tr class="separator:acb31aaed8dbbfb3b075fc21e2d666c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b07faf41fd8c395c1f98f98f0c8eeac" id="r_a2b07faf41fd8c395c1f98f98f0c8eeac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a2b07faf41fd8c395c1f98f98f0c8eeac">GrowAndDivideCells</a> (int growth_rate)</td></tr>
<tr class="separator:a2b07faf41fd8c395c1f98f98f0c8eeac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d66ff8068a1e46e3e4a19db727f7eaf" id="r_a1d66ff8068a1e46e3e4a19db727f7eaf"><td class="memItemLeft" align="right" valign="top"><a id="a1d66ff8068a1e46e3e4a19db727f7eaf" name="a1d66ff8068a1e46e3e4a19db727f7eaf"></a>
<a class="el" href="class_cell.html">Cell</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCell</b> (int c)</td></tr>
<tr class="separator:a1d66ff8068a1e46e3e4a19db727f7eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8915e042c82581b22ff19f903f3f255a" id="r_a8915e042c82581b22ff19f903f3f255a"><td class="memItemLeft" align="right" valign="top"><a id="a8915e042c82581b22ff19f903f3f255a" name="a8915e042c82581b22ff19f903f3f255a"></a>
vector&lt; <a class="el" href="class_cell.html">Cell</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>getCellArray</b> ()</td></tr>
<tr class="separator:a8915e042c82581b22ff19f903f3f255a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1233da3a36aae791fda27ed0171306" id="r_aed1233da3a36aae791fda27ed0171306"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#aed1233da3a36aae791fda27ed0171306">DrawConvexHull</a> (<a class="el" href="class_graphics.html">Graphics</a> *g, int <a class="el" href="structcolor.html">color</a>=1)</td></tr>
<tr class="separator:aed1233da3a36aae791fda27ed0171306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e044382275fecdefeeeabc0d4de759" id="r_aa7e044382275fecdefeeeabc0d4de759"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#aa7e044382275fecdefeeeabc0d4de759">Compactness</a> (void)</td></tr>
<tr class="separator:aa7e044382275fecdefeeeabc0d4de759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ac68f926e575d4b56b325dacecbb6d" id="r_a49ac68f926e575d4b56b325dacecbb6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a49ac68f926e575d4b56b325dacecbb6d">RandomSigma</a> (int n_cells)</td></tr>
<tr class="memdesc:a49ac68f926e575d4b56b325dacecbb6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign random sigma to every lattice point.  <br /></td></tr>
<tr class="separator:a49ac68f926e575d4b56b325dacecbb6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6025b81a4f315dfd944151e9cb0b61b3" id="r_a6025b81a4f315dfd944151e9cb0b61b3"><td class="memItemLeft" align="right" valign="top"><a id="a6025b81a4f315dfd944151e9cb0b61b3" name="a6025b81a4f315dfd944151e9cb0b61b3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MeasureCellSizes</b> (void)</td></tr>
<tr class="memdesc:a6025b81a4f315dfd944151e9cb0b61b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the initial cell sizes Measure cell sizes of all initial size and assign them to the cells. <br /></td></tr>
<tr class="separator:a6025b81a4f315dfd944151e9cb0b61b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae852394cc178fad51c3d5eb7f6064da1" id="r_ae852394cc178fad51c3d5eb7f6064da1"><td class="memItemLeft" align="right" valign="top"><a id="ae852394cc178fad51c3d5eb7f6064da1" name="ae852394cc178fad51c3d5eb7f6064da1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MeasureCellPerimeters</b> ()</td></tr>
<tr class="memdesc:ae852394cc178fad51c3d5eb7f6064da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Measure the initial cell perimeters Measure cell perimeters of all initial size and assign them to the cells. <br /></td></tr>
<tr class="separator:ae852394cc178fad51c3d5eb7f6064da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626a7d57e20559085dd7d6cb8d523865" id="r_a626a7d57e20559085dd7d6cb8d523865"><td class="memItemLeft" align="right" valign="top"><a id="a626a7d57e20559085dd7d6cb8d523865" name="a626a7d57e20559085dd7d6cb8d523865"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>anneal</b> (int steps)</td></tr>
<tr class="memdesc:a626a7d57e20559085dd7d6cb8d523865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run amoebaemove while only accepting negative delta H. <br /></td></tr>
<tr class="separator:a626a7d57e20559085dd7d6cb8d523865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff7b8b5515e8dc8d21fa8ae4e1d7a4f" id="r_acff7b8b5515e8dc8d21fa8ae4e1d7a4f"><td class="memItemLeft" align="right" valign="top">int **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#acff7b8b5515e8dc8d21fa8ae4e1d7a4f">get_annealed_sigma</a> (int steps)</td></tr>
<tr class="memdesc:acff7b8b5515e8dc8d21fa8ae4e1d7a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the sigma field after annealing steps.  <br /></td></tr>
<tr class="separator:acff7b8b5515e8dc8d21fa8ae4e1d7a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45f5ca6a7461e965a7e90a34922b337" id="r_af45f5ca6a7461e965a7e90a34922b337"><td class="memItemLeft" align="right" valign="top"><a id="af45f5ca6a7461e965a7e90a34922b337" name="af45f5ca6a7461e965a7e90a34922b337"></a>
int **&#160;</td><td class="memItemRight" valign="bottom"><b>getSigma</b> ()</td></tr>
<tr class="separator:af45f5ca6a7461e965a7e90a34922b337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60166888cf558fdca9d0f0163bb6b725" id="r_a60166888cf558fdca9d0f0163bb6b725"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cellular_potts.html#a60166888cf558fdca9d0f0163bb6b725">plotPos</a> (int x, int y, <a class="el" href="class_graphics.html">Graphics</a> *graphics)</td></tr>
<tr class="memdesc:a60166888cf558fdca9d0f0163bb6b725"><td class="mdescLeft">&#160;</td><td class="mdescRight">plot the sigma at (x,y)  <br /></td></tr>
<tr class="separator:a60166888cf558fdca9d0f0163bb6b725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9319311f5e1d357884bf5fc6fbf6cadc" id="r_a9319311f5e1d357884bf5fc6fbf6cadc"><td class="memItemLeft" align="right" valign="top"><a id="a9319311f5e1d357884bf5fc6fbf6cadc" name="a9319311f5e1d357884bf5fc6fbf6cadc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>linePlotPos</b> (int x, int y, <a class="el" href="class_graphics.html">Graphics</a> *graphics)</td></tr>
<tr class="memdesc:a9319311f5e1d357884bf5fc6fbf6cadc"><td class="mdescLeft">&#160;</td><td class="mdescRight">plot cell outlines <br /></td></tr>
<tr class="separator:a9319311f5e1d357884bf5fc6fbf6cadc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c335f33dac20923df380a6d7a90379" id="r_a25c335f33dac20923df380a6d7a90379"><td class="memItemLeft" align="right" valign="top"><a id="a25c335f33dac20923df380a6d7a90379" name="a25c335f33dac20923df380a6d7a90379"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>fillCellColArr</b> (int *arr)</td></tr>
<tr class="separator:a25c335f33dac20923df380a6d7a90379"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a32ac92b625b4aef1313d7e214453d5b7" id="r_a32ac92b625b4aef1313d7e214453d5b7"><td class="memItemLeft" align="right" valign="top"><a id="a32ac92b625b4aef1313d7e214453d5b7" name="a32ac92b625b4aef1313d7e214453d5b7"></a>
std::unordered_set&lt; std::array&lt; int, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>alivePixels</b></td></tr>
<tr class="separator:a32ac92b625b4aef1313d7e214453d5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ad5d02c226035859430b03223bc23b" id="r_a87ad5d02c226035859430b03223bc23b"><td class="memItemLeft" align="right" valign="top"><a id="a87ad5d02c226035859430b03223bc23b" name="a87ad5d02c226035859430b03223bc23b"></a>
std::unordered_map&lt; std::array&lt; int, 2 &gt;, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>actPixels</b></td></tr>
<tr class="separator:a87ad5d02c226035859430b03223bc23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5485bc85171613850c4e5d5bf6b7fa3d" id="r_a5485bc85171613850c4e5d5bf6b7fa3d"><td class="memItemLeft" align="right" valign="top"><a id="a5485bc85171613850c4e5d5bf6b7fa3d" name="a5485bc85171613850c4e5d5bf6b7fa3d"></a>
int **&#160;</td><td class="memItemRight" valign="bottom"><b>matrix</b></td></tr>
<tr class="separator:a5485bc85171613850c4e5d5bf6b7fa3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988007556bb6eb946b51b158551253d6" id="r_a988007556bb6eb946b51b158551253d6"><td class="memItemLeft" align="right" valign="top"><a id="a988007556bb6eb946b51b158551253d6" name="a988007556bb6eb946b51b158551253d6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>spins_converted</b></td></tr>
<tr class="separator:a988007556bb6eb946b51b158551253d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa5ec739e069c82b6a2dfb961b42b9a02" id="r_aa5ec739e069c82b6a2dfb961b42b9a02"><td class="memItemLeft" align="right" valign="top"><a id="aa5ec739e069c82b6a2dfb961b42b9a02" name="aa5ec739e069c82b6a2dfb961b42b9a02"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>BaseInitialization</b> (std::vector&lt; <a class="el" href="class_cell.html">Cell</a> &gt; *cell)</td></tr>
<tr class="memdesc:aa5ec739e069c82b6a2dfb961b42b9a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise CPM class. <br /></td></tr>
<tr class="separator:aa5ec739e069c82b6a2dfb961b42b9a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a917afb990a67fed9b84b5937e2302657" id="r_a917afb990a67fed9b84b5937e2302657"><td class="memItemLeft" align="right" valign="top"><a id="a917afb990a67fed9b84b5937e2302657" name="a917afb990a67fed9b84b5937e2302657"></a>
int **&#160;</td><td class="memItemRight" valign="bottom"><b>sigma</b></td></tr>
<tr class="separator:a917afb990a67fed9b84b5937e2302657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc15e6c75d38e40b7e0bf9e207edec6b" id="r_abc15e6c75d38e40b7e0bf9e207edec6b"><td class="memItemLeft" align="right" valign="top"><a id="abc15e6c75d38e40b7e0bf9e207edec6b" name="abc15e6c75d38e40b7e0bf9e207edec6b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sizex</b></td></tr>
<tr class="separator:abc15e6c75d38e40b7e0bf9e207edec6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d3233d669045680f343176473e946a" id="r_a49d3233d669045680f343176473e946a"><td class="memItemLeft" align="right" valign="top"><a id="a49d3233d669045680f343176473e946a" name="a49d3233d669045680f343176473e946a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>sizey</b></td></tr>
<tr class="separator:a49d3233d669045680f343176473e946a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4838ff865b8d8625c61d208a420f8212" id="r_a4838ff865b8d8625c61d208a420f8212"><td class="memItemLeft" align="right" valign="top"><a id="a4838ff865b8d8625c61d208a420f8212" name="a4838ff865b8d8625c61d208a420f8212"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Info</b></td></tr>
<tr class="separator:a4838ff865b8d8625c61d208a420f8212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2593c600f6299dcd541c319ed4c35e0f" id="r_a2593c600f6299dcd541c319ed4c35e0f"><td class="memItemLeft" align="right" valign="top"><a id="a2593c600f6299dcd541c319ed4c35e0f" name="a2593c600f6299dcd541c319ed4c35e0f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Morphometry</b></td></tr>
<tr class="separator:a2593c600f6299dcd541c319ed4c35e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a19ba4646f7a09b99a6d1b138103fa4b6" name="a19ba4646f7a09b99a6d1b138103fa4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ba4646f7a09b99a6d1b138103fa4b6">&#9670;&#160;</a></span>Act_AmoebaeMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::Act_AmoebaeMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_d_e.html">PDE</a> *&#160;</td>
          <td class="paramname"><em>PDEfield</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements the core CPM algorithm including Act dynamics. Carries out one MCS with the edge lsit algorithmAMo. </p><dl class="section return"><dt>Returns</dt><dd>Total energy change during MCS. </dd></dl>

</div>
</div>
<a id="a669103985248ae144731f7c94724822b" name="a669103985248ae144731f7c94724822b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669103985248ae144731f7c94724822b">&#9670;&#160;</a></span>AllocateSigma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void CellularPotts::AllocateSigma </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates data for the sigma array. </p>
<p>Keyword virtual means, that derived classed (cppvmCellularPotts) can override this function and carry out the memory allocation in their preferred way Every time AllocateSigma is called in the base class methods the function belonging the actual type will be called </p>

</div>
</div>
<a id="a9d5e73910b835fee1171c1fa6c220f73" name="a9d5e73910b835fee1171c1fa6c220f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5e73910b835fee1171c1fa6c220f73">&#9670;&#160;</a></span>AmoebaeMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::AmoebaeMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_d_e.html">PDE</a> *&#160;</td>
          <td class="paramname"><em>PDEfield</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>anneal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Monte Carlo Step. Returns summed energy change. </p>
<p>Implements the core CPM algorithm. Carries out one MCS. </p><dl class="section return"><dt>Returns</dt><dd>Total energy change during MCS. </dd></dl>

</div>
</div>
<a id="aae05936dbf37d5469fe3d88dc365d3e9" name="aae05936dbf37d5469fe3d88dc365d3e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae05936dbf37d5469fe3d88dc365d3e9">&#9670;&#160;</a></span>CellDensity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CellularPotts::CellDensity </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the cell density. </p>
<p><a class="el" href="class_cell.html">Cell</a> density is defined as the area occupied by cells divided by the size of the field. </p>

</div>
</div>
<a id="aa7e044382275fecdefeeeabc0d4de759" name="aa7e044382275fecdefeeeabc0d4de759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7e044382275fecdefeeeabc0d4de759">&#9670;&#160;</a></span>Compactness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CellularPotts::Compactness </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate compactness (summed_area/hull_area) of all cells. This is a good measure for the density. Function allows a bounding box. </p><dl class="section return"><dt>Returns</dt><dd>Compactness. </dd></dl>

</div>
</div>
<a id="a651a2d70d4dd58ce00eaec5ce483c5a5" name="a651a2d70d4dd58ce00eaec5ce483c5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651a2d70d4dd58ce00eaec5ce483c5a5">&#9670;&#160;</a></span>DivideCells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CellularPotts::DivideCells </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt;&#160;</td>
          <td class="paramname"><em>which_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide all cells marked "true" in which_cells. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">which_cells</td><td>is a vector&lt;bool&gt; with the same number of elements as the number of cells. It is a mask indicating which cells should be divided; each cell marked true will be divided.</td></tr>
  </table>
  </dd>
</dl>
<p>If which_cells is empty, this method divides all cells. </p>

</div>
</div>
<a id="aed1233da3a36aae791fda27ed0171306" name="aed1233da3a36aae791fda27ed0171306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1233da3a36aae791fda27ed0171306">&#9670;&#160;</a></span>DrawConvexHull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double CellularPotts::DrawConvexHull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graphics.html">Graphics</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>color</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draw convex hull around all cells. </p><dl class="section return"><dt>Returns</dt><dd>The area of the convex hull in lattice sites. </dd></dl>

</div>
</div>
<a id="a19115b49e9c77e81835938a2f7a00f80" name="a19115b49e9c77e81835938a2f7a00f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19115b49e9c77e81835938a2f7a00f80">&#9670;&#160;</a></span>FindCellDirections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_dir.html">Dir</a> * CellularPotts::FindCellDirections </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In this method the principal axes of the cells are computed using the method described in "Biometry", box 15.5 </p><dl class="section return"><dt>Returns</dt><dd>a pointer to a "new[]"ed array containing the directions. The memory has to be freed afterwards using the delete[] operator </dd></dl>

</div>
</div>
<a id="acff7b8b5515e8dc8d21fa8ae4e1d7a4f" name="acff7b8b5515e8dc8d21fa8ae4e1d7a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff7b8b5515e8dc8d21fa8ae4e1d7a4f">&#9670;&#160;</a></span>get_annealed_sigma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ** CellularPotts::get_annealed_sigma </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>steps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the sigma field after annealing steps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">steps</td><td>Number of annealing MCS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sigma-field after annealing </dd></dl>

</div>
</div>
<a id="a9fe4d50600de429a184627ee7baf1079" name="a9fe4d50600de429a184627ee7baf1079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe4d50600de429a184627ee7baf1079">&#9670;&#160;</a></span>GetActLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::GetActLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the level of act. </p>
<dl class="section return"><dt>Returns</dt><dd>Act concentration </dd></dl>

</div>
</div>
<a id="a92d005dd4af63755bc57cf097ec09b02" name="a92d005dd4af63755bc57cf097ec09b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d005dd4af63755bc57cf097ec09b02">&#9670;&#160;</a></span>GetCellECMInteractions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_cell_e_c_m_interactions.html">CellECMInteractions</a> CellularPotts::GetCellECMInteractions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns changes made to the adhesions since the last reset. </p><dl class="section return"><dt>Returns</dt><dd>The accumulated changes </dd></dl>

</div>
</div>
<a id="a097de27a408be042f2c5c413b2049efa" name="a097de27a408be042f2c5c413b2049efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a097de27a408be042f2c5c413b2049efa">&#9670;&#160;</a></span>GetMatrixLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::GetMatrixLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the level of matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>Matrix concentration concentration </dd></dl>

</div>
</div>
<a id="ad621be8ea38deccef8d6060bddd19f41" name="ad621be8ea38deccef8d6060bddd19f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad621be8ea38deccef8d6060bddd19f41">&#9670;&#160;</a></span>GetNewPerimeterIfXYWereAdded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::GetNewPerimeterIfXYWereAdded </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sxyp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get perimeter if new pixel is added. </p>
<dl class="section return"><dt>Returns</dt><dd>New perimeter </dd></dl>

</div>
</div>
<a id="a2c1568580d7a946eace7fe975939636f" name="a2c1568580d7a946eace7fe975939636f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1568580d7a946eace7fe975939636f">&#9670;&#160;</a></span>GetNewPerimeterIfXYWereRemoved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::GetNewPerimeterIfXYWereRemoved </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get perimeter if pixel is removed. </p>
<dl class="section return"><dt>Returns</dt><dd>New perimeter </dd></dl>

</div>
</div>
<a id="a2b07faf41fd8c395c1f98f98f0c8eeac" name="a2b07faf41fd8c395c1f98f98f0c8eeac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b07faf41fd8c395c1f98f98f0c8eeac">&#9670;&#160;</a></span>GrowAndDivideCells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CellularPotts::GrowAndDivideCells </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>growth_rate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cells grow until twice their original target_length, then divide, with rate "growth_rate" </p>

</div>
</div>
<a id="a6ffb2aad630eaaff5a07b78a810c5c0a" name="a6ffb2aad630eaaff5a07b78a810c5c0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ffb2aad630eaaff5a07b78a810c5c0a">&#9670;&#160;</a></span>GrowInCells() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::GrowInCells </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cell_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the CA plane with n cells using an Eden growth algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of cells. </td></tr>
    <tr><td class="paramname">cell_size</td><td>Number of Eden growth iterations. </td></tr>
    <tr><td class="paramname">sx</td><td>x-size of subfield. </td></tr>
    <tr><td class="paramname">sy</td><td>y-size of subfield. </td></tr>
    <tr><td class="paramname">offset_x</td><td>x location for subfield. </td></tr>
    <tr><td class="paramname">offset_y</td><td>y location for subfield. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of last cell inserted. </dd></dl>

</div>
</div>
<a id="adaa7d7a5ba27ae620ed66f5eb9564257" name="adaa7d7a5ba27ae620ed66f5eb9564257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa7d7a5ba27ae620ed66f5eb9564257">&#9670;&#160;</a></span>GrowInCells() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::GrowInCells </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cellsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>subfield</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posx</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>posy</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the subfield in which eden growth takes place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of cells. </td></tr>
    <tr><td class="paramname">cellsize</td><td>Number of Eden growth iterations. </td></tr>
    <tr><td class="paramname">subfield</td><td>Defines a centered frame of size (size/subfield)^2 in which all cell will be positioned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of last cell inserted. </dd></dl>

</div>
</div>
<a id="af7cd87909d465133cdecc1d80f4347fd" name="af7cd87909d465133cdecc1d80f4347fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7cd87909d465133cdecc1d80f4347fd">&#9670;&#160;</a></span>InitialiseEdgeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CellularPotts::InitialiseEdgeList </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialises the edgelist at the beginning of a simulation. </p>
<p>The edgelist keeps track of pairs of lattice points that are eligible to change the CPM configuration. This function initialises the edgelist at the start. </p>

</div>
</div>
<a id="a080c719d169997556834fdc0dbe247a6" name="a080c719d169997556834fdc0dbe247a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080c719d169997556834fdc0dbe247a6">&#9670;&#160;</a></span>IsingMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::IsingMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_d_e.html">PDE</a> *&#160;</td>
          <td class="paramname"><em>PDEfield</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Monte Carlo Step. Returns summed energy change. </p>
<p>Implements Metropolis dynamics for the Ising model. Carries out one MCS. </p><dl class="section return"><dt>Returns</dt><dd>Total energy change during MCS. </dd></dl>

</div>
</div>
<a id="a74b82f8fb894878d242defd1883da849" name="a74b82f8fb894878d242defd1883da849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b82f8fb894878d242defd1883da849">&#9670;&#160;</a></span>KawasakiMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::KawasakiMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_d_e.html">PDE</a> *&#160;</td>
          <td class="paramname"><em>PDEfield</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Monte Carlo Step. Returns summed energy change. </p>
<p>Implements the core CPM algorithm with Kawasaki dynamics. Carries out one MCS. </p><dl class="section return"><dt>Returns</dt><dd>Total energy change during MCS. </dd></dl>

</div>
</div>
<a id="ad3bec6a234220d4fbaf04f9ed3a5be27" name="ad3bec6a234220d4fbaf04f9ed3a5be27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bec6a234220d4fbaf04f9ed3a5be27">&#9670;&#160;</a></span>PlotIsing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CellularPotts::PlotIsing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graphics.html">Graphics</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special plotting for Ising model Only plot lines between the two states. </p>
<p>Plot in black &amp; white for the Ising model </p>

</div>
</div>
<a id="a60166888cf558fdca9d0f0163bb6b725" name="a60166888cf558fdca9d0f0163bb6b725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60166888cf558fdca9d0f0163bb6b725">&#9670;&#160;</a></span>plotPos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool CellularPotts::plotPos </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_graphics.html">Graphics</a> *&#160;</td>
          <td class="paramname"><em>graphics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>plot the sigma at (x,y) </p>
<dl class="section return"><dt>Returns</dt><dd>True if cell belongs to medium </dd></dl>

</div>
</div>
<a id="a0866b5925006bafd9c492fcd52302415" name="a0866b5925006bafd9c492fcd52302415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0866b5925006bafd9c492fcd52302415">&#9670;&#160;</a></span>PlotSigma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CellularPotts::PlotSigma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graphics.html">Graphics</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mag</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plot the cells according to their cell identity, not their type. The black lines are omitted. </p>
<p>A simple method to plot all sigma's in window without the black lines </p>

</div>
</div>
<a id="a83e3eb01edd9531cc0f2ee43e3cfe581" name="a83e3eb01edd9531cc0f2ee43e3cfe581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e3eb01edd9531cc0f2ee43e3cfe581">&#9670;&#160;</a></span>PottsMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::PottsMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_d_e.html">PDE</a> *&#160;</td>
          <td class="paramname"><em>PDEfield</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Monte Carlo Step. Returns summed energy change. </p>
<p>Implements standard large q-Potts model. Carries out one MCS. </p><dl class="section return"><dt>Returns</dt><dd>Total energy change during MCS. </dd></dl>

</div>
</div>
<a id="a394d1982f7eb760c2ad0e4a119f2b354" name="a394d1982f7eb760c2ad0e4a119f2b354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a394d1982f7eb760c2ad0e4a119f2b354">&#9670;&#160;</a></span>PottsNeighbourMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::PottsNeighbourMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_p_d_e.html">PDE</a> *&#160;</td>
          <td class="paramname"><em>PDEfield</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Monte Carlo Step. Returns summed energy change. </p>
<p>Implements standard large q-Potts model via Neighbour copies. Carries out one MCS. </p><dl class="section return"><dt>Returns</dt><dd>Total energy change during MCS. </dd></dl>

</div>
</div>
<a id="a49ac68f926e575d4b56b325dacecbb6d" name="a49ac68f926e575d4b56b325dacecbb6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ac68f926e575d4b56b325dacecbb6d">&#9670;&#160;</a></span>RandomSigma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CellularPotts::RandomSigma </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign random sigma to every lattice point. </p>
<dl class="section user"><dt>n_cells: total number of cells</dt><dd></dd></dl>

</div>
</div>
<a id="a4e7493532f148c65d960e65a8c131590" name="a4e7493532f148c65d960e65a8c131590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7493532f148c65d960e65a8c131590">&#9670;&#160;</a></span>RandomSpins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CellularPotts::RandomSpins </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>prob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise cpm field with a random sigma of 0 or 1 of every pixel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prob</td><td>This fraction of pixels will be a medium pixel </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a704dfea7f85ca5939899e617266a2b39" name="a704dfea7f85ca5939899e617266a2b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704dfea7f85ca5939899e617266a2b39">&#9670;&#160;</a></span>ResetCellECMInteractions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CellularPotts::ResetCellECMInteractions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears recorded changes to the adhesions. </p>

</div>
</div>
<a id="a747d71d26a03ced7b61f6a43cc8dbdbb" name="a747d71d26a03ced7b61f6a43cc8dbdbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747d71d26a03ced7b61f6a43cc8dbdbb">&#9670;&#160;</a></span>SearchNandPlot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ** CellularPotts::SearchNandPlot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graphics.html">Graphics</a> *&#160;</td>
          <td class="paramname"><em>g</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>get_neighbours</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Plots the dish to the screen or to a movie and searches the neighbours. </p>
<p>These distinct tasks have been lumped together in the same method because both for drawing the black lines between the cells and for searching the neighbours the cell borders have to be determined.</p>
<dl class="section return"><dt>Returns</dt><dd>neighborhood array </dd></dl>

</div>
</div>
<a id="a4e386f5813077b558c7f72d0d78712af" name="a4e386f5813077b558c7f72d0d78712af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e386f5813077b558c7f72d0d78712af">&#9670;&#160;</a></span>SearchNeighboursMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ** CellularPotts::SearchNeighboursMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the neighbour matrix of cells. </p>
<dl class="section return"><dt>Returns</dt><dd>Neighborhood array </dd></dl>

</div>
</div>
<a id="a4ae795cc3226bd4711986861b4c072e6" name="a4ae795cc3226bd4711986861b4c072e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae795cc3226bd4711986861b4c072e6">&#9670;&#160;</a></span>SetECMBoundaryState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CellularPotts::SetECMBoundaryState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_e_c_m_boundary_state.html">ECMBoundaryState</a> const &amp;&#160;</td>
          <td class="paramname"><em>ecm_boundary_state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set ECM boundary state, overwriting the current state. </p>

</div>
</div>
<a id="a3ce57d56c6e561ded805e13851d06c63" name="a3ce57d56c6e561ded805e13851d06c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce57d56c6e561ded805e13851d06c63">&#9670;&#160;</a></span>ShowDirections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CellularPotts::ShowDirections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_graphics.html">Graphics</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_dir.html">Dir</a> *&#160;</td>
          <td class="paramname"><em>celldir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display the division planes returned by FindCellDirections. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td><a class="el" href="class_graphics.html" title="API for Graphics windows.">Graphics</a> window </td></tr>
    <tr><td class="paramname">celldir</td><td>cell axes as returned by FindCellDirections. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5bbce2aae8baeead6cf173dd3d81d02" name="af5bbce2aae8baeead6cf173dd3d81d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bbce2aae8baeead6cf173dd3d81d02">&#9670;&#160;</a></span>Sigma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::Sigma </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the value of lattice site (x,y). </p>
<p>i.e. This will return the index of the cell which occupies site (x,y). </p>

</div>
</div>
<a id="abe734e8295788f92fcc21f4188a83dde" name="abe734e8295788f92fcc21f4188a83dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe734e8295788f92fcc21f4188a83dde">&#9670;&#160;</a></span>SquareCell()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::SquareCell </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a square cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sig</td><td>sigma value of the cell </td></tr>
    <tr><td class="paramname">cx</td><td>x-coordinate of the cell </td></tr>
    <tr><td class="paramname">cy</td><td>y-coordinate of the cell </td></tr>
    <tr><td class="paramname">size</td><td>length of the square cells</td></tr>
  </table>
  </dd>
</dl>
<p>Draw a square cell in at (cx,cy) </p>

</div>
</div>
<a id="a568014835d075361e62ec6d2489a7db3" name="a568014835d075361e62ec6d2489a7db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568014835d075361e62ec6d2489a7db3">&#9670;&#160;</a></span>ThrowInCells()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int CellularPotts::ThrowInCells </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cellsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the CA plane with n circular cells fitting in a cellsize^2 square. </p>
<p>! Fill the plane with initial cells </p><dl class="section return"><dt>Returns</dt><dd>actual amount of cells (some are not draw due to overlap) </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/Users/koenkeijzer/Documents/CPM/Tissue-Simulation-Toolkit/src/cellular_potts/<a class="el" href="ca_8hpp_source.html">ca.hpp</a></li>
<li>/Users/koenkeijzer/Documents/CPM/Tissue-Simulation-Toolkit/src/cellular_potts/<b>ca.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
