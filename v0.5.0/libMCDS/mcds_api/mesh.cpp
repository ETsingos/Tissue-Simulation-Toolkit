// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "mesh.hpp"

#include <stdlib.h>
#include <new>

#include <xsde/cxx/guard.hxx>

namespace mesh
{
  // bounding_box
  //

  bounding_box::
  bounding_box ()
  {
    this->type_present_ = false;
  }

  bounding_box::
  ~bounding_box ()
  {
  }

  void bounding_box::
  _copy (bounding_box& c) const
  {
    XSDE_UNUSED (c);

    const ::common::units_double_list& b = *this;
    b._copy (c);
    if (this->type_present ())
      c.type (this->type ());
  }

  bounding_box* bounding_box::
  _clone () const
  {
    bounding_box* c = new bounding_box;
    ::xsde::cxx::guard< bounding_box > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // mesh
  //

  mesh::
  mesh ()
  {
    this->type_present_ = false;
    this->uniform_present_ = false;
    this->regular_present_ = false;
    this->units_present_ = false;
    this->bounding_box_ = 0;
    this->x_coordinates_ = 0;
    this->y_coordinates_ = 0;
    this->z_coordinates_ = 0;
    this->voxels_ = 0;
    this->custom_ = 0;
  }

  mesh::
  ~mesh ()
  {
    delete this->bounding_box_;
    delete this->x_coordinates_;
    delete this->y_coordinates_;
    delete this->z_coordinates_;
    delete this->voxels_;
    delete this->custom_;
  }

  void mesh::
  _copy (mesh& c) const
  {
    XSDE_UNUSED (c);

    if (this->type_present ())
      c.type (this->type ());

    if (this->uniform_present ())
      c.uniform (this->uniform ());

    if (this->regular_present ())
      c.regular (this->regular ());

    if (this->units_present ())
      c.units (this->units ());

    if (this->bounding_box_present ())
    {
      ::mesh::bounding_box* m = this->bounding_box ()._clone ();
      c.bounding_box (m);
    }

    if (this->x_coordinates_present ())
    {
      ::common::units_double_list* m = this->x_coordinates ()._clone ();
      c.x_coordinates (m);
    }

    if (this->y_coordinates_present ())
    {
      ::common::units_double_list* m = this->y_coordinates ()._clone ();
      c.y_coordinates (m);
    }

    if (this->z_coordinates_present ())
    {
      ::common::units_double_list* m = this->z_coordinates ()._clone ();
      c.z_coordinates (m);
    }

    if (this->voxels_present ())
    {
      ::mesh::list_of_voxels* m = this->voxels ()._clone ();
      c.voxels (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  mesh* mesh::
  _clone () const
  {
    mesh* c = new mesh;
    ::xsde::cxx::guard< mesh > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // list_of_voxels
  //

  list_of_voxels::
  list_of_voxels ()
  {
    this->type_present_ = false;
    this->filename_present_ = false;
    this->custom_ = 0;
  }

  list_of_voxels::
  ~list_of_voxels ()
  {
    delete this->custom_;
  }

  void list_of_voxels::
  _copy (list_of_voxels& c) const
  {
    XSDE_UNUSED (c);

    if (this->type_present ())
      c.type (this->type ());

    if (this->filename_present ())
      c.filename (this->filename ());

    this->voxel ().copy (c.voxel ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  list_of_voxels* list_of_voxels::
  _clone () const
  {
    list_of_voxels* c = new list_of_voxels;
    ::xsde::cxx::guard< list_of_voxels > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // voxel
  //

  voxel::
  voxel ()
  {
    this->ID_present_ = false;
    this->type_present_ = false;
    this->center_ = 0;
    this->volume_ = 0;
    this->custom_ = 0;
  }

  voxel::
  ~voxel ()
  {
    delete this->center_;
    delete this->volume_;
    delete this->custom_;
  }

  void voxel::
  _copy (voxel& c) const
  {
    XSDE_UNUSED (c);

    if (this->ID_present ())
      c.ID (this->ID ());

    if (this->type_present ())
      c.type (this->type ());

    {
      ::common::units_double_list* m = this->center ()._clone ();
      c.center (m);
    }

    {
      ::common::units_decimal_nonnegative* m = this->volume ()._clone ();
      c.volume (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  voxel* voxel::
  _clone () const
  {
    voxel* c = new voxel;
    ::xsde::cxx::guard< voxel > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // node
  //

  node::
  node ()
  {
    this->ID_present_ = false;
    this->position_ = 0;
    this->custom_ = 0;
  }

  node::
  ~node ()
  {
    delete this->position_;
    delete this->custom_;
  }

  void node::
  _copy (node& c) const
  {
    XSDE_UNUSED (c);

    if (this->ID_present ())
      c.ID (this->ID ());

    {
      ::common::units_double_list* m = this->position ()._clone ();
      c.position (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  node* node::
  _clone () const
  {
    node* c = new node;
    ::xsde::cxx::guard< node > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  static const ::std::string _xsde_node_static_type_ = "node mesh";

  const ::std::string& node::
  _static_type ()
  {
    return _xsde_node_static_type_;
  }

  const ::std::string& node::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // edge
  //

  edge::
  edge ()
  {
    this->ID_present_ = false;
  }

  edge::
  ~edge ()
  {
  }

  void edge::
  _copy (edge& c) const
  {
    XSDE_UNUSED (c);

    if (this->ID_present ())
      c.ID (this->ID ());

    this->node_ID ().copy (c.node_ID ());
  }

  edge* edge::
  _clone () const
  {
    edge* c = new edge;
    ::xsde::cxx::guard< edge > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // face
  //

  face::
  face ()
  {
    this->ID_present_ = false;
  }

  face::
  ~face ()
  {
  }

  void face::
  _copy (face& c) const
  {
    XSDE_UNUSED (c);

    if (this->ID_present ())
      c.ID (this->ID ());

    this->edge_ID ().copy (c.edge_ID ());
  }

  face* face::
  _clone () const
  {
    face* c = new face;
    ::xsde::cxx::guard< face > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // int_list_xpath
  //

  int_list_xpath::
  int_list_xpath ()
  {
    this->xpath_present_ = false;
    this->grouping_number_present_ = false;
  }

  int_list_xpath::
  ~int_list_xpath ()
  {
  }

  void int_list_xpath::
  _copy (int_list_xpath& c) const
  {
    XSDE_UNUSED (c);

    const ::common::unsigned_int_list& b = *this;
    b._copy (c);
    if (this->xpath_present ())
      c.xpath (this->xpath ());

    if (this->grouping_number_present ())
      c.grouping_number (this->grouping_number ());
  }

  int_list_xpath* int_list_xpath::
  _clone () const
  {
    int_list_xpath* c = new int_list_xpath;
    ::xsde::cxx::guard< int_list_xpath > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

