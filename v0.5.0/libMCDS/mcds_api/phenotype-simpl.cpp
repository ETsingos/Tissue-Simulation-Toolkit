// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "phenotype-simpl.hpp"

namespace phenotype
{
  // phenotype_elements_simpl
  //

  phenotype_elements_simpl::
  phenotype_elements_simpl ()
  : phenotype_elements_sskel (&base_impl_)
  {
  }

  void phenotype_elements_simpl::
  pre (const ::phenotype::phenotype_elements& x)
  {
    this->base_impl_.pre (x);
    this->phenotype_elements_simpl_state_.phenotype_elements_ = &x;
  }

  bool phenotype_elements_simpl::
  adhesion_present ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->adhesion_present ();
  }

  const ::phenotype_common::adhesion& phenotype_elements_simpl::
  adhesion ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->adhesion ();
  }

  bool phenotype_elements_simpl::
  geometrical_properties_present ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->geometrical_properties_present ();
  }

  const ::phenotype_common::geometrical_properties& phenotype_elements_simpl::
  geometrical_properties ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->geometrical_properties ();
  }

  bool phenotype_elements_simpl::
  mass_present ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->mass_present ();
  }

  const ::phenotype_common::mass& phenotype_elements_simpl::
  mass ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->mass ();
  }

  bool phenotype_elements_simpl::
  mechanics_present ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->mechanics_present ();
  }

  const ::phenotype_common::mechanics& phenotype_elements_simpl::
  mechanics ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->mechanics ();
  }

  bool phenotype_elements_simpl::
  motility_present ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->motility_present ();
  }

  const ::phenotype_common::motility& phenotype_elements_simpl::
  motility ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->motility ();
  }

  bool phenotype_elements_simpl::
  PKPD_present ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->PKPD_present ();
  }

  const ::pkpd::PKPD& phenotype_elements_simpl::
  PKPD ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->PKPD ();
  }

  bool phenotype_elements_simpl::
  timescale_present ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->timescale_present ();
  }

  const ::phenotype_base::expected_timescale& phenotype_elements_simpl::
  timescale ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->timescale ();
  }

  bool phenotype_elements_simpl::
  transport_processes_present ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->transport_processes_present ();
  }

  const ::phenotype_common::transport_processes& phenotype_elements_simpl::
  transport_processes ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->transport_processes ();
  }

  bool phenotype_elements_simpl::
  custom_present ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->custom_present ();
  }

  const ::common::custom& phenotype_elements_simpl::
  custom ()
  {
    return this->phenotype_elements_simpl_state_.phenotype_elements_->custom ();
  }

  // phenotype_simpl
  //

  phenotype_simpl::
  phenotype_simpl ()
  : phenotype_sskel (&base_impl_)
  {
  }

  void phenotype_simpl::
  pre (const ::phenotype::phenotype& x)
  {
    this->base_impl_.pre (x);
    this->phenotype_simpl_state_.phenotype_ = &x;
  }

  bool phenotype_simpl::
  type_present ()
  {
    return this->phenotype_simpl_state_.phenotype_->type_present ();
  }

  const ::phenotype_base::phenotype_type& phenotype_simpl::
  type ()
  {
    return this->phenotype_simpl_state_.phenotype_->type ();
  }
}

// Begin epilogue.
//
//
// End epilogue.

