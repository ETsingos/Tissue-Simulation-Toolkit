// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "metadata.hpp"

#include <stdlib.h>
#include <new>

#include <xsde/cxx/guard.hxx>

namespace metadata
{
  // URL
  //

  URL::
  URL ()
  {
  }

  // orcid-identifier
  //

  orcid_identifier::
  orcid_identifier ()
  {
    this->path_present_ = false;
    this->given_names_present_ = false;
    this->family_name_present_ = false;
    this->email_present_ = false;
    this->url_present_ = false;
    this->organization_name_present_ = false;
    this->department_name_present_ = false;
  }

  orcid_identifier::
  ~orcid_identifier ()
  {
  }

  orcid_identifier::
  orcid_identifier (const orcid_identifier& x)
  {
    XSDE_UNUSED (x);
    this->path_present_ = x.path_present_;
    if (this->path_present_)
      this->path_ = x.path_;
    this->given_names_present_ = x.given_names_present_;
    if (this->given_names_present_)
      this->given_names_ = x.given_names_;
    this->family_name_present_ = x.family_name_present_;
    if (this->family_name_present_)
      this->family_name_ = x.family_name_;
    this->email_present_ = x.email_present_;
    if (this->email_present_)
      this->email_ = x.email_;
    this->url_present_ = x.url_present_;
    if (this->url_present_)
      this->url_ = x.url_;
    this->organization_name_present_ = x.organization_name_present_;
    if (this->organization_name_present_)
      this->organization_name_ = x.organization_name_;
    this->department_name_present_ = x.department_name_present_;
    if (this->department_name_present_)
      this->department_name_ = x.department_name_;
  }

  orcid_identifier& orcid_identifier::
  operator= (const orcid_identifier& x)
  {
    XSDE_UNUSED (x);
    this->path_present_ = x.path_present_;
    if (this->path_present_)
      this->path_ = x.path_;
    this->given_names_present_ = x.given_names_present_;
    if (this->given_names_present_)
      this->given_names_ = x.given_names_;
    this->family_name_present_ = x.family_name_present_;
    if (this->family_name_present_)
      this->family_name_ = x.family_name_;
    this->email_present_ = x.email_present_;
    if (this->email_present_)
      this->email_ = x.email_;
    this->url_present_ = x.url_present_;
    if (this->url_present_)
      this->url_ = x.url_;
    this->organization_name_present_ = x.organization_name_present_;
    if (this->organization_name_present_)
      this->organization_name_ = x.organization_name_;
    this->department_name_present_ = x.department_name_present_;
    if (this->department_name_present_)
      this->department_name_ = x.department_name_;
    return *this;
  }

  // orcid-person
  //

  orcid_person::
  orcid_person ()
  {
  }

  orcid_person::
  ~orcid_person ()
  {
  }

  void orcid_person::
  _copy (orcid_person& c) const
  {
    XSDE_UNUSED (c);

    this->orcid_identifier ().copy (c.orcid_identifier ());
  }

  orcid_person* orcid_person::
  _clone () const
  {
    orcid_person* c = new orcid_person;
    ::xsde::cxx::guard< orcid_person > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // classification
  //

  classification::
  classification ()
  {
  }

  classification::
  ~classification ()
  {
  }

  classification::
  classification (const classification& x)
  {
    XSDE_UNUSED (x);
    this->classification_number_ = x.classification_number_;
    this->line_ = x.line_;
    this->variant_ = x.variant_;
    this->branch_ = x.branch_;
    this->version_ = x.version_;
  }

  classification& classification::
  operator= (const classification& x)
  {
    XSDE_UNUSED (x);
    this->classification_number_ = x.classification_number_;
    this->line_ = x.line_;
    this->variant_ = x.variant_;
    this->branch_ = x.branch_;
    this->version_ = x.version_;
    return *this;
  }

  // curation
  //

  curation::
  curation ()
  {
    this->curated_present_ = false;
    this->choice_arm_ = choice_arm_tag (2);
    this->creator_ = 0;
    this->current_contact_ = 0;
    this->curator_ = 0;
    this->last_modified_by_ = 0;
  }

  curation::
  ~curation ()
  {
    this->choice_arm (choice_arm_tag (2));
    delete this->creator_;
    delete this->current_contact_;
    delete this->curator_;
    delete this->last_modified_by_;
  }

  void curation::
  choice_arm (choice_arm_tag x)
  {
    if (this->choice_arm_ == x)
      return;

    switch (this->choice_arm_)
    {
      case classification_tag:
      {
        typedef ::metadata::classification _dtor;
        reinterpret_cast< ::metadata::classification& > (this->choice_.classification_).~_dtor ();
        break;
      }
      case version_tag:
      {
        typedef ::std::string _dtor;
        reinterpret_cast< ::std::string& > (this->choice_.version_).~_dtor ();
        break;
      }
      default:
      break;
    }

    this->choice_arm_ = choice_arm_tag (2);

    switch (x)
    {
      case classification_tag:
      {
        new (&this->choice_.classification_) ::metadata::classification;
        break;
      }
      case version_tag:
      {
        new (&this->choice_.version_) ::std::string;
        break;
      }
      default:
      break;
    }

    this->choice_arm_ = x;
  }

  void curation::
  _copy (curation& c) const
  {
    XSDE_UNUSED (c);

    if (this->curated_present ())
      c.curated (this->curated ());

    c.created (this->created ());

    c.last_modified (this->last_modified ());

    c.choice_arm (this->choice_arm ());

    switch (this->choice_arm ())
    {
      case classification_tag:
      {
        c.classification (this->classification ());

        break;
      }
      case version_tag:
      {
        c.version (this->version ());

        break;
      }
      default:
      break;
    }

    {
      ::metadata::orcid_person* m = this->creator ()._clone ();
      c.creator (m);
    }

    {
      ::metadata::orcid_person* m = this->current_contact ()._clone ();
      c.current_contact (m);
    }

    if (this->curator_present ())
    {
      ::metadata::orcid_person* m = this->curator ()._clone ();
      c.curator (m);
    }

    {
      ::metadata::orcid_person* m = this->last_modified_by ()._clone ();
      c.last_modified_by (m);
    }
  }

  curation* curation::
  _clone () const
  {
    curation* c = new curation;
    ::xsde::cxx::guard< curation > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // citation
  //

  citation::
  citation ()
  {
    this->text_present_ = false;
    this->DOI_present_ = false;
    this->PMID_present_ = false;
    this->PMCID_present_ = false;
    this->arXiv_present_ = false;
    this->notes_present_ = false;
    this->custom_ = 0;
  }

  citation::
  ~citation ()
  {
    delete this->custom_;
  }

  void citation::
  _copy (citation& c) const
  {
    XSDE_UNUSED (c);

    if (this->text_present ())
      c.text (this->text ());

    if (this->DOI_present ())
      c.DOI (this->DOI ());

    this->URL ().copy (c.URL ());

    if (this->PMID_present ())
      c.PMID (this->PMID ());

    if (this->PMCID_present ())
      c.PMCID (this->PMCID ());

    if (this->arXiv_present ())
      c.arXiv (this->arXiv ());

    if (this->notes_present ())
      c.notes (this->notes ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  citation* citation::
  _clone () const
  {
    citation* c = new citation;
    ::xsde::cxx::guard< citation > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // data_origin
  //

  data_origin::
  data_origin ()
  {
    this->ID_present_ = false;
    this->instrumentation_information_present_ = false;
    this->experimental_protocol_present_ = false;
    this->xpath_present_ = false;
    this->notes_present_ = false;
    this->custom_ = 0;
  }

  data_origin::
  ~data_origin ()
  {
    delete this->custom_;
  }

  void data_origin::
  _copy (data_origin& c) const
  {
    XSDE_UNUSED (c);

    if (this->ID_present ())
      c.ID (this->ID ());

    if (this->instrumentation_information_present ())
      c.instrumentation_information (this->instrumentation_information ());

    if (this->experimental_protocol_present ())
      c.experimental_protocol (this->experimental_protocol ());

    this->citation ().copy (c.citation ());

    if (this->xpath_present ())
      c.xpath (this->xpath ());

    if (this->notes_present ())
      c.notes (this->notes ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  data_origin* data_origin::
  _clone () const
  {
    data_origin* c = new data_origin;
    ::xsde::cxx::guard< data_origin > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // data_origins
  //

  data_origins::
  data_origins ()
  {
    this->custom_ = 0;
  }

  data_origins::
  ~data_origins ()
  {
    delete this->custom_;
  }

  void data_origins::
  _copy (data_origins& c) const
  {
    XSDE_UNUSED (c);

    this->data_origin ().copy (c.data_origin ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  data_origins* data_origins::
  _clone () const
  {
    data_origins* c = new data_origins;
    ::xsde::cxx::guard< data_origins > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // data_analysis
  //

  data_analysis::
  data_analysis ()
  {
    this->URL_present_ = false;
    this->citation_ = 0;
    this->software_ = 0;
    this->xpath_present_ = false;
    this->notes_present_ = false;
    this->custom_ = 0;
  }

  data_analysis::
  ~data_analysis ()
  {
    delete this->citation_;
    delete this->software_;
    delete this->custom_;
  }

  void data_analysis::
  _copy (data_analysis& c) const
  {
    XSDE_UNUSED (c);

    if (this->URL_present ())
      c.URL (this->URL ());

    if (this->citation_present ())
    {
      ::metadata::citation* m = this->citation ()._clone ();
      c.citation (m);
    }

    if (this->software_present ())
    {
      ::metadata::software* m = this->software ()._clone ();
      c.software (m);
    }

    if (this->xpath_present ())
      c.xpath (this->xpath ());

    if (this->notes_present ())
      c.notes (this->notes ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  data_analysis* data_analysis::
  _clone () const
  {
    data_analysis* c = new data_analysis;
    ::xsde::cxx::guard< data_analysis > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // software
  //

  software::
  software ()
  {
    this->software_name_present_ = false;
    this->software_version_present_ = false;
    this->software_input_configuration_ = 0;
    this->name_present_ = false;
    this->version_present_ = false;
    this->input_configuration_ = 0;
    this->URL_present_ = false;
    this->creator_ = 0;
    this->citation_ = 0;
    this->user_ = 0;
    this->custom_ = 0;
  }

  software::
  ~software ()
  {
    delete this->software_input_configuration_;
    delete this->input_configuration_;
    delete this->creator_;
    delete this->citation_;
    delete this->user_;
    delete this->custom_;
  }

  void software::
  _copy (software& c) const
  {
    XSDE_UNUSED (c);

    if (this->software_name_present ())
      c.software_name (this->software_name ());

    if (this->software_version_present ())
      c.software_version (this->software_version ());

    if (this->software_input_configuration_present ())
    {
      ::common::custom* m = this->software_input_configuration ()._clone ();
      c.software_input_configuration (m);
    }

    if (this->name_present ())
      c.name (this->name ());

    if (this->version_present ())
      c.version (this->version ());

    if (this->input_configuration_present ())
    {
      ::common::custom* m = this->input_configuration ()._clone ();
      c.input_configuration (m);
    }

    if (this->URL_present ())
      c.URL (this->URL ());

    if (this->creator_present ())
    {
      ::metadata::orcid_person* m = this->creator ()._clone ();
      c.creator (m);
    }

    if (this->citation_present ())
    {
      ::metadata::citation* m = this->citation ()._clone ();
      c.citation (m);
    }

    if (this->user_present ())
    {
      ::metadata::orcid_person* m = this->user ()._clone ();
      c.user (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  software* software::
  _clone () const
  {
    software* c = new software;
    ::xsde::cxx::guard< software > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // patient_derived
  //

  patient_derived::
  patient_derived ()
  {
    this->patient_ID_present_ = false;
  }

  patient_derived::
  ~patient_derived ()
  {
  }

  patient_derived::
  patient_derived (const patient_derived& x)
  : ::xml_schema::boolean_base (x)
  {
    XSDE_UNUSED (x);
    this->patient_ID_present_ = x.patient_ID_present_;
    if (this->patient_ID_present_)
      this->patient_ID_ = x.patient_ID_;
  }

  patient_derived& patient_derived::
  operator= (const patient_derived& x)
  {
    XSDE_UNUSED (x);
    static_cast< ::xml_schema::boolean_base& > (*this) = x;
    this->patient_ID_present_ = x.patient_ID_present_;
    if (this->patient_ID_present_)
      this->patient_ID_ = x.patient_ID_;
    return *this;
  }

  // species
  //

  species::
  species ()
  {
    this->MeSH_ID_present_ = false;
  }

  species::
  ~species ()
  {
  }

  species::
  species (const species& x)
  : ::std::string (x)
  {
    XSDE_UNUSED (x);
    this->MeSH_ID_present_ = x.MeSH_ID_present_;
    if (this->MeSH_ID_present_)
      this->MeSH_ID_ = x.MeSH_ID_;
  }

  species& species::
  operator= (const species& x)
  {
    XSDE_UNUSED (x);
    static_cast< ::std::string& > (*this) = x;
    this->MeSH_ID_present_ = x.MeSH_ID_present_;
    if (this->MeSH_ID_present_)
      this->MeSH_ID_ = x.MeSH_ID_;
    return *this;
  }

  // disease
  //

  disease::
  disease ()
  {
    this->EFO_ID_present_ = false;
    this->DOID_ID_present_ = false;
  }

  disease::
  ~disease ()
  {
  }

  disease::
  disease (const disease& x)
  : ::std::string (x)
  {
    XSDE_UNUSED (x);
    this->EFO_ID_present_ = x.EFO_ID_present_;
    if (this->EFO_ID_present_)
      this->EFO_ID_ = x.EFO_ID_;
    this->DOID_ID_present_ = x.DOID_ID_present_;
    if (this->DOID_ID_present_)
      this->DOID_ID_ = x.DOID_ID_;
  }

  disease& disease::
  operator= (const disease& x)
  {
    XSDE_UNUSED (x);
    static_cast< ::std::string& > (*this) = x;
    this->EFO_ID_present_ = x.EFO_ID_present_;
    if (this->EFO_ID_present_)
      this->EFO_ID_ = x.EFO_ID_;
    this->DOID_ID_present_ = x.DOID_ID_present_;
    if (this->DOID_ID_present_)
      this->DOID_ID_ = x.DOID_ID_;
    return *this;
  }

  // cell_origin
  //

  cell_origin::
  cell_origin ()
  {
    this->BTO_ID_present_ = false;
    this->CLO_ID_present_ = false;
    this->species_present_ = false;
    this->strain_present_ = false;
    this->organ_present_ = false;
    this->disease_present_ = false;
    this->morphology_present_ = false;
    this->patient_derived_present_ = false;
    this->custom_ = 0;
  }

  cell_origin::
  ~cell_origin ()
  {
    delete this->custom_;
  }

  void cell_origin::
  _copy (cell_origin& c) const
  {
    XSDE_UNUSED (c);

    if (this->BTO_ID_present ())
      c.BTO_ID (this->BTO_ID ());

    if (this->CLO_ID_present ())
      c.CLO_ID (this->CLO_ID ());

    if (this->species_present ())
      c.species (this->species ());

    if (this->strain_present ())
      c.strain (this->strain ());

    if (this->organ_present ())
      c.organ (this->organ ());

    if (this->disease_present ())
      c.disease (this->disease ());

    if (this->morphology_present ())
      c.morphology (this->morphology ());

    if (this->patient_derived_present ())
      c.patient_derived (this->patient_derived ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  cell_origin* cell_origin::
  _clone () const
  {
    cell_origin* c = new cell_origin;
    ::xsde::cxx::guard< cell_origin > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // MultiCellDB
  //

  MultiCellDB::
  MultiCellDB ()
  {
    this->ID_present_ = false;
    this->name_present_ = false;
  }

  MultiCellDB::
  ~MultiCellDB ()
  {
  }

  MultiCellDB::
  MultiCellDB (const MultiCellDB& x)
  {
    XSDE_UNUSED (x);
    this->ID_present_ = x.ID_present_;
    if (this->ID_present_)
      this->ID_ = x.ID_;
    this->name_present_ = x.name_present_;
    if (this->name_present_)
      this->name_ = x.name_;
  }

  MultiCellDB& MultiCellDB::
  operator= (const MultiCellDB& x)
  {
    XSDE_UNUSED (x);
    this->ID_present_ = x.ID_present_;
    if (this->ID_present_)
      this->ID_ = x.ID_;
    this->name_present_ = x.name_present_;
    if (this->name_present_)
      this->name_ = x.name_;
    return *this;
  }

  // rights
  //

  rights::
  rights ()
  {
    this->custom_ = 0;
  }

  rights::
  ~rights ()
  {
    delete this->custom_;
  }

  void rights::
  _copy (rights& c) const
  {
    XSDE_UNUSED (c);

    this->license ().copy (c.license ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  rights* rights::
  _clone () const
  {
    rights* c = new rights;
    ::xsde::cxx::guard< rights > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // license
  //

  license::
  license ()
  {
    this->LicenseDocument_ = 0;
    this->notes_present_ = false;
    this->custom_ = 0;
  }

  license::
  ~license ()
  {
    delete this->LicenseDocument_;
    delete this->custom_;
  }

  void license::
  _copy (license& c) const
  {
    XSDE_UNUSED (c);

    {
      ::metadata::LicenseDocument* m = this->LicenseDocument ()._clone ();
      c.LicenseDocument (m);
    }

    if (this->notes_present ())
      c.notes (this->notes ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  license* license::
  _clone () const
  {
    license* c = new license;
    ::xsde::cxx::guard< license > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // LicenseDocument
  //

  LicenseDocument::
  LicenseDocument ()
  {
    this->URL_present_ = false;
    this->custom_ = 0;
  }

  LicenseDocument::
  ~LicenseDocument ()
  {
    delete this->custom_;
  }

  void LicenseDocument::
  _copy (LicenseDocument& c) const
  {
    XSDE_UNUSED (c);

    c.name (this->name ());

    if (this->URL_present ())
      c.URL (this->URL ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  LicenseDocument* LicenseDocument::
  _clone () const
  {
    LicenseDocument* c = new LicenseDocument;
    ::xsde::cxx::guard< LicenseDocument > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // metadata
  //

  metadata::
  metadata ()
  {
    this->MultiCellDB_present_ = false;
    this->description_present_ = false;
    this->software_ = 0;
    this->citation_ = 0;
    this->curation_ = 0;
    this->data_origins_ = 0;
    this->rights_ = 0;
    this->cell_origin_ = 0;
    this->current_time_ = 0;
    this->current_runtime_ = 0;
    this->created_present_ = false;
    this->last_modified_present_ = false;
    this->notes_present_ = false;
    this->custom_ = 0;
  }

  metadata::
  ~metadata ()
  {
    delete this->software_;
    delete this->citation_;
    delete this->curation_;
    delete this->data_origins_;
    delete this->rights_;
    delete this->cell_origin_;
    delete this->current_time_;
    delete this->current_runtime_;
    delete this->custom_;
  }

  void metadata::
  _copy (metadata& c) const
  {
    XSDE_UNUSED (c);

    if (this->MultiCellDB_present ())
      c.MultiCellDB (this->MultiCellDB ());

    if (this->description_present ())
      c.description (this->description ());

    if (this->software_present ())
    {
      ::metadata::software* m = this->software ()._clone ();
      c.software (m);
    }

    if (this->citation_present ())
    {
      ::metadata::citation* m = this->citation ()._clone ();
      c.citation (m);
    }

    if (this->curation_present ())
    {
      ::metadata::curation* m = this->curation ()._clone ();
      c.curation (m);
    }

    if (this->data_origins_present ())
    {
      ::metadata::data_origins* m = this->data_origins ()._clone ();
      c.data_origins (m);
    }

    this->data_analysis ().copy (c.data_analysis ());

    {
      ::metadata::rights* m = this->rights ()._clone ();
      c.rights (m);
    }

    if (this->cell_origin_present ())
    {
      ::metadata::cell_origin* m = this->cell_origin ()._clone ();
      c.cell_origin (m);
    }

    if (this->current_time_present ())
    {
      ::common::units_decimal_nonnegative* m = this->current_time ()._clone ();
      c.current_time (m);
    }

    if (this->current_runtime_present ())
    {
      ::common::units_decimal_nonnegative* m = this->current_runtime ()._clone ();
      c.current_runtime (m);
    }

    if (this->created_present ())
      c.created (this->created ());

    if (this->last_modified_present ())
      c.last_modified (this->last_modified ());

    if (this->notes_present ())
      c.notes (this->notes ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  metadata* metadata::
  _clone () const
  {
    metadata* c = new metadata;
    ::xsde::cxx::guard< metadata > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

