// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "phenotype_base-pimpl.hpp"

#include <xsde/cxx/parser/validating/string-common.hxx>

namespace phenotype_base
{
  // phenotype_type_pimpl
  //

  phenotype_type_pimpl::
  phenotype_type_pimpl ()
  : phenotype_type_pskel (0)
  {
  }

  void phenotype_type_pimpl::
  pre ()
  {
    this->phenotype_type_pimpl_state_.str_.clear ();
  }

  void phenotype_type_pimpl::
  _characters (const ::xsde::cxx::ro_string& s)
  {
    if (this->_facets ().whitespace_ == 2 &&
        this->phenotype_type_pimpl_state_.str_.size () == 0)
    {
      ::xsde::cxx::ro_string tmp (s.data (), s.size ());

      if (::xsde::cxx::trim_left (tmp) != 0)
      {
        this->phenotype_type_pimpl_state_.str_ += tmp;
      }
    }
    else
      this->phenotype_type_pimpl_state_.str_ += s;
  }

  void phenotype_type_pimpl::
  _post ()
  {
    ::xsde::cxx::parser::validating::string_common::validate_facets (
      this->phenotype_type_pimpl_state_.str_,
      this->_facets (),
      this->_context ());
  }

  ::phenotype_base::phenotype_type phenotype_type_pimpl::
  post_phenotype_type ()
  {
    ::phenotype_base::phenotype_type::value_type v =
    static_cast< ::phenotype_base::phenotype_type::value_type > (0);
    const char* s = this->phenotype_type_pimpl_state_.str_.c_str ();

    if (strcmp (s, "expected") == 0)
      v = ::phenotype_base::phenotype_type::expected;
    else if (strcmp (s, "current") == 0)
      v = ::phenotype_base::phenotype_type::current;
    else if (strcmp (s, "target") == 0)
      v = ::phenotype_base::phenotype_type::target;

    ::phenotype_base::phenotype_type r (v);
    return r;
  }

  // phenotype_base_pimpl
  //

  phenotype_base_pimpl::
  phenotype_base_pimpl (bool b)
  {
    this->phenotype_base_pimpl_base_ = b;
    this->phenotype_base_pimpl_state_.phenotype_base_ = 0;
  }

  phenotype_base_pimpl::
  ~phenotype_base_pimpl ()
  {
    if (!this->phenotype_base_pimpl_base_ && this->phenotype_base_pimpl_state_.phenotype_base_)
      delete this->phenotype_base_pimpl_state_.phenotype_base_;
  }

  void phenotype_base_pimpl::
  _reset ()
  {
    phenotype_base_pskel::_reset ();

    if (!this->phenotype_base_pimpl_base_ && this->phenotype_base_pimpl_state_.phenotype_base_)
    {
      delete this->phenotype_base_pimpl_state_.phenotype_base_;
      this->phenotype_base_pimpl_state_.phenotype_base_ = 0;
    }
  }

  void phenotype_base_pimpl::
  pre_impl (::phenotype_base::phenotype_base* x)
  {
    this->phenotype_base_pimpl_state_.phenotype_base_ = x;
  }

  void phenotype_base_pimpl::
  pre ()
  {
    ::phenotype_base::phenotype_base* x = new ::phenotype_base::phenotype_base;
    this->pre_impl (x);
  }

  void phenotype_base_pimpl::
  type (const ::phenotype_base::phenotype_type& x)
  {
    this->phenotype_base_pimpl_state_.phenotype_base_->type (x);
  }

  void phenotype_base_pimpl::
  adhesion (::phenotype_common::adhesion* x)
  {
    this->phenotype_base_pimpl_state_.phenotype_base_->adhesion (x);
  }

  void phenotype_base_pimpl::
  geometrical_properties (::phenotype_common::geometrical_properties* x)
  {
    this->phenotype_base_pimpl_state_.phenotype_base_->geometrical_properties (x);
  }

  void phenotype_base_pimpl::
  mass (::phenotype_common::mass* x)
  {
    this->phenotype_base_pimpl_state_.phenotype_base_->mass (x);
  }

  void phenotype_base_pimpl::
  mechanics (::phenotype_common::mechanics* x)
  {
    this->phenotype_base_pimpl_state_.phenotype_base_->mechanics (x);
  }

  void phenotype_base_pimpl::
  motility (::phenotype_common::motility* x)
  {
    this->phenotype_base_pimpl_state_.phenotype_base_->motility (x);
  }

  void phenotype_base_pimpl::
  PKPD (::pkpd::PKPD* x)
  {
    this->phenotype_base_pimpl_state_.phenotype_base_->PKPD (x);
  }

  void phenotype_base_pimpl::
  timescale (::phenotype_base::expected_timescale* x)
  {
    this->phenotype_base_pimpl_state_.phenotype_base_->timescale (x);
  }

  void phenotype_base_pimpl::
  transport_processes (::phenotype_common::transport_processes* x)
  {
    this->phenotype_base_pimpl_state_.phenotype_base_->transport_processes (x);
  }

  void phenotype_base_pimpl::
  custom (::common::custom* x)
  {
    this->phenotype_base_pimpl_state_.phenotype_base_->custom (x);
  }

  ::phenotype_base::phenotype_base* phenotype_base_pimpl::
  post_phenotype_base ()
  {
    ::phenotype_base::phenotype_base* r = this->phenotype_base_pimpl_state_.phenotype_base_;
    this->phenotype_base_pimpl_state_.phenotype_base_ = 0;
    return r;
  }

  // expected_timescale_pimpl
  //

  expected_timescale_pimpl::
  expected_timescale_pimpl (bool b)
  : expected_timescale_pskel (&base_impl_),
    base_impl_ (true)
  {
    this->expected_timescale_pimpl_base_ = b;
    this->expected_timescale_pimpl_state_.expected_timescale_ = 0;
  }

  expected_timescale_pimpl::
  ~expected_timescale_pimpl ()
  {
    if (!this->expected_timescale_pimpl_base_ && this->expected_timescale_pimpl_state_.expected_timescale_)
      delete this->expected_timescale_pimpl_state_.expected_timescale_;
  }

  void expected_timescale_pimpl::
  _reset ()
  {
    expected_timescale_pskel::_reset ();

    if (!this->expected_timescale_pimpl_base_ && this->expected_timescale_pimpl_state_.expected_timescale_)
    {
      delete this->expected_timescale_pimpl_state_.expected_timescale_;
      this->expected_timescale_pimpl_state_.expected_timescale_ = 0;
    }
  }

  void expected_timescale_pimpl::
  pre_impl (::phenotype_base::expected_timescale* x)
  {
    this->expected_timescale_pimpl_state_.expected_timescale_ = x;
    this->base_impl_.pre_impl (x);
  }

  void expected_timescale_pimpl::
  pre ()
  {
    ::phenotype_base::expected_timescale* x = new ::phenotype_base::expected_timescale;
    this->pre_impl (x);
  }

  void expected_timescale_pimpl::
  cell_cycle_ID (unsigned int x)
  {
    this->expected_timescale_pimpl_state_.expected_timescale_->cell_cycle_ID (x);
  }

  void expected_timescale_pimpl::
  cell_cycle_phase_ID (unsigned int x)
  {
    this->expected_timescale_pimpl_state_.expected_timescale_->cell_cycle_phase_ID (x);
  }

  void expected_timescale_pimpl::
  cell_death_ID (unsigned int x)
  {
    this->expected_timescale_pimpl_state_.expected_timescale_->cell_death_ID (x);
  }

  ::phenotype_base::expected_timescale* expected_timescale_pimpl::
  post_expected_timescale ()
  {
    this->base_impl_.post_units_decimal_nonnegative ();
    ::phenotype_base::expected_timescale* r = this->expected_timescale_pimpl_state_.expected_timescale_;
    this->expected_timescale_pimpl_state_.expected_timescale_ = 0;
    return r;
  }

  // cell_parts_pimpl
  //

  cell_parts_pimpl::
  cell_parts_pimpl (bool b)
  : cell_parts_pimpl_state_ (sizeof (cell_parts_pimpl_state ), &cell_parts_pimpl_state_first_)
  {
    this->cell_parts_pimpl_base_ = b;
  }

  cell_parts_pimpl::
  ~cell_parts_pimpl ()
  {
    for (; !this->cell_parts_pimpl_state_.empty (); this->cell_parts_pimpl_state_.pop ())
    {
      if (!this->cell_parts_pimpl_base_ && static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_)
        delete static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_;
    }
  }

  void cell_parts_pimpl::
  _reset ()
  {
    cell_parts_pskel::_reset ();

    for (; !this->cell_parts_pimpl_state_.empty (); this->cell_parts_pimpl_state_.pop ())
    {
      if (!this->cell_parts_pimpl_base_ && static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_)
        delete static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_;
    }
  }

  void cell_parts_pimpl::
  pre_impl (::phenotype_base::cell_parts* x)
  {
    this->cell_parts_pimpl_state_.push ();
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_ = x;
  }

  void cell_parts_pimpl::
  pre ()
  {
    ::phenotype_base::cell_parts* x = new ::phenotype_base::cell_parts;
    this->pre_impl (x);
  }

  void cell_parts_pimpl::
  name (const ::std::string& x)
  {
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_->name (x);
  }

  void cell_parts_pimpl::
  ID (unsigned int x)
  {
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_->ID (x);
  }

  void cell_parts_pimpl::
  phenotype (::phenotype_base::phenotype_base* x)
  {
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_->phenotype ().push_back (x);
  }

  void cell_parts_pimpl::
  cell_part (::phenotype_base::cell_parts* x)
  {
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_->cell_part ().push_back (x);
  }

  void cell_parts_pimpl::
  custom (::common::custom* x)
  {
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_->custom (x);
  }

  ::phenotype_base::cell_parts* cell_parts_pimpl::
  post_cell_parts ()
  {
    ::phenotype_base::cell_parts* r = static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_;
    this->cell_parts_pimpl_state_.pop ();
    return r;
  }
}

// Begin epilogue.
//
//
// End epilogue.

