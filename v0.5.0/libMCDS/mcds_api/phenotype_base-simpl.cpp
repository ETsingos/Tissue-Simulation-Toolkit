// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "phenotype_base-simpl.hpp"

namespace phenotype_base
{
  // phenotype_type_simpl
  //

  phenotype_type_simpl::
  phenotype_type_simpl ()
  : phenotype_type_sskel (0)
  {
  }

  void phenotype_type_simpl::
  pre (const ::phenotype_base::phenotype_type& x)
  {
    this->phenotype_type_simpl_state_ = &x;
  }

  void phenotype_type_simpl::
  _serialize_content ()
  {
    this->_characters (this->phenotype_type_simpl_state_->string ());
  }

  // phenotype_base_simpl
  //

  void phenotype_base_simpl::
  pre (const ::phenotype_base::phenotype_base& x)
  {
    this->phenotype_base_simpl_state_.phenotype_base_ = &x;
  }

  bool phenotype_base_simpl::
  type_present ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->type_present ();
  }

  const ::phenotype_base::phenotype_type& phenotype_base_simpl::
  type ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->type ();
  }

  bool phenotype_base_simpl::
  adhesion_present ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->adhesion_present ();
  }

  const ::phenotype_common::adhesion& phenotype_base_simpl::
  adhesion ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->adhesion ();
  }

  bool phenotype_base_simpl::
  geometrical_properties_present ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->geometrical_properties_present ();
  }

  const ::phenotype_common::geometrical_properties& phenotype_base_simpl::
  geometrical_properties ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->geometrical_properties ();
  }

  bool phenotype_base_simpl::
  mass_present ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->mass_present ();
  }

  const ::phenotype_common::mass& phenotype_base_simpl::
  mass ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->mass ();
  }

  bool phenotype_base_simpl::
  mechanics_present ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->mechanics_present ();
  }

  const ::phenotype_common::mechanics& phenotype_base_simpl::
  mechanics ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->mechanics ();
  }

  bool phenotype_base_simpl::
  motility_present ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->motility_present ();
  }

  const ::phenotype_common::motility& phenotype_base_simpl::
  motility ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->motility ();
  }

  bool phenotype_base_simpl::
  PKPD_present ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->PKPD_present ();
  }

  const ::pkpd::PKPD& phenotype_base_simpl::
  PKPD ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->PKPD ();
  }

  bool phenotype_base_simpl::
  timescale_present ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->timescale_present ();
  }

  const ::phenotype_base::expected_timescale& phenotype_base_simpl::
  timescale ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->timescale ();
  }

  bool phenotype_base_simpl::
  transport_processes_present ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->transport_processes_present ();
  }

  const ::phenotype_common::transport_processes& phenotype_base_simpl::
  transport_processes ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->transport_processes ();
  }

  bool phenotype_base_simpl::
  custom_present ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->custom_present ();
  }

  const ::common::custom& phenotype_base_simpl::
  custom ()
  {
    return this->phenotype_base_simpl_state_.phenotype_base_->custom ();
  }

  // expected_timescale_simpl
  //

  expected_timescale_simpl::
  expected_timescale_simpl ()
  : expected_timescale_sskel (&base_impl_)
  {
  }

  void expected_timescale_simpl::
  pre (const ::phenotype_base::expected_timescale& x)
  {
    this->base_impl_.pre (x);
    this->expected_timescale_simpl_state_.expected_timescale_ = &x;
  }

  bool expected_timescale_simpl::
  cell_cycle_ID_present ()
  {
    return this->expected_timescale_simpl_state_.expected_timescale_->cell_cycle_ID_present ();
  }

  unsigned int expected_timescale_simpl::
  cell_cycle_ID ()
  {
    return this->expected_timescale_simpl_state_.expected_timescale_->cell_cycle_ID ();
  }

  bool expected_timescale_simpl::
  cell_cycle_phase_ID_present ()
  {
    return this->expected_timescale_simpl_state_.expected_timescale_->cell_cycle_phase_ID_present ();
  }

  unsigned int expected_timescale_simpl::
  cell_cycle_phase_ID ()
  {
    return this->expected_timescale_simpl_state_.expected_timescale_->cell_cycle_phase_ID ();
  }

  bool expected_timescale_simpl::
  cell_death_ID_present ()
  {
    return this->expected_timescale_simpl_state_.expected_timescale_->cell_death_ID_present ();
  }

  unsigned int expected_timescale_simpl::
  cell_death_ID ()
  {
    return this->expected_timescale_simpl_state_.expected_timescale_->cell_death_ID ();
  }

  // cell_parts_simpl
  //

  cell_parts_simpl::
  cell_parts_simpl ()
  : cell_parts_simpl_state_ (sizeof (cell_parts_simpl_state ), &cell_parts_simpl_state_first_)
  {
  }

  void cell_parts_simpl::
  pre (const ::phenotype_base::cell_parts& x)
  {
    this->cell_parts_simpl_state_.push ();
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_ = &x;
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->phenotype_ = 
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->phenotype ().begin ();
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->phenotype_end_ = 
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->phenotype ().end ();
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_part_ = 
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->cell_part ().begin ();
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_part_end_ = 
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->cell_part ().end ();
  }

  ::std::string cell_parts_simpl::
  name ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->name ();
  }

  bool cell_parts_simpl::
  ID_present ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->ID_present ();
  }

  unsigned int cell_parts_simpl::
  ID ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->ID ();
  }

  bool cell_parts_simpl::
  phenotype_next ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->phenotype_ != 
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->phenotype_end_;
  }

  const ::phenotype_base::phenotype_base& cell_parts_simpl::
  phenotype ()
  {
    return *static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->phenotype_++;
  }

  bool cell_parts_simpl::
  cell_part_next ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_part_ != 
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_part_end_;
  }

  const ::phenotype_base::cell_parts& cell_parts_simpl::
  cell_part ()
  {
    return *static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_part_++;
  }

  bool cell_parts_simpl::
  custom_present ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->custom_present ();
  }

  const ::common::custom& cell_parts_simpl::
  custom ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->custom ();
  }

  void cell_parts_simpl::
  post ()
  {
    this->cell_parts_simpl_state_.pop ();
  }

  void cell_parts_simpl::
  _reset ()
  {
    cell_parts_sskel::_reset ();
    for (; !this->cell_parts_simpl_state_.empty (); this->cell_parts_simpl_state_.pop ()) ;
  }
}

// Begin epilogue.
//
//
// End epilogue.

