// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "state-simpl.hpp"

#include <xsde/cxx/serializer/validating/string-common.hxx>

namespace state
{
  // phase_name_simpl
  //

  phase_name_simpl::
  phase_name_simpl ()
  : phase_name_sskel (&base_impl_)
  {
  }

  void phase_name_simpl::
  pre (const ::state::phase_name& x)
  {
    this->base_impl_.pre (x);
    this->phase_name_simpl_state_.phase_name_ = &x;
  }

  bool phase_name_simpl::
  GO_ID_present ()
  {
    return this->phase_name_simpl_state_.phase_name_->GO_ID_present ();
  }

  ::std::string phase_name_simpl::
  GO_ID ()
  {
    return this->phase_name_simpl_state_.phase_name_->GO_ID ();
  }

  // phase_simpl
  //

  void phase_simpl::
  pre (const ::state::phase& x)
  {
    this->phase_simpl_state_.phase_ = &x;
  }

  bool phase_simpl::
  model_name_present ()
  {
    return this->phase_simpl_state_.phase_->model_name_present ();
  }

  ::std::string phase_simpl::
  model_name ()
  {
    return this->phase_simpl_state_.phase_->model_name ();
  }

  bool phase_simpl::
  phase_name_present ()
  {
    return this->phase_simpl_state_.phase_->phase_name_present ();
  }

  const ::state::phase_name& phase_simpl::
  phase_name ()
  {
    return this->phase_simpl_state_.phase_->phase_name ();
  }

  bool phase_simpl::
  cell_cycle_model_index_present ()
  {
    return this->phase_simpl_state_.phase_->cell_cycle_model_index_present ();
  }

  unsigned short phase_simpl::
  cell_cycle_model_index ()
  {
    return this->phase_simpl_state_.phase_->cell_cycle_model_index ();
  }

  bool phase_simpl::
  cell_cycle_phase_index_present ()
  {
    return this->phase_simpl_state_.phase_->cell_cycle_phase_index_present ();
  }

  unsigned short phase_simpl::
  cell_cycle_phase_index ()
  {
    return this->phase_simpl_state_.phase_->cell_cycle_phase_index ();
  }

  bool phase_simpl::
  elapsed_time_present ()
  {
    return this->phase_simpl_state_.phase_->elapsed_time_present ();
  }

  const ::common::units_decimal& phase_simpl::
  elapsed_time ()
  {
    return this->phase_simpl_state_.phase_->elapsed_time ();
  }

  bool phase_simpl::
  custom_present ()
  {
    return this->phase_simpl_state_.phase_->custom_present ();
  }

  const ::common::custom& phase_simpl::
  custom ()
  {
    return this->phase_simpl_state_.phase_->custom ();
  }

  // orientation_formalism_simpl
  //

  orientation_formalism_simpl::
  orientation_formalism_simpl ()
  : orientation_formalism_sskel (0)
  {
  }

  void orientation_formalism_simpl::
  pre (const ::state::orientation_formalism& x)
  {
    this->orientation_formalism_simpl_state_ = &x;
  }

  void orientation_formalism_simpl::
  _serialize_content ()
  {
    if (::xsde::cxx::serializer::validating::string_common::validate_facets (
          this->orientation_formalism_simpl_state_->string (),
          this->_facets (),
          this->_context ()))
      this->_characters (this->orientation_formalism_simpl_state_->string ());
  }

  // orientation_simpl
  //

  orientation_simpl::
  orientation_simpl ()
  : orientation_sskel (&base_impl_)
  {
  }

  void orientation_simpl::
  pre (const ::state::orientation& x)
  {
    this->base_impl_.pre (x);
    this->orientation_simpl_state_.orientation_ = &x;
  }

  bool orientation_simpl::
  formalism_present ()
  {
    return this->orientation_simpl_state_.orientation_->formalism_present ();
  }

  const ::state::orientation_formalism& orientation_simpl::
  formalism ()
  {
    return this->orientation_simpl_state_.orientation_->formalism ();
  }

  // cell_parts_simpl
  //

  cell_parts_simpl::
  cell_parts_simpl ()
  : cell_parts_simpl_state_ (sizeof (cell_parts_simpl_state ), &cell_parts_simpl_state_first_)
  {
  }

  void cell_parts_simpl::
  pre (const ::state::cell_parts& x)
  {
    this->cell_parts_simpl_state_.push ();
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_ = &x;
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_part_ = 
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->cell_part ().begin ();
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_part_end_ = 
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->cell_part ().end ();
  }

  ::std::string cell_parts_simpl::
  name ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->name ();
  }

  bool cell_parts_simpl::
  ID_present ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->ID_present ();
  }

  unsigned int cell_parts_simpl::
  ID ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->ID ();
  }

  bool cell_parts_simpl::
  orientation_present ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->orientation_present ();
  }

  const ::state::orientation& cell_parts_simpl::
  orientation ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->orientation ();
  }

  bool cell_parts_simpl::
  position_present ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->position_present ();
  }

  const ::common::units_double_list& cell_parts_simpl::
  position ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->position ();
  }

  bool cell_parts_simpl::
  velocity_present ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->velocity_present ();
  }

  const ::common::units_double_list& cell_parts_simpl::
  velocity ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->velocity ();
  }

  bool cell_parts_simpl::
  voxels_present ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->voxels_present ();
  }

  const ::mesh::int_list_xpath& cell_parts_simpl::
  voxels ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->voxels ();
  }

  bool cell_parts_simpl::
  cell_part_next ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_part_ != 
    static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_part_end_;
  }

  const ::state::cell_parts& cell_parts_simpl::
  cell_part ()
  {
    return *static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_part_++;
  }

  bool cell_parts_simpl::
  custom_present ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->custom_present ();
  }

  const ::common::custom& cell_parts_simpl::
  custom ()
  {
    return static_cast< cell_parts_simpl_state* > (this->cell_parts_simpl_state_.top ())->cell_parts_->custom ();
  }

  void cell_parts_simpl::
  post ()
  {
    this->cell_parts_simpl_state_.pop ();
  }

  void cell_parts_simpl::
  _reset ()
  {
    cell_parts_sskel::_reset ();
    for (; !this->cell_parts_simpl_state_.empty (); this->cell_parts_simpl_state_.pop ()) ;
  }

  // state_simpl
  //

  void state_simpl::
  pre (const ::state::state& x)
  {
    this->state_simpl_state_.state_ = &x;
    this->state_simpl_state_.cell_part_ = 
    this->state_simpl_state_.state_->cell_part ().begin ();
    this->state_simpl_state_.cell_part_end_ = 
    this->state_simpl_state_.state_->cell_part ().end ();
  }

  bool state_simpl::
  orientation_present ()
  {
    return this->state_simpl_state_.state_->orientation_present ();
  }

  const ::state::orientation& state_simpl::
  orientation ()
  {
    return this->state_simpl_state_.state_->orientation ();
  }

  bool state_simpl::
  position_present ()
  {
    return this->state_simpl_state_.state_->position_present ();
  }

  const ::common::units_double_list& state_simpl::
  position ()
  {
    return this->state_simpl_state_.state_->position ();
  }

  bool state_simpl::
  velocity_present ()
  {
    return this->state_simpl_state_.state_->velocity_present ();
  }

  const ::common::units_double_list& state_simpl::
  velocity ()
  {
    return this->state_simpl_state_.state_->velocity ();
  }

  bool state_simpl::
  voxels_present ()
  {
    return this->state_simpl_state_.state_->voxels_present ();
  }

  const ::mesh::int_list_xpath& state_simpl::
  voxels ()
  {
    return this->state_simpl_state_.state_->voxels ();
  }

  bool state_simpl::
  cell_part_next ()
  {
    return this->state_simpl_state_.cell_part_ != 
    this->state_simpl_state_.cell_part_end_;
  }

  const ::state::cell_parts& state_simpl::
  cell_part ()
  {
    return *this->state_simpl_state_.cell_part_++;
  }

  bool state_simpl::
  phase_present ()
  {
    return this->state_simpl_state_.state_->phase_present ();
  }

  const ::state::phase& state_simpl::
  phase ()
  {
    return this->state_simpl_state_.state_->phase ();
  }

  bool state_simpl::
  adhered_cells_present ()
  {
    return this->state_simpl_state_.state_->adhered_cells_present ();
  }

  const ::state::list_of_adhered_cells& state_simpl::
  adhered_cells ()
  {
    return this->state_simpl_state_.state_->adhered_cells ();
  }

  bool state_simpl::
  custom_present ()
  {
    return this->state_simpl_state_.state_->custom_present ();
  }

  const ::common::custom& state_simpl::
  custom ()
  {
    return this->state_simpl_state_.state_->custom ();
  }

  // adhered_cell_simpl
  //

  void adhered_cell_simpl::
  pre (const ::state::adhered_cell& x)
  {
    this->adhered_cell_simpl_state_.adhered_cell_ = &x;
  }

  unsigned int adhered_cell_simpl::
  ID ()
  {
    return this->adhered_cell_simpl_state_.adhered_cell_->ID ();
  }

  const ::common::units_decimal_nonnegative& adhered_cell_simpl::
  contact_area ()
  {
    return this->adhered_cell_simpl_state_.adhered_cell_->contact_area ();
  }

  const ::phenotype_common::cross_section& adhered_cell_simpl::
  contact ()
  {
    return this->adhered_cell_simpl_state_.adhered_cell_->contact ();
  }

  bool adhered_cell_simpl::
  custom_present ()
  {
    return this->adhered_cell_simpl_state_.adhered_cell_->custom_present ();
  }

  const ::common::custom& adhered_cell_simpl::
  custom ()
  {
    return this->adhered_cell_simpl_state_.adhered_cell_->custom ();
  }

  // list_of_adhered_cells_simpl
  //

  void list_of_adhered_cells_simpl::
  pre (const ::state::list_of_adhered_cells& x)
  {
    this->list_of_adhered_cells_simpl_state_.list_of_adhered_cells_ = &x;
    this->list_of_adhered_cells_simpl_state_.adhered_cell_ = 
    this->list_of_adhered_cells_simpl_state_.list_of_adhered_cells_->adhered_cell ().begin ();
    this->list_of_adhered_cells_simpl_state_.adhered_cell_end_ = 
    this->list_of_adhered_cells_simpl_state_.list_of_adhered_cells_->adhered_cell ().end ();
  }

  bool list_of_adhered_cells_simpl::
  adhered_cell_next ()
  {
    return this->list_of_adhered_cells_simpl_state_.adhered_cell_ != 
    this->list_of_adhered_cells_simpl_state_.adhered_cell_end_;
  }

  const ::state::adhered_cell& list_of_adhered_cells_simpl::
  adhered_cell ()
  {
    return *this->list_of_adhered_cells_simpl_state_.adhered_cell_++;
  }

  bool list_of_adhered_cells_simpl::
  custom_present ()
  {
    return this->list_of_adhered_cells_simpl_state_.list_of_adhered_cells_->custom_present ();
  }

  const ::common::custom& list_of_adhered_cells_simpl::
  custom ()
  {
    return this->list_of_adhered_cells_simpl_state_.list_of_adhered_cells_->custom ();
  }
}

// Begin epilogue.
//
//
// End epilogue.

