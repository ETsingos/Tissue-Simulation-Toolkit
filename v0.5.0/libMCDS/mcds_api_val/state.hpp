// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef STATE_HPP
#define STATE_HPP

#include <xsde/cxx/version.hxx>

#if (XSDE_INT_VERSION != 3020000L)
#error XSD/e runtime version mismatch
#endif

#include <xsde/cxx/config.hxx>

#ifndef XSDE_ENCODING_UTF8
#error the generated code uses the UTF-8 encodingwhile the XSD/e runtime does not (reconfigure the runtime or change the --char-encoding value)
#endif

#ifndef XSDE_STL
#error the generated code uses STL while the XSD/e runtime does not (reconfigure the runtime or add --no-stl)
#endif

#ifndef XSDE_EXCEPTIONS
#error the generated code uses exceptions while the XSD/e runtime does not (reconfigure the runtime or add --no-exceptions)
#endif

#ifndef XSDE_LONGLONG
#error the generated code uses long long while the XSD/e runtime does not (reconfigure the runtime or add --no-long-long)
#endif

#ifdef XSDE_CUSTOM_ALLOCATOR
#error the XSD/e runtime uses custom allocator while the generated code does not (reconfigure the runtime or add --custom-allocator)
#endif

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "state-fwd.hpp"

#ifndef XSDE_DONT_INCLUDE_INLINE
#define XSDE_DONT_INCLUDE_INLINE

#include "common.hpp"

#include "phenotype_common.hpp"

#include "mesh.hpp"

#undef XSDE_DONT_INCLUDE_INLINE
#else

#include "common.hpp"

#include "phenotype_common.hpp"

#include "mesh.hpp"

#endif // XSDE_DONT_INCLUDE_INLINE

namespace state
{
  // phase_name (fixed-length)
  //
  class phase_name: public ::std::string
  {
    public:
    phase_name ();

    phase_name (const phase_name&);
    phase_name& operator= (const phase_name&);

    ~phase_name ();

    // GO_ID
    //
    bool
    GO_ID_present () const;

    void
    GO_ID_present (bool);

    const ::std::string&
    GO_ID () const;

    ::std::string&
    GO_ID ();

    void
    GO_ID (const ::std::string&);

    private:
    ::std::string GO_ID_;
    unsigned char GO_ID_present_;
  };

  // phase (variable-length)
  //
  class phase
  {
    private:
    phase (const phase&);
    phase& operator= (const phase&);

    public:
    phase ();

    phase*
    _clone () const;

    ~phase ();

    // model_name
    //
    bool
    model_name_present () const;

    void
    model_name_present (bool);

    const ::std::string&
    model_name () const;

    ::std::string&
    model_name ();

    void
    model_name (const ::std::string&);

    // phase_name
    //
    bool
    phase_name_present () const;

    void
    phase_name_present (bool);

    const ::state::phase_name&
    phase_name () const;

    ::state::phase_name&
    phase_name ();

    void
    phase_name (const ::state::phase_name&);

    // cell_cycle_model_index
    //
    bool
    cell_cycle_model_index_present () const;

    void
    cell_cycle_model_index_present (bool);

    unsigned short
    cell_cycle_model_index () const;

    unsigned short&
    cell_cycle_model_index ();

    void
    cell_cycle_model_index (unsigned short);

    // cell_cycle_phase_index
    //
    bool
    cell_cycle_phase_index_present () const;

    void
    cell_cycle_phase_index_present (bool);

    unsigned short
    cell_cycle_phase_index () const;

    unsigned short&
    cell_cycle_phase_index ();

    void
    cell_cycle_phase_index (unsigned short);

    // elapsed_time
    //
    bool
    elapsed_time_present () const;

    const ::common::units_decimal&
    elapsed_time () const;

    ::common::units_decimal&
    elapsed_time ();

    void
    elapsed_time (::common::units_decimal*);

    ::common::units_decimal*
    elapsed_time_detach ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (phase&) const;

    private:
    ::std::string model_name_;
    unsigned char model_name_present_;
    ::state::phase_name phase_name_;
    unsigned char phase_name_present_;
    unsigned short cell_cycle_model_index_;
    unsigned char cell_cycle_model_index_present_;
    unsigned short cell_cycle_phase_index_;
    unsigned char cell_cycle_phase_index_present_;
    ::common::units_decimal* elapsed_time_;
    ::common::custom* custom_;
  };

  // orientation_formalism (fixed-length)
  //
  class orientation_formalism
  {
    public:
    enum value_type
    {
      axis_angle,
      quaternion,
      Euler_Angles,
      Tait_Bryan,
      polar,
      Polar,
      Unit_Vector
    };

    orientation_formalism ();
    orientation_formalism (value_type);

    void
    value (value_type);

    operator value_type () const
    {
      return value_;
    }

    const char*
    string () const;

    private:
    value_type value_;
  };

  // orientation (variable-length)
  //
  class orientation: public ::common::units_double_list
  {
    private:
    orientation (const orientation&);
    orientation& operator= (const orientation&);

    public:
    orientation ();

    orientation*
    _clone () const;

    ~orientation ();

    // formalism
    //
    bool
    formalism_present () const;

    void
    formalism_present (bool);

    const ::state::orientation_formalism&
    formalism () const;

    ::state::orientation_formalism&
    formalism ();

    void
    formalism (const ::state::orientation_formalism&);

    void
    _copy (orientation&) const;

    private:
    ::state::orientation_formalism formalism_;
    unsigned char formalism_present_;
  };

  // cell_parts (variable-length)
  //
  class cell_parts
  {
    private:
    cell_parts (const cell_parts&);
    cell_parts& operator= (const cell_parts&);

    public:
    cell_parts ();

    cell_parts*
    _clone () const;

    ~cell_parts ();

    // name
    //
    const ::std::string&
    name () const;

    ::std::string&
    name ();

    void
    name (const ::std::string&);

    // ID
    //
    bool
    ID_present () const;

    void
    ID_present (bool);

    unsigned int
    ID () const;

    unsigned int&
    ID ();

    void
    ID (unsigned int);

    // orientation
    //
    bool
    orientation_present () const;

    const ::state::orientation&
    orientation () const;

    ::state::orientation&
    orientation ();

    void
    orientation (::state::orientation*);

    ::state::orientation*
    orientation_detach ();

    // position
    //
    bool
    position_present () const;

    const ::common::units_double_list&
    position () const;

    ::common::units_double_list&
    position ();

    void
    position (::common::units_double_list*);

    ::common::units_double_list*
    position_detach ();

    // velocity
    //
    bool
    velocity_present () const;

    const ::common::units_double_list&
    velocity () const;

    ::common::units_double_list&
    velocity ();

    void
    velocity (::common::units_double_list*);

    ::common::units_double_list*
    velocity_detach ();

    // voxels
    //
    bool
    voxels_present () const;

    const ::mesh::int_list_xpath&
    voxels () const;

    ::mesh::int_list_xpath&
    voxels ();

    void
    voxels (::mesh::int_list_xpath*);

    ::mesh::int_list_xpath*
    voxels_detach ();

    // cell_part
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::state::cell_parts > cell_part_sequence;
    typedef cell_part_sequence::iterator cell_part_iterator;
    typedef cell_part_sequence::const_iterator cell_part_const_iterator;

    const cell_part_sequence&
    cell_part () const;

    cell_part_sequence&
    cell_part ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (cell_parts&) const;

    private:
    ::std::string name_;
    unsigned int ID_;
    unsigned char ID_present_;
    ::state::orientation* orientation_;
    ::common::units_double_list* position_;
    ::common::units_double_list* velocity_;
    ::mesh::int_list_xpath* voxels_;
    cell_part_sequence cell_part_;
    ::common::custom* custom_;
  };

  // state (variable-length)
  //
  class state
  {
    private:
    state (const state&);
    state& operator= (const state&);

    public:
    state ();

    state*
    _clone () const;

    ~state ();

    // orientation
    //
    bool
    orientation_present () const;

    const ::state::orientation&
    orientation () const;

    ::state::orientation&
    orientation ();

    void
    orientation (::state::orientation*);

    ::state::orientation*
    orientation_detach ();

    // position
    //
    bool
    position_present () const;

    const ::common::units_double_list&
    position () const;

    ::common::units_double_list&
    position ();

    void
    position (::common::units_double_list*);

    ::common::units_double_list*
    position_detach ();

    // velocity
    //
    bool
    velocity_present () const;

    const ::common::units_double_list&
    velocity () const;

    ::common::units_double_list&
    velocity ();

    void
    velocity (::common::units_double_list*);

    ::common::units_double_list*
    velocity_detach ();

    // voxels
    //
    bool
    voxels_present () const;

    const ::mesh::int_list_xpath&
    voxels () const;

    ::mesh::int_list_xpath&
    voxels ();

    void
    voxels (::mesh::int_list_xpath*);

    ::mesh::int_list_xpath*
    voxels_detach ();

    // cell_part
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::state::cell_parts > cell_part_sequence;
    typedef cell_part_sequence::iterator cell_part_iterator;
    typedef cell_part_sequence::const_iterator cell_part_const_iterator;

    const cell_part_sequence&
    cell_part () const;

    cell_part_sequence&
    cell_part ();

    // phase
    //
    bool
    phase_present () const;

    const ::state::phase&
    phase () const;

    ::state::phase&
    phase ();

    void
    phase (::state::phase*);

    ::state::phase*
    phase_detach ();

    // adhered_cells
    //
    bool
    adhered_cells_present () const;

    const ::state::list_of_adhered_cells&
    adhered_cells () const;

    ::state::list_of_adhered_cells&
    adhered_cells ();

    void
    adhered_cells (::state::list_of_adhered_cells*);

    ::state::list_of_adhered_cells*
    adhered_cells_detach ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (state&) const;

    private:
    ::state::orientation* orientation_;
    ::common::units_double_list* position_;
    ::common::units_double_list* velocity_;
    ::mesh::int_list_xpath* voxels_;
    cell_part_sequence cell_part_;
    ::state::phase* phase_;
    ::state::list_of_adhered_cells* adhered_cells_;
    ::common::custom* custom_;
  };

  // adhered_cell (variable-length)
  //
  class adhered_cell
  {
    private:
    adhered_cell (const adhered_cell&);
    adhered_cell& operator= (const adhered_cell&);

    public:
    adhered_cell ();

    adhered_cell*
    _clone () const;

    ~adhered_cell ();

    // ID
    //
    unsigned int
    ID () const;

    unsigned int&
    ID ();

    void
    ID (unsigned int);

    // contact_area
    //
    const ::common::units_decimal_nonnegative&
    contact_area () const;

    ::common::units_decimal_nonnegative&
    contact_area ();

    void
    contact_area (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    contact_area_detach ();

    // contact
    //
    const ::phenotype_common::cross_section&
    contact () const;

    ::phenotype_common::cross_section&
    contact ();

    void
    contact (::phenotype_common::cross_section*);

    ::phenotype_common::cross_section*
    contact_detach ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (adhered_cell&) const;

    private:
    unsigned int ID_;
    ::common::units_decimal_nonnegative* contact_area_;
    ::phenotype_common::cross_section* contact_;
    ::common::custom* custom_;
  };

  // list_of_adhered_cells (variable-length)
  //
  class list_of_adhered_cells
  {
    private:
    list_of_adhered_cells (const list_of_adhered_cells&);
    list_of_adhered_cells& operator= (const list_of_adhered_cells&);

    public:
    list_of_adhered_cells ();

    list_of_adhered_cells*
    _clone () const;

    ~list_of_adhered_cells ();

    // adhered_cell
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::state::adhered_cell > adhered_cell_sequence;
    typedef adhered_cell_sequence::iterator adhered_cell_iterator;
    typedef adhered_cell_sequence::const_iterator adhered_cell_const_iterator;

    const adhered_cell_sequence&
    adhered_cell () const;

    adhered_cell_sequence&
    adhered_cell ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (list_of_adhered_cells&) const;

    private:
    adhered_cell_sequence adhered_cell_;
    ::common::custom* custom_;
  };
}

#ifndef XSDE_DONT_INCLUDE_INLINE

#include "common.ipp"

#include "phenotype_common.ipp"

#include "mesh.ipp"

#endif // XSDE_DONT_INCLUDE_INLINE

#ifndef XSDE_DONT_INCLUDE_INLINE
#include "state.ipp"
#endif // XSDE_DONT_INCLUDE_INLINE

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

#endif // STATE_HPP
