// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef PHENOTYPE_COMMON_HPP
#define PHENOTYPE_COMMON_HPP

#include <xsde/cxx/version.hxx>

#if (XSDE_INT_VERSION != 3020000L)
#error XSD/e runtime version mismatch
#endif

#include <xsde/cxx/config.hxx>

#ifndef XSDE_ENCODING_UTF8
#error the generated code uses the UTF-8 encodingwhile the XSD/e runtime does not (reconfigure the runtime or change the --char-encoding value)
#endif

#ifndef XSDE_STL
#error the generated code uses STL while the XSD/e runtime does not (reconfigure the runtime or add --no-stl)
#endif

#ifndef XSDE_EXCEPTIONS
#error the generated code uses exceptions while the XSD/e runtime does not (reconfigure the runtime or add --no-exceptions)
#endif

#ifndef XSDE_LONGLONG
#error the generated code uses long long while the XSD/e runtime does not (reconfigure the runtime or add --no-long-long)
#endif

#ifdef XSDE_CUSTOM_ALLOCATOR
#error the XSD/e runtime uses custom allocator while the generated code does not (reconfigure the runtime or add --custom-allocator)
#endif

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "phenotype_common-fwd.hpp"

#ifndef XSDE_DONT_INCLUDE_INLINE
#define XSDE_DONT_INCLUDE_INLINE

#include "common.hpp"

#include "variables.hpp"

#undef XSDE_DONT_INCLUDE_INLINE
#else

#include "common.hpp"

#include "variables.hpp"

#endif // XSDE_DONT_INCLUDE_INLINE

namespace phenotype_common
{
  // adhesion (variable-length)
  //
  class adhesion
  {
    private:
    adhesion (const adhesion&);
    adhesion& operator= (const adhesion&);

    public:
    adhesion ();

    adhesion*
    _clone () const;

    ~adhesion ();

    // adhesion_bond_breaking_rate
    //
    bool
    adhesion_bond_breaking_rate_present () const;

    const ::common::units_decimal&
    adhesion_bond_breaking_rate () const;

    ::common::units_decimal&
    adhesion_bond_breaking_rate ();

    void
    adhesion_bond_breaking_rate (::common::units_decimal*);

    ::common::units_decimal*
    adhesion_bond_breaking_rate_detach ();

    // adhesion_bond_formation_rate
    //
    bool
    adhesion_bond_formation_rate_present () const;

    const ::common::units_decimal&
    adhesion_bond_formation_rate () const;

    ::common::units_decimal&
    adhesion_bond_formation_rate ();

    void
    adhesion_bond_formation_rate (::common::units_decimal*);

    ::common::units_decimal*
    adhesion_bond_formation_rate_detach ();

    // adhesion_spring_constant
    //
    bool
    adhesion_spring_constant_present () const;

    const ::common::units_decimal_nonnegative&
    adhesion_spring_constant () const;

    ::common::units_decimal_nonnegative&
    adhesion_spring_constant ();

    void
    adhesion_spring_constant (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    adhesion_spring_constant_detach ();

    // adhesion_receptor_density
    //
    bool
    adhesion_receptor_density_present () const;

    const ::common::units_decimal_nonnegative&
    adhesion_receptor_density () const;

    ::common::units_decimal_nonnegative&
    adhesion_receptor_density ();

    void
    adhesion_receptor_density (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    adhesion_receptor_density_detach ();

    // surface_binding_energy
    //
    bool
    surface_binding_energy_present () const;

    const ::common::units_decimal&
    surface_binding_energy () const;

    ::common::units_decimal&
    surface_binding_energy ();

    void
    surface_binding_energy (::common::units_decimal*);

    ::common::units_decimal*
    surface_binding_energy_detach ();

    // number_of_adhered_cells
    //
    bool
    number_of_adhered_cells_present () const;

    const ::common::units_decimal_nonnegative&
    number_of_adhered_cells () const;

    ::common::units_decimal_nonnegative&
    number_of_adhered_cells ();

    void
    number_of_adhered_cells (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    number_of_adhered_cells_detach ();

    // maximum_number_of_adhered_cells
    //
    bool
    maximum_number_of_adhered_cells_present () const;

    void
    maximum_number_of_adhered_cells_present (bool);

    const ::common::units_unsignedShort&
    maximum_number_of_adhered_cells () const;

    ::common::units_unsignedShort&
    maximum_number_of_adhered_cells ();

    void
    maximum_number_of_adhered_cells (const ::common::units_unsignedShort&);

    // adhered_surface_area
    //
    bool
    adhered_surface_area_present () const;

    const ::common::units_decimal_nonnegative&
    adhered_surface_area () const;

    ::common::units_decimal_nonnegative&
    adhered_surface_area ();

    void
    adhered_surface_area (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    adhered_surface_area_detach ();

    // maximum_adhered_surface_area
    //
    bool
    maximum_adhered_surface_area_present () const;

    const ::common::units_decimal_nonnegative&
    maximum_adhered_surface_area () const;

    ::common::units_decimal_nonnegative&
    maximum_adhered_surface_area ();

    void
    maximum_adhered_surface_area (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    maximum_adhered_surface_area_detach ();

    // adhesion_force_per_surface_area
    //
    bool
    adhesion_force_per_surface_area_present () const;

    const ::common::units_decimal&
    adhesion_force_per_surface_area () const;

    ::common::units_decimal&
    adhesion_force_per_surface_area ();

    void
    adhesion_force_per_surface_area (::common::units_decimal*);

    ::common::units_decimal*
    adhesion_force_per_surface_area_detach ();

    // adhesion_probability
    //
    bool
    adhesion_probability_present () const;

    const ::common::units_fraction&
    adhesion_probability () const;

    ::common::units_fraction&
    adhesion_probability ();

    void
    adhesion_probability (::common::units_fraction*);

    ::common::units_fraction*
    adhesion_probability_detach ();

    // detachment_proability
    //
    bool
    detachment_proability_present () const;

    const ::common::units_fraction&
    detachment_proability () const;

    ::common::units_fraction&
    detachment_proability ();

    void
    detachment_proability (::common::units_fraction*);

    ::common::units_fraction*
    detachment_proability_detach ();

    // rolling_observation
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::phenotype_common::rolling_observation > rolling_observation_sequence;
    typedef rolling_observation_sequence::iterator rolling_observation_iterator;
    typedef rolling_observation_sequence::const_iterator rolling_observation_const_iterator;

    const rolling_observation_sequence&
    rolling_observation () const;

    rolling_observation_sequence&
    rolling_observation ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (adhesion&) const;

    private:
    ::common::units_decimal* adhesion_bond_breaking_rate_;
    ::common::units_decimal* adhesion_bond_formation_rate_;
    ::common::units_decimal_nonnegative* adhesion_spring_constant_;
    ::common::units_decimal_nonnegative* adhesion_receptor_density_;
    ::common::units_decimal* surface_binding_energy_;
    ::common::units_decimal_nonnegative* number_of_adhered_cells_;
    ::common::units_unsignedShort maximum_number_of_adhered_cells_;
    unsigned char maximum_number_of_adhered_cells_present_;
    ::common::units_decimal_nonnegative* adhered_surface_area_;
    ::common::units_decimal_nonnegative* maximum_adhered_surface_area_;
    ::common::units_decimal* adhesion_force_per_surface_area_;
    ::common::units_fraction* adhesion_probability_;
    ::common::units_fraction* detachment_proability_;
    rolling_observation_sequence rolling_observation_;
    ::common::custom* custom_;
  };

  // rolling_observation (variable-length)
  //
  class rolling_observation
  {
    private:
    rolling_observation (const rolling_observation&);
    rolling_observation& operator= (const rolling_observation&);

    public:
    rolling_observation ();

    rolling_observation*
    _clone () const;

    ~rolling_observation ();

    // rolling_velocity
    //
    const ::common::units_decimal&
    rolling_velocity () const;

    ::common::units_decimal&
    rolling_velocity ();

    void
    rolling_velocity (::common::units_decimal*);

    ::common::units_decimal*
    rolling_velocity_detach ();

    // shear_stress
    //
    const ::common::units_decimal&
    shear_stress () const;

    ::common::units_decimal&
    shear_stress ();

    void
    shear_stress (::common::units_decimal*);

    ::common::units_decimal*
    shear_stress_detach ();

    void
    _copy (rolling_observation&) const;

    private:
    ::common::units_decimal* rolling_velocity_;
    ::common::units_decimal* shear_stress_;
  };

  // friction (variable-length)
  //
  class friction
  {
    private:
    friction (const friction&);
    friction& operator= (const friction&);

    public:
    friction ();

    friction*
    _clone () const;

    ~friction ();

    // compression
    //
    bool
    compression_present () const;

    const ::common::units_decimal_nonnegative&
    compression () const;

    ::common::units_decimal_nonnegative&
    compression ();

    void
    compression (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    compression_detach ();

    // ECM
    //
    bool
    ECM_present () const;

    const ::common::units_decimal_nonnegative&
    ECM () const;

    ::common::units_decimal_nonnegative&
    ECM ();

    void
    ECM (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    ECM_detach ();

    // shear
    //
    bool
    shear_present () const;

    const ::common::units_decimal_nonnegative&
    shear () const;

    ::common::units_decimal_nonnegative&
    shear ();

    void
    shear (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    shear_detach ();

    void
    _copy (friction&) const;

    private:
    ::common::units_decimal_nonnegative* compression_;
    ::common::units_decimal_nonnegative* ECM_;
    ::common::units_decimal_nonnegative* shear_;
  };

  // mechanics (variable-length)
  //
  class mechanics
  {
    private:
    mechanics (const mechanics&);
    mechanics& operator= (const mechanics&);

    public:
    mechanics ();

    mechanics*
    _clone () const;

    ~mechanics ();

    // friction
    //
    bool
    friction_present () const;

    const ::phenotype_common::friction&
    friction () const;

    ::phenotype_common::friction&
    friction ();

    void
    friction (::phenotype_common::friction*);

    ::phenotype_common::friction*
    friction_detach ();

    // maximum_cell_deformation
    //
    bool
    maximum_cell_deformation_present () const;

    const ::common::units_decimal&
    maximum_cell_deformation () const;

    ::common::units_decimal&
    maximum_cell_deformation ();

    void
    maximum_cell_deformation (::common::units_decimal*);

    ::common::units_decimal*
    maximum_cell_deformation_detach ();

    // mechanical_pressure
    //
    bool
    mechanical_pressure_present () const;

    const ::common::units_decimal&
    mechanical_pressure () const;

    ::common::units_decimal&
    mechanical_pressure ();

    void
    mechanical_pressure (::common::units_decimal*);

    ::common::units_decimal*
    mechanical_pressure_detach ();

    // indentation_observation
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::phenotype_common::indentation_observation > indentation_observation_sequence;
    typedef indentation_observation_sequence::iterator indentation_observation_iterator;
    typedef indentation_observation_sequence::const_iterator indentation_observation_const_iterator;

    const indentation_observation_sequence&
    indentation_observation () const;

    indentation_observation_sequence&
    indentation_observation ();

    // poisson_ratio
    //
    bool
    poisson_ratio_present () const;

    const ::common::units_decimal&
    poisson_ratio () const;

    ::common::units_decimal&
    poisson_ratio ();

    void
    poisson_ratio (::common::units_decimal*);

    ::common::units_decimal*
    poisson_ratio_detach ();

    // youngs_modulus
    //
    bool
    youngs_modulus_present () const;

    const ::common::units_decimal&
    youngs_modulus () const;

    ::common::units_decimal&
    youngs_modulus ();

    void
    youngs_modulus (::common::units_decimal*);

    ::common::units_decimal*
    youngs_modulus_detach ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (mechanics&) const;

    private:
    ::phenotype_common::friction* friction_;
    ::common::units_decimal* maximum_cell_deformation_;
    ::common::units_decimal* mechanical_pressure_;
    indentation_observation_sequence indentation_observation_;
    ::common::units_decimal* poisson_ratio_;
    ::common::units_decimal* youngs_modulus_;
    ::common::custom* custom_;
  };

  // indentation_observation (variable-length)
  //
  class indentation_observation
  {
    private:
    indentation_observation (const indentation_observation&);
    indentation_observation& operator= (const indentation_observation&);

    public:
    indentation_observation ();

    indentation_observation*
    _clone () const;

    ~indentation_observation ();

    // depth
    //
    const ::common::units_decimal&
    depth () const;

    ::common::units_decimal&
    depth ();

    void
    depth (::common::units_decimal*);

    ::common::units_decimal*
    depth_detach ();

    // poisson_ratio
    //
    bool
    poisson_ratio_present () const;

    const ::common::units_decimal&
    poisson_ratio () const;

    ::common::units_decimal&
    poisson_ratio ();

    void
    poisson_ratio (::common::units_decimal*);

    ::common::units_decimal*
    poisson_ratio_detach ();

    // youngs_modulus
    //
    bool
    youngs_modulus_present () const;

    const ::common::units_decimal&
    youngs_modulus () const;

    ::common::units_decimal&
    youngs_modulus ();

    void
    youngs_modulus (::common::units_decimal*);

    ::common::units_decimal*
    youngs_modulus_detach ();

    void
    _copy (indentation_observation&) const;

    private:
    ::common::units_decimal* depth_;
    ::common::units_decimal* poisson_ratio_;
    ::common::units_decimal* youngs_modulus_;
  };

  // motility (variable-length)
  //
  class motility
  {
    private:
    motility (const motility&);
    motility& operator= (const motility&);

    public:
    motility ();

    motility*
    _clone () const;

    ~motility ();

    // unrestricted
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::phenotype_common::motility_types > unrestricted_sequence;
    typedef unrestricted_sequence::iterator unrestricted_iterator;
    typedef unrestricted_sequence::const_iterator unrestricted_const_iterator;

    const unrestricted_sequence&
    unrestricted () const;

    unrestricted_sequence&
    unrestricted ();

    // restricted
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::phenotype_common::motility_types > restricted_sequence;
    typedef restricted_sequence::iterator restricted_iterator;
    typedef restricted_sequence::const_iterator restricted_const_iterator;

    const restricted_sequence&
    restricted () const;

    restricted_sequence&
    restricted ();

    void
    _copy (motility&) const;

    private:
    unrestricted_sequence unrestricted_;
    restricted_sequence restricted_;
  };

  // motility_types (variable-length)
  //
  class motility_types
  {
    private:
    motility_types (const motility_types&);
    motility_types& operator= (const motility_types&);

    public:
    motility_types ();

    motility_types*
    _clone () const;

    ~motility_types ();

    // ID
    //
    bool
    ID_present () const;

    void
    ID_present (bool);

    unsigned int
    ID () const;

    unsigned int&
    ID ();

    void
    ID (unsigned int);

    // timescale
    //
    bool
    timescale_present () const;

    const ::phenotype_common::timescale&
    timescale () const;

    ::phenotype_common::timescale&
    timescale ();

    void
    timescale (::phenotype_common::timescale*);

    ::phenotype_common::timescale*
    timescale_detach ();

    // restriction
    //
    bool
    restriction_present () const;

    const ::variables::experimental_conditions&
    restriction () const;

    ::variables::experimental_conditions&
    restriction ();

    void
    restriction (::variables::experimental_conditions*);

    ::variables::experimental_conditions*
    restriction_detach ();

    // net_displacement
    //
    bool
    net_displacement_present () const;

    const ::common::units_decimal&
    net_displacement () const;

    ::common::units_decimal&
    net_displacement ();

    void
    net_displacement (::common::units_decimal*);

    ::common::units_decimal*
    net_displacement_detach ();

    // total_displacement
    //
    bool
    total_displacement_present () const;

    const ::common::units_decimal_nonnegative&
    total_displacement () const;

    ::common::units_decimal_nonnegative&
    total_displacement ();

    void
    total_displacement (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    total_displacement_detach ();

    // mean_square_displacement
    //
    bool
    mean_square_displacement_present () const;

    const ::common::units_decimal_nonnegative&
    mean_square_displacement () const;

    ::common::units_decimal_nonnegative&
    mean_square_displacement ();

    void
    mean_square_displacement (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    mean_square_displacement_detach ();

    // mean_speed
    //
    bool
    mean_speed_present () const;

    const ::common::units_decimal&
    mean_speed () const;

    ::common::units_decimal&
    mean_speed ();

    void
    mean_speed (::common::units_decimal*);

    ::common::units_decimal*
    mean_speed_detach ();

    // net_speed
    //
    bool
    net_speed_present () const;

    const ::common::units_decimal&
    net_speed () const;

    ::common::units_decimal&
    net_speed ();

    void
    net_speed (::common::units_decimal*);

    ::common::units_decimal*
    net_speed_detach ();

    // persistence
    //
    bool
    persistence_present () const;

    const ::common::units_decimal&
    persistence () const;

    ::common::units_decimal&
    persistence ();

    void
    persistence (::common::units_decimal*);

    ::common::units_decimal*
    persistence_detach ();

    // mean_path_length
    //
    bool
    mean_path_length_present () const;

    const ::common::units_decimal&
    mean_path_length () const;

    ::common::units_decimal&
    mean_path_length ();

    void
    mean_path_length (::common::units_decimal*);

    ::common::units_decimal*
    mean_path_length_detach ();

    // diffusion_coefficient
    //
    bool
    diffusion_coefficient_present () const;

    const ::common::units_decimal&
    diffusion_coefficient () const;

    ::common::units_decimal&
    diffusion_coefficient ();

    void
    diffusion_coefficient (::common::units_decimal*);

    ::common::units_decimal*
    diffusion_coefficient_detach ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (motility_types&) const;

    private:
    unsigned int ID_;
    unsigned char ID_present_;
    ::phenotype_common::timescale* timescale_;
    ::variables::experimental_conditions* restriction_;
    ::common::units_decimal* net_displacement_;
    ::common::units_decimal_nonnegative* total_displacement_;
    ::common::units_decimal_nonnegative* mean_square_displacement_;
    ::common::units_decimal* mean_speed_;
    ::common::units_decimal* net_speed_;
    ::common::units_decimal* persistence_;
    ::common::units_decimal* mean_path_length_;
    ::common::units_decimal* diffusion_coefficient_;
    ::common::custom* custom_;
  };

  // timescale (variable-length)
  //
  class timescale: public ::common::units_decimal
  {
    private:
    timescale (const timescale&);
    timescale& operator= (const timescale&);

    public:
    timescale ();

    timescale*
    _clone () const;

    ~timescale ();

    // mitotic
    //
    bool
    mitotic_present () const;

    void
    mitotic_present (bool);

    bool
    mitotic () const;

    bool&
    mitotic ();

    void
    mitotic (bool);

    void
    _copy (timescale&) const;

    private:
    bool mitotic_;
    unsigned char mitotic_present_;
  };

  // transport_processes (variable-length)
  //
  class transport_processes
  {
    private:
    transport_processes (const transport_processes&);
    transport_processes& operator= (const transport_processes&);

    public:
    transport_processes ();

    transport_processes*
    _clone () const;

    ~transport_processes ();

    // variable
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::phenotype_common::transport_variable > variable_sequence;
    typedef variable_sequence::iterator variable_iterator;
    typedef variable_sequence::const_iterator variable_const_iterator;

    const variable_sequence&
    variable () const;

    variable_sequence&
    variable ();

    void
    _copy (transport_processes&) const;

    private:
    variable_sequence variable_;
  };

  // transport_variable (variable-length)
  //
  class transport_variable
  {
    private:
    transport_variable (const transport_variable&);
    transport_variable& operator= (const transport_variable&);

    public:
    transport_variable ();

    transport_variable*
    _clone () const;

    ~transport_variable ();

    // name
    //
    const ::std::string&
    name () const;

    ::std::string&
    name ();

    void
    name (const ::std::string&);

    // units
    //
    bool
    units_present () const;

    void
    units_present (bool);

    const ::std::string&
    units () const;

    ::std::string&
    units ();

    void
    units (const ::std::string&);

    // ID
    //
    bool
    ID_present () const;

    void
    ID_present (bool);

    unsigned long long
    ID () const;

    unsigned long long&
    ID ();

    void
    ID (unsigned long long);

    // type
    //
    bool
    type_present () const;

    void
    type_present (bool);

    const ::variables::amount_type&
    type () const;

    ::variables::amount_type&
    type ();

    void
    type (const ::variables::amount_type&);

    // ChEBI_ID
    //
    bool
    ChEBI_ID_present () const;

    void
    ChEBI_ID_present (bool);

    const ::std::string&
    ChEBI_ID () const;

    ::std::string&
    ChEBI_ID ();

    void
    ChEBI_ID (const ::std::string&);

    // MeSH_ID
    //
    bool
    MeSH_ID_present () const;

    void
    MeSH_ID_present (bool);

    const ::std::string&
    MeSH_ID () const;

    ::std::string&
    MeSH_ID ();

    void
    MeSH_ID (const ::std::string&);

    // DrugBank_ID
    //
    bool
    DrugBank_ID_present () const;

    void
    DrugBank_ID_present (bool);

    const ::std::string&
    DrugBank_ID () const;

    ::std::string&
    DrugBank_ID ();

    void
    DrugBank_ID (const ::std::string&);

    // GMO_ID
    //
    bool
    GMO_ID_present () const;

    void
    GMO_ID_present (bool);

    const ::std::string&
    GMO_ID () const;

    ::std::string&
    GMO_ID ();

    void
    GMO_ID (const ::std::string&);

    // GO_ID
    //
    bool
    GO_ID_present () const;

    void
    GO_ID_present (bool);

    const ::std::string&
    GO_ID () const;

    ::std::string&
    GO_ID ();

    void
    GO_ID (const ::std::string&);

    // UniProt_ID
    //
    bool
    UniProt_ID_present () const;

    void
    UniProt_ID_present (bool);

    const ::std::string&
    UniProt_ID () const;

    ::std::string&
    UniProt_ID ();

    void
    UniProt_ID (const ::std::string&);

    // PR_ID
    //
    bool
    PR_ID_present () const;

    void
    PR_ID_present (bool);

    const ::std::string&
    PR_ID () const;

    ::std::string&
    PR_ID ();

    void
    PR_ID (const ::std::string&);

    // all (variable-length)
    //
    class all_type
    {
      public:
      all_type ();

      all_type*
      _clone () const;

      ~all_type ();

      private:
      all_type (const all_type&);
      all_type& operator= (const all_type&);

      public:
      // export_rate
      //
      bool
      export_rate_present () const;

      const ::common::units_decimal&
      export_rate () const;

      ::common::units_decimal&
      export_rate ();

      void
      export_rate (::common::units_decimal*);

      ::common::units_decimal*
      export_rate_detach ();

      // export_rate_per_unit_surface_area
      //
      bool
      export_rate_per_unit_surface_area_present () const;

      const ::common::units_decimal&
      export_rate_per_unit_surface_area () const;

      ::common::units_decimal&
      export_rate_per_unit_surface_area ();

      void
      export_rate_per_unit_surface_area (::common::units_decimal*);

      ::common::units_decimal*
      export_rate_per_unit_surface_area_detach ();

      // import_rate
      //
      bool
      import_rate_present () const;

      const ::common::units_decimal&
      import_rate () const;

      ::common::units_decimal&
      import_rate ();

      void
      import_rate (::common::units_decimal*);

      ::common::units_decimal*
      import_rate_detach ();

      // import_rate_per_unit_surface_area
      //
      bool
      import_rate_per_unit_surface_area_present () const;

      const ::common::units_decimal&
      import_rate_per_unit_surface_area () const;

      ::common::units_decimal&
      import_rate_per_unit_surface_area ();

      void
      import_rate_per_unit_surface_area (::common::units_decimal*);

      ::common::units_decimal*
      import_rate_per_unit_surface_area_detach ();

      // saturation_density
      //
      bool
      saturation_density_present () const;

      const ::common::units_decimal&
      saturation_density () const;

      ::common::units_decimal&
      saturation_density ();

      void
      saturation_density (::common::units_decimal*);

      ::common::units_decimal*
      saturation_density_detach ();

      // custom
      //
      bool
      custom_present () const;

      const ::common::custom&
      custom () const;

      ::common::custom&
      custom ();

      void
      custom (::common::custom*);

      ::common::custom*
      custom_detach ();

      void
      _copy (all_type&) const;

      private:
      ::common::units_decimal* export_rate_;
      ::common::units_decimal* export_rate_per_unit_surface_area_;
      ::common::units_decimal* import_rate_;
      ::common::units_decimal* import_rate_per_unit_surface_area_;
      ::common::units_decimal* saturation_density_;
      ::common::custom* custom_;
    };

    bool
    all_present () const;

    const all_type&
    all () const;

    all_type&
    all ();

    void
    all (all_type*);

    all_type*
    all_detach ();

    void
    _copy (transport_variable&) const;

    private:
    ::std::string name_;
    ::std::string units_;
    unsigned char units_present_;
    unsigned long long ID_;
    unsigned char ID_present_;
    ::variables::amount_type type_;
    unsigned char type_present_;
    ::std::string ChEBI_ID_;
    unsigned char ChEBI_ID_present_;
    ::std::string MeSH_ID_;
    unsigned char MeSH_ID_present_;
    ::std::string DrugBank_ID_;
    unsigned char DrugBank_ID_present_;
    ::std::string GMO_ID_;
    unsigned char GMO_ID_present_;
    ::std::string GO_ID_;
    unsigned char GO_ID_present_;
    ::std::string UniProt_ID_;
    unsigned char UniProt_ID_present_;
    ::std::string PR_ID_;
    unsigned char PR_ID_present_;
    all_type* all_;
  };

  // geometrical_parameters (variable-length)
  //
  class geometrical_parameters
  {
    private:
    geometrical_parameters (const geometrical_parameters&);
    geometrical_parameters& operator= (const geometrical_parameters&);

    public:
    geometrical_parameters ();

    geometrical_parameters*
    _clone () const;

    ~geometrical_parameters ();

    // units
    //
    bool
    units_present () const;

    void
    units_present (bool);

    const ::std::string&
    units () const;

    ::std::string&
    units ();

    void
    units (const ::std::string&);

    // aspect_ratio
    //
    bool
    aspect_ratio_present () const;

    const ::common::units_decimal_nonnegative&
    aspect_ratio () const;

    ::common::units_decimal_nonnegative&
    aspect_ratio ();

    void
    aspect_ratio (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    aspect_ratio_detach ();

    // circularity
    //
    bool
    circularity_present () const;

    const ::common::units_decimal_nonnegative&
    circularity () const;

    ::common::units_decimal_nonnegative&
    circularity ();

    void
    circularity (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    circularity_detach ();

    // eccentricity
    //
    bool
    eccentricity_present () const;

    const ::common::units_decimal_nonnegative&
    eccentricity () const;

    ::common::units_decimal_nonnegative&
    eccentricity ();

    void
    eccentricity (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    eccentricity_detach ();

    // sphericity
    //
    bool
    sphericity_present () const;

    const ::common::units_decimal_nonnegative&
    sphericity () const;

    ::common::units_decimal_nonnegative&
    sphericity ();

    void
    sphericity (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    sphericity_detach ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (geometrical_parameters&) const;

    private:
    ::std::string units_;
    unsigned char units_present_;
    ::common::units_decimal_nonnegative* aspect_ratio_;
    ::common::units_decimal_nonnegative* circularity_;
    ::common::units_decimal_nonnegative* eccentricity_;
    ::common::units_decimal_nonnegative* sphericity_;
    ::common::custom* custom_;
  };

  // lengths (variable-length)
  //
  class lengths
  {
    private:
    lengths (const lengths&);
    lengths& operator= (const lengths&);

    public:
    lengths ();

    lengths*
    _clone () const;

    ~lengths ();

    // units
    //
    bool
    units_present () const;

    void
    units_present (bool);

    const ::std::string&
    units () const;

    ::std::string&
    units ();

    void
    units (const ::std::string&);

    // diameter
    //
    bool
    diameter_present () const;

    const ::common::units_decimal_nonnegative&
    diameter () const;

    ::common::units_decimal_nonnegative&
    diameter ();

    void
    diameter (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    diameter_detach ();

    // major_axis
    //
    bool
    major_axis_present () const;

    const ::common::units_decimal_nonnegative&
    major_axis () const;

    ::common::units_decimal_nonnegative&
    major_axis ();

    void
    major_axis (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    major_axis_detach ();

    // minor_axis
    //
    bool
    minor_axis_present () const;

    const ::common::units_decimal_nonnegative&
    minor_axis () const;

    ::common::units_decimal_nonnegative&
    minor_axis ();

    void
    minor_axis (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    minor_axis_detach ();

    // perimeter
    //
    bool
    perimeter_present () const;

    const ::common::units_decimal_nonnegative&
    perimeter () const;

    ::common::units_decimal_nonnegative&
    perimeter ();

    void
    perimeter (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    perimeter_detach ();

    // radius
    //
    bool
    radius_present () const;

    const ::common::units_decimal_nonnegative&
    radius () const;

    ::common::units_decimal_nonnegative&
    radius ();

    void
    radius (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    radius_detach ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (lengths&) const;

    private:
    ::std::string units_;
    unsigned char units_present_;
    ::common::units_decimal_nonnegative* diameter_;
    ::common::units_decimal_nonnegative* major_axis_;
    ::common::units_decimal_nonnegative* minor_axis_;
    ::common::units_decimal_nonnegative* perimeter_;
    ::common::units_decimal_nonnegative* radius_;
    ::common::custom* custom_;
  };

  // areas_3D (variable-length)
  //
  class areas_3D
  {
    private:
    areas_3D (const areas_3D&);
    areas_3D& operator= (const areas_3D&);

    public:
    areas_3D ();

    areas_3D*
    _clone () const;

    ~areas_3D ();

    // units
    //
    bool
    units_present () const;

    void
    units_present (bool);

    const ::std::string&
    units () const;

    ::std::string&
    units ();

    void
    units (const ::std::string&);

    // free_surface_area
    //
    bool
    free_surface_area_present () const;

    const ::common::units_decimal_nonnegative&
    free_surface_area () const;

    ::common::units_decimal_nonnegative&
    free_surface_area ();

    void
    free_surface_area (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    free_surface_area_detach ();

    // total_surface_area
    //
    bool
    total_surface_area_present () const;

    const ::common::units_decimal_nonnegative&
    total_surface_area () const;

    ::common::units_decimal_nonnegative&
    total_surface_area ();

    void
    total_surface_area (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    total_surface_area_detach ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (areas_3D&) const;

    private:
    ::std::string units_;
    unsigned char units_present_;
    ::common::units_decimal_nonnegative* free_surface_area_;
    ::common::units_decimal_nonnegative* total_surface_area_;
    ::common::custom* custom_;
  };

  // areas_2D (variable-length)
  //
  class areas_2D
  {
    private:
    areas_2D (const areas_2D&);
    areas_2D& operator= (const areas_2D&);

    public:
    areas_2D ();

    areas_2D*
    _clone () const;

    ~areas_2D ();

    // units
    //
    bool
    units_present () const;

    void
    units_present (bool);

    const ::std::string&
    units () const;

    ::std::string&
    units ();

    void
    units (const ::std::string&);

    // total_area
    //
    bool
    total_area_present () const;

    const ::common::units_decimal_nonnegative&
    total_area () const;

    ::common::units_decimal_nonnegative&
    total_area ();

    void
    total_area (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    total_area_detach ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (areas_2D&) const;

    private:
    ::std::string units_;
    unsigned char units_present_;
    ::common::units_decimal_nonnegative* total_area_;
    ::common::custom* custom_;
  };

  // volumes (variable-length)
  //
  class volumes
  {
    private:
    volumes (const volumes&);
    volumes& operator= (const volumes&);

    public:
    volumes ();

    volumes*
    _clone () const;

    ~volumes ();

    // units
    //
    bool
    units_present () const;

    void
    units_present (bool);

    const ::std::string&
    units () const;

    ::std::string&
    units ();

    void
    units (const ::std::string&);

    // fluid_volume
    //
    bool
    fluid_volume_present () const;

    const ::common::units_decimal_nonnegative&
    fluid_volume () const;

    ::common::units_decimal_nonnegative&
    fluid_volume ();

    void
    fluid_volume (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    fluid_volume_detach ();

    // fluid_volume_fraction
    //
    bool
    fluid_volume_fraction_present () const;

    const ::common::units_fraction&
    fluid_volume_fraction () const;

    ::common::units_fraction&
    fluid_volume_fraction ();

    void
    fluid_volume_fraction (::common::units_fraction*);

    ::common::units_fraction*
    fluid_volume_fraction_detach ();

    // solid_calcified_volume
    //
    bool
    solid_calcified_volume_present () const;

    const ::common::units_decimal_nonnegative&
    solid_calcified_volume () const;

    ::common::units_decimal_nonnegative&
    solid_calcified_volume ();

    void
    solid_calcified_volume (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    solid_calcified_volume_detach ();

    // solid_volume
    //
    bool
    solid_volume_present () const;

    const ::common::units_decimal_nonnegative&
    solid_volume () const;

    ::common::units_decimal_nonnegative&
    solid_volume ();

    void
    solid_volume (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    solid_volume_detach ();

    // solid_volume_fraction
    //
    bool
    solid_volume_fraction_present () const;

    const ::common::units_fraction&
    solid_volume_fraction () const;

    ::common::units_fraction&
    solid_volume_fraction ();

    void
    solid_volume_fraction (::common::units_fraction*);

    ::common::units_fraction*
    solid_volume_fraction_detach ();

    // total_volume
    //
    bool
    total_volume_present () const;

    const ::common::units_decimal_nonnegative&
    total_volume () const;

    ::common::units_decimal_nonnegative&
    total_volume ();

    void
    total_volume (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    total_volume_detach ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (volumes&) const;

    private:
    ::std::string units_;
    unsigned char units_present_;
    ::common::units_decimal_nonnegative* fluid_volume_;
    ::common::units_fraction* fluid_volume_fraction_;
    ::common::units_decimal_nonnegative* solid_calcified_volume_;
    ::common::units_decimal_nonnegative* solid_volume_;
    ::common::units_fraction* solid_volume_fraction_;
    ::common::units_decimal_nonnegative* total_volume_;
    ::common::custom* custom_;
  };

  // geometrical_properties (variable-length)
  //
  class geometrical_properties
  {
    private:
    geometrical_properties (const geometrical_properties&);
    geometrical_properties& operator= (const geometrical_properties&);

    public:
    geometrical_properties ();

    geometrical_properties*
    _clone () const;

    ~geometrical_properties ();

    // parameters
    //
    bool
    parameters_present () const;

    const ::phenotype_common::geometrical_parameters&
    parameters () const;

    ::phenotype_common::geometrical_parameters&
    parameters ();

    void
    parameters (::phenotype_common::geometrical_parameters*);

    ::phenotype_common::geometrical_parameters*
    parameters_detach ();

    // lengths
    //
    bool
    lengths_present () const;

    const ::phenotype_common::lengths&
    lengths () const;

    ::phenotype_common::lengths&
    lengths ();

    void
    lengths (::phenotype_common::lengths*);

    ::phenotype_common::lengths*
    lengths_detach ();

    // areas
    //
    bool
    areas_present () const;

    const ::phenotype_common::areas_3D&
    areas () const;

    ::phenotype_common::areas_3D&
    areas ();

    void
    areas (::phenotype_common::areas_3D*);

    ::phenotype_common::areas_3D*
    areas_detach ();

    // volumes
    //
    bool
    volumes_present () const;

    const ::phenotype_common::volumes&
    volumes () const;

    ::phenotype_common::volumes&
    volumes ();

    void
    volumes (::phenotype_common::volumes*);

    ::phenotype_common::volumes*
    volumes_detach ();

    // cross_section
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::phenotype_common::cross_section > cross_section_sequence;
    typedef cross_section_sequence::iterator cross_section_iterator;
    typedef cross_section_sequence::const_iterator cross_section_const_iterator;

    const cross_section_sequence&
    cross_section () const;

    cross_section_sequence&
    cross_section ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (geometrical_properties&) const;

    private:
    ::phenotype_common::geometrical_parameters* parameters_;
    ::phenotype_common::lengths* lengths_;
    ::phenotype_common::areas_3D* areas_;
    ::phenotype_common::volumes* volumes_;
    cross_section_sequence cross_section_;
    ::common::custom* custom_;
  };

  // cross_section (variable-length)
  //
  class cross_section
  {
    private:
    cross_section (const cross_section&);
    cross_section& operator= (const cross_section&);

    public:
    cross_section ();

    cross_section*
    _clone () const;

    ~cross_section ();

    // parameters
    //
    bool
    parameters_present () const;

    const ::phenotype_common::geometrical_parameters&
    parameters () const;

    ::phenotype_common::geometrical_parameters&
    parameters ();

    void
    parameters (::phenotype_common::geometrical_parameters*);

    ::phenotype_common::geometrical_parameters*
    parameters_detach ();

    // lengths
    //
    bool
    lengths_present () const;

    const ::phenotype_common::lengths&
    lengths () const;

    ::phenotype_common::lengths&
    lengths ();

    void
    lengths (::phenotype_common::lengths*);

    ::phenotype_common::lengths*
    lengths_detach ();

    // areas
    //
    bool
    areas_present () const;

    const ::phenotype_common::areas_2D&
    areas () const;

    ::phenotype_common::areas_2D&
    areas ();

    void
    areas (::phenotype_common::areas_2D*);

    ::phenotype_common::areas_2D*
    areas_detach ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (cross_section&) const;

    private:
    ::phenotype_common::geometrical_parameters* parameters_;
    ::phenotype_common::lengths* lengths_;
    ::phenotype_common::areas_2D* areas_;
    ::common::custom* custom_;
  };

  // mass (variable-length)
  //
  class mass
  {
    private:
    mass (const mass&);
    mass& operator= (const mass&);

    public:
    mass ();

    mass*
    _clone () const;

    ~mass ();

    // biomass
    //
    bool
    biomass_present () const;

    const ::common::units_decimal_nonnegative&
    biomass () const;

    ::common::units_decimal_nonnegative&
    biomass ();

    void
    biomass (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    biomass_detach ();

    // fluid_mass
    //
    bool
    fluid_mass_present () const;

    const ::common::units_decimal_nonnegative&
    fluid_mass () const;

    ::common::units_decimal_nonnegative&
    fluid_mass ();

    void
    fluid_mass (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    fluid_mass_detach ();

    // total_mass
    //
    bool
    total_mass_present () const;

    const ::common::units_decimal_nonnegative&
    total_mass () const;

    ::common::units_decimal_nonnegative&
    total_mass ();

    void
    total_mass (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    total_mass_detach ();

    void
    _copy (mass&) const;

    private:
    ::common::units_decimal_nonnegative* biomass_;
    ::common::units_decimal_nonnegative* fluid_mass_;
    ::common::units_decimal_nonnegative* total_mass_;
  };
}

#ifndef XSDE_DONT_INCLUDE_INLINE

#include "common.ipp"

#include "variables.ipp"

#endif // XSDE_DONT_INCLUDE_INLINE

#ifndef XSDE_DONT_INCLUDE_INLINE
#include "phenotype_common.ipp"
#endif // XSDE_DONT_INCLUDE_INLINE

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

#endif // PHENOTYPE_COMMON_HPP
