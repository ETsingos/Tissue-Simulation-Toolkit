// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "phenotype_common-sskel.hpp"

#include <assert.h>

#include <string.h>
#include <xsde/cxx/serializer/substitution-map.hxx>
#include <xsde/cxx/serializer/validating/inheritance-map.hxx>

static
const ::xsde::cxx::serializer::substitution_map_init
_xsde_substitution_map_init_;

static
const ::xsde::cxx::serializer::validating::inheritance_map_init
_xsde_inheritance_map_init_;

namespace phenotype_common
{
  // adhesion_sskel
  //

  bool adhesion_sskel::
  adhesion_bond_breaking_rate_present ()
  {
    return this->adhesion_impl_ ? this->adhesion_impl_->adhesion_bond_breaking_rate_present () : false;
  }

  bool adhesion_sskel::
  adhesion_bond_formation_rate_present ()
  {
    return this->adhesion_impl_ ? this->adhesion_impl_->adhesion_bond_formation_rate_present () : false;
  }

  bool adhesion_sskel::
  adhesion_spring_constant_present ()
  {
    return this->adhesion_impl_ ? this->adhesion_impl_->adhesion_spring_constant_present () : false;
  }

  bool adhesion_sskel::
  adhesion_receptor_density_present ()
  {
    return this->adhesion_impl_ ? this->adhesion_impl_->adhesion_receptor_density_present () : false;
  }

  bool adhesion_sskel::
  surface_binding_energy_present ()
  {
    return this->adhesion_impl_ ? this->adhesion_impl_->surface_binding_energy_present () : false;
  }

  bool adhesion_sskel::
  number_of_adhered_cells_present ()
  {
    return this->adhesion_impl_ ? this->adhesion_impl_->number_of_adhered_cells_present () : false;
  }

  bool adhesion_sskel::
  maximum_number_of_adhered_cells_present ()
  {
    return this->adhesion_impl_ ? this->adhesion_impl_->maximum_number_of_adhered_cells_present () : false;
  }

  bool adhesion_sskel::
  adhered_surface_area_present ()
  {
    return this->adhesion_impl_ ? this->adhesion_impl_->adhered_surface_area_present () : false;
  }

  bool adhesion_sskel::
  maximum_adhered_surface_area_present ()
  {
    return this->adhesion_impl_ ? this->adhesion_impl_->maximum_adhered_surface_area_present () : false;
  }

  bool adhesion_sskel::
  adhesion_force_per_surface_area_present ()
  {
    return this->adhesion_impl_ ? this->adhesion_impl_->adhesion_force_per_surface_area_present () : false;
  }

  bool adhesion_sskel::
  adhesion_probability_present ()
  {
    return this->adhesion_impl_ ? this->adhesion_impl_->adhesion_probability_present () : false;
  }

  bool adhesion_sskel::
  detachment_proability_present ()
  {
    return this->adhesion_impl_ ? this->adhesion_impl_->detachment_proability_present () : false;
  }

  bool adhesion_sskel::
  rolling_observation_next ()
  {
    return this->adhesion_impl_ ? this->adhesion_impl_->rolling_observation_next () : false;
  }

  bool adhesion_sskel::
  custom_present ()
  {
    return this->adhesion_impl_ ? this->adhesion_impl_->custom_present () : false;
  }

  void adhesion_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->adhesion_bond_breaking_rate_serializer_)
      this->adhesion_bond_breaking_rate_serializer_->_reset ();

    if (this->adhesion_bond_breaking_rate_serializer_map_)
      this->adhesion_bond_breaking_rate_serializer_map_->reset ();

    if (this->adhesion_bond_formation_rate_serializer_)
      this->adhesion_bond_formation_rate_serializer_->_reset ();

    if (this->adhesion_bond_formation_rate_serializer_map_)
      this->adhesion_bond_formation_rate_serializer_map_->reset ();

    if (this->adhesion_spring_constant_serializer_)
      this->adhesion_spring_constant_serializer_->_reset ();

    if (this->adhesion_spring_constant_serializer_map_)
      this->adhesion_spring_constant_serializer_map_->reset ();

    if (this->adhesion_receptor_density_serializer_)
      this->adhesion_receptor_density_serializer_->_reset ();

    if (this->adhesion_receptor_density_serializer_map_)
      this->adhesion_receptor_density_serializer_map_->reset ();

    if (this->surface_binding_energy_serializer_)
      this->surface_binding_energy_serializer_->_reset ();

    if (this->surface_binding_energy_serializer_map_)
      this->surface_binding_energy_serializer_map_->reset ();

    if (this->number_of_adhered_cells_serializer_)
      this->number_of_adhered_cells_serializer_->_reset ();

    if (this->number_of_adhered_cells_serializer_map_)
      this->number_of_adhered_cells_serializer_map_->reset ();

    if (this->maximum_number_of_adhered_cells_serializer_)
      this->maximum_number_of_adhered_cells_serializer_->_reset ();

    if (this->maximum_number_of_adhered_cells_serializer_map_)
      this->maximum_number_of_adhered_cells_serializer_map_->reset ();

    if (this->adhered_surface_area_serializer_)
      this->adhered_surface_area_serializer_->_reset ();

    if (this->adhered_surface_area_serializer_map_)
      this->adhered_surface_area_serializer_map_->reset ();

    if (this->maximum_adhered_surface_area_serializer_)
      this->maximum_adhered_surface_area_serializer_->_reset ();

    if (this->maximum_adhered_surface_area_serializer_map_)
      this->maximum_adhered_surface_area_serializer_map_->reset ();

    if (this->adhesion_force_per_surface_area_serializer_)
      this->adhesion_force_per_surface_area_serializer_->_reset ();

    if (this->adhesion_force_per_surface_area_serializer_map_)
      this->adhesion_force_per_surface_area_serializer_map_->reset ();

    if (this->adhesion_probability_serializer_)
      this->adhesion_probability_serializer_->_reset ();

    if (this->adhesion_probability_serializer_map_)
      this->adhesion_probability_serializer_map_->reset ();

    if (this->detachment_proability_serializer_)
      this->detachment_proability_serializer_->_reset ();

    if (this->detachment_proability_serializer_map_)
      this->detachment_proability_serializer_map_->reset ();

    if (this->rolling_observation_serializer_)
      this->rolling_observation_serializer_->_reset ();

    if (this->rolling_observation_serializer_map_)
      this->rolling_observation_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* adhesion_sskel::
  _static_type ()
  {
    return "adhesion phenotype_common";
  }

  const char* adhesion_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // rolling_observation_sskel
  //

  void rolling_observation_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->rolling_velocity_serializer_)
      this->rolling_velocity_serializer_->_reset ();

    if (this->rolling_velocity_serializer_map_)
      this->rolling_velocity_serializer_map_->reset ();

    if (this->shear_stress_serializer_)
      this->shear_stress_serializer_->_reset ();

    if (this->shear_stress_serializer_map_)
      this->shear_stress_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* rolling_observation_sskel::
  _static_type ()
  {
    return "rolling_observation phenotype_common";
  }

  const char* rolling_observation_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // friction_sskel
  //

  bool friction_sskel::
  compression_present ()
  {
    return this->friction_impl_ ? this->friction_impl_->compression_present () : false;
  }

  bool friction_sskel::
  ECM_present ()
  {
    return this->friction_impl_ ? this->friction_impl_->ECM_present () : false;
  }

  bool friction_sskel::
  shear_present ()
  {
    return this->friction_impl_ ? this->friction_impl_->shear_present () : false;
  }

  void friction_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->compression_serializer_)
      this->compression_serializer_->_reset ();

    if (this->compression_serializer_map_)
      this->compression_serializer_map_->reset ();

    if (this->ECM_serializer_)
      this->ECM_serializer_->_reset ();

    if (this->ECM_serializer_map_)
      this->ECM_serializer_map_->reset ();

    if (this->shear_serializer_)
      this->shear_serializer_->_reset ();

    if (this->shear_serializer_map_)
      this->shear_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* friction_sskel::
  _static_type ()
  {
    return "friction phenotype_common";
  }

  const char* friction_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // mechanics_sskel
  //

  bool mechanics_sskel::
  friction_present ()
  {
    return this->mechanics_impl_ ? this->mechanics_impl_->friction_present () : false;
  }

  bool mechanics_sskel::
  maximum_cell_deformation_present ()
  {
    return this->mechanics_impl_ ? this->mechanics_impl_->maximum_cell_deformation_present () : false;
  }

  bool mechanics_sskel::
  mechanical_pressure_present ()
  {
    return this->mechanics_impl_ ? this->mechanics_impl_->mechanical_pressure_present () : false;
  }

  bool mechanics_sskel::
  indentation_observation_next ()
  {
    return this->mechanics_impl_ ? this->mechanics_impl_->indentation_observation_next () : false;
  }

  bool mechanics_sskel::
  poisson_ratio_present ()
  {
    return this->mechanics_impl_ ? this->mechanics_impl_->poisson_ratio_present () : false;
  }

  bool mechanics_sskel::
  youngs_modulus_present ()
  {
    return this->mechanics_impl_ ? this->mechanics_impl_->youngs_modulus_present () : false;
  }

  bool mechanics_sskel::
  custom_present ()
  {
    return this->mechanics_impl_ ? this->mechanics_impl_->custom_present () : false;
  }

  void mechanics_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->friction_serializer_)
      this->friction_serializer_->_reset ();

    if (this->friction_serializer_map_)
      this->friction_serializer_map_->reset ();

    if (this->maximum_cell_deformation_serializer_)
      this->maximum_cell_deformation_serializer_->_reset ();

    if (this->maximum_cell_deformation_serializer_map_)
      this->maximum_cell_deformation_serializer_map_->reset ();

    if (this->mechanical_pressure_serializer_)
      this->mechanical_pressure_serializer_->_reset ();

    if (this->mechanical_pressure_serializer_map_)
      this->mechanical_pressure_serializer_map_->reset ();

    if (this->indentation_observation_serializer_)
      this->indentation_observation_serializer_->_reset ();

    if (this->indentation_observation_serializer_map_)
      this->indentation_observation_serializer_map_->reset ();

    if (this->poisson_ratio_serializer_)
      this->poisson_ratio_serializer_->_reset ();

    if (this->poisson_ratio_serializer_map_)
      this->poisson_ratio_serializer_map_->reset ();

    if (this->youngs_modulus_serializer_)
      this->youngs_modulus_serializer_->_reset ();

    if (this->youngs_modulus_serializer_map_)
      this->youngs_modulus_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* mechanics_sskel::
  _static_type ()
  {
    return "mechanics phenotype_common";
  }

  const char* mechanics_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // indentation_observation_sskel
  //

  bool indentation_observation_sskel::
  poisson_ratio_present ()
  {
    return this->indentation_observation_impl_ ? this->indentation_observation_impl_->poisson_ratio_present () : false;
  }

  bool indentation_observation_sskel::
  youngs_modulus_present ()
  {
    return this->indentation_observation_impl_ ? this->indentation_observation_impl_->youngs_modulus_present () : false;
  }

  void indentation_observation_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->depth_serializer_)
      this->depth_serializer_->_reset ();

    if (this->depth_serializer_map_)
      this->depth_serializer_map_->reset ();

    if (this->poisson_ratio_serializer_)
      this->poisson_ratio_serializer_->_reset ();

    if (this->poisson_ratio_serializer_map_)
      this->poisson_ratio_serializer_map_->reset ();

    if (this->youngs_modulus_serializer_)
      this->youngs_modulus_serializer_->_reset ();

    if (this->youngs_modulus_serializer_map_)
      this->youngs_modulus_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* indentation_observation_sskel::
  _static_type ()
  {
    return "indentation_observation phenotype_common";
  }

  const char* indentation_observation_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // motility_sskel
  //

  bool motility_sskel::
  unrestricted_next ()
  {
    return this->motility_impl_ ? this->motility_impl_->unrestricted_next () : false;
  }

  bool motility_sskel::
  restricted_next ()
  {
    return this->motility_impl_ ? this->motility_impl_->restricted_next () : false;
  }

  void motility_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->unrestricted_serializer_)
      this->unrestricted_serializer_->_reset ();

    if (this->unrestricted_serializer_map_)
      this->unrestricted_serializer_map_->reset ();

    if (this->restricted_serializer_)
      this->restricted_serializer_->_reset ();

    if (this->restricted_serializer_map_)
      this->restricted_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* motility_sskel::
  _static_type ()
  {
    return "motility phenotype_common";
  }

  const char* motility_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // motility_types_sskel
  //

  bool motility_types_sskel::
  ID_present ()
  {
    return this->motility_types_impl_ ? this->motility_types_impl_->ID_present () : false;
  }

  bool motility_types_sskel::
  timescale_present ()
  {
    return this->motility_types_impl_ ? this->motility_types_impl_->timescale_present () : false;
  }

  bool motility_types_sskel::
  restriction_present ()
  {
    return this->motility_types_impl_ ? this->motility_types_impl_->restriction_present () : false;
  }

  bool motility_types_sskel::
  net_displacement_present ()
  {
    return this->motility_types_impl_ ? this->motility_types_impl_->net_displacement_present () : false;
  }

  bool motility_types_sskel::
  total_displacement_present ()
  {
    return this->motility_types_impl_ ? this->motility_types_impl_->total_displacement_present () : false;
  }

  bool motility_types_sskel::
  mean_square_displacement_present ()
  {
    return this->motility_types_impl_ ? this->motility_types_impl_->mean_square_displacement_present () : false;
  }

  bool motility_types_sskel::
  mean_speed_present ()
  {
    return this->motility_types_impl_ ? this->motility_types_impl_->mean_speed_present () : false;
  }

  bool motility_types_sskel::
  net_speed_present ()
  {
    return this->motility_types_impl_ ? this->motility_types_impl_->net_speed_present () : false;
  }

  bool motility_types_sskel::
  persistence_present ()
  {
    return this->motility_types_impl_ ? this->motility_types_impl_->persistence_present () : false;
  }

  bool motility_types_sskel::
  mean_path_length_present ()
  {
    return this->motility_types_impl_ ? this->motility_types_impl_->mean_path_length_present () : false;
  }

  bool motility_types_sskel::
  diffusion_coefficient_present ()
  {
    return this->motility_types_impl_ ? this->motility_types_impl_->diffusion_coefficient_present () : false;
  }

  bool motility_types_sskel::
  custom_present ()
  {
    return this->motility_types_impl_ ? this->motility_types_impl_->custom_present () : false;
  }

  void motility_types_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    if (this->ID_serializer_)
      this->ID_serializer_->_reset ();

    this->resetting_ = true;

    if (this->timescale_serializer_)
      this->timescale_serializer_->_reset ();

    if (this->timescale_serializer_map_)
      this->timescale_serializer_map_->reset ();

    if (this->restriction_serializer_)
      this->restriction_serializer_->_reset ();

    if (this->restriction_serializer_map_)
      this->restriction_serializer_map_->reset ();

    if (this->net_displacement_serializer_)
      this->net_displacement_serializer_->_reset ();

    if (this->net_displacement_serializer_map_)
      this->net_displacement_serializer_map_->reset ();

    if (this->total_displacement_serializer_)
      this->total_displacement_serializer_->_reset ();

    if (this->total_displacement_serializer_map_)
      this->total_displacement_serializer_map_->reset ();

    if (this->mean_square_displacement_serializer_)
      this->mean_square_displacement_serializer_->_reset ();

    if (this->mean_square_displacement_serializer_map_)
      this->mean_square_displacement_serializer_map_->reset ();

    if (this->mean_speed_serializer_)
      this->mean_speed_serializer_->_reset ();

    if (this->mean_speed_serializer_map_)
      this->mean_speed_serializer_map_->reset ();

    if (this->net_speed_serializer_)
      this->net_speed_serializer_->_reset ();

    if (this->net_speed_serializer_map_)
      this->net_speed_serializer_map_->reset ();

    if (this->persistence_serializer_)
      this->persistence_serializer_->_reset ();

    if (this->persistence_serializer_map_)
      this->persistence_serializer_map_->reset ();

    if (this->mean_path_length_serializer_)
      this->mean_path_length_serializer_->_reset ();

    if (this->mean_path_length_serializer_map_)
      this->mean_path_length_serializer_map_->reset ();

    if (this->diffusion_coefficient_serializer_)
      this->diffusion_coefficient_serializer_->_reset ();

    if (this->diffusion_coefficient_serializer_map_)
      this->diffusion_coefficient_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* motility_types_sskel::
  _static_type ()
  {
    return "motility_types phenotype_common";
  }

  const char* motility_types_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // timescale_sskel
  //

  bool timescale_sskel::
  mitotic_present ()
  {
    return this->timescale_impl_ ? this->timescale_impl_->mitotic_present () : false;
  }

  void timescale_sskel::
  _reset ()
  {
    typedef ::common::units_decimal_sskel base;
    base::_reset ();

    if (this->mitotic_serializer_)
      this->mitotic_serializer_->_reset ();
  }

  const char* timescale_sskel::
  _static_type ()
  {
    return "timescale phenotype_common";
  }

  const char* timescale_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  static
  const ::xsde::cxx::serializer::validating::inheritance_map_entry
  _xsde_timescale_sskel_inheritance_map_entry_ (
    timescale_sskel::_static_type (),
    ::common::units_decimal_sskel::_static_type ());

  void timescale_sskel::
  pre (const ::common::units_decimal& x)
  {
    assert (this->units_decimal_impl_);
    this->units_decimal_impl_->pre (x);
  }

  ::std::string timescale_sskel::
  units ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->units ();
  }

  ::std::string timescale_sskel::
  measurement_type ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->measurement_type ();
  }

  double timescale_sskel::
  uncertainty ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->uncertainty ();
  }

  double timescale_sskel::
  negative_uncertainty ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->negative_uncertainty ();
  }

  double timescale_sskel::
  positive_uncertainty ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->positive_uncertainty ();
  }

  double timescale_sskel::
  uncertainty_percentage ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->uncertainty_percentage ();
  }

  double timescale_sskel::
  negative_uncertainty_percentage ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->negative_uncertainty_percentage ();
  }

  double timescale_sskel::
  positive_uncertainty_percentage ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->positive_uncertainty_percentage ();
  }

  double timescale_sskel::
  median ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->median ();
  }

  double timescale_sskel::
  standard_deviation ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->standard_deviation ();
  }

  const ::common::two_doubles& timescale_sskel::
  interquartile_range ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->interquartile_range ();
  }

  const ::common::two_doubles& timescale_sskel::
  range ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->range ();
  }

  double timescale_sskel::
  min ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->min ();
  }

  double timescale_sskel::
  max ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->max ();
  }

  double timescale_sskel::
  standard_error ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->standard_error ();
  }

  double timescale_sskel::
  standard_error_of_the_mean ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->standard_error_of_the_mean ();
  }

  int timescale_sskel::
  number_obs ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->number_obs ();
  }

  double timescale_sskel::
  skewnesss ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->skewnesss ();
  }

  double timescale_sskel::
  kurtosis ()
  {
    assert (this->units_decimal_impl_);
    return this->units_decimal_impl_->kurtosis ();
  }

  // transport_processes_sskel
  //

  void transport_processes_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->variable_serializer_)
      this->variable_serializer_->_reset ();

    if (this->variable_serializer_map_)
      this->variable_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* transport_processes_sskel::
  _static_type ()
  {
    return "transport_processes phenotype_common";
  }

  const char* transport_processes_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // transport_variable_sskel
  //

  bool transport_variable_sskel::
  units_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->units_present () : false;
  }

  bool transport_variable_sskel::
  ID_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->ID_present () : false;
  }

  bool transport_variable_sskel::
  type_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->type_present () : false;
  }

  bool transport_variable_sskel::
  ChEBI_ID_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->ChEBI_ID_present () : false;
  }

  bool transport_variable_sskel::
  MeSH_ID_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->MeSH_ID_present () : false;
  }

  bool transport_variable_sskel::
  DrugBank_ID_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->DrugBank_ID_present () : false;
  }

  bool transport_variable_sskel::
  GMO_ID_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->GMO_ID_present () : false;
  }

  bool transport_variable_sskel::
  GO_ID_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->GO_ID_present () : false;
  }

  bool transport_variable_sskel::
  UniProt_ID_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->UniProt_ID_present () : false;
  }

  bool transport_variable_sskel::
  PR_ID_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->PR_ID_present () : false;
  }

  bool transport_variable_sskel::
  all_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->all_present () : false;
  }

  bool transport_variable_sskel::
  export_rate_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->export_rate_present () : false;
  }

  bool transport_variable_sskel::
  export_rate_per_unit_surface_area_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->export_rate_per_unit_surface_area_present () : false;
  }

  bool transport_variable_sskel::
  import_rate_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->import_rate_present () : false;
  }

  bool transport_variable_sskel::
  import_rate_per_unit_surface_area_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->import_rate_per_unit_surface_area_present () : false;
  }

  bool transport_variable_sskel::
  saturation_density_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->saturation_density_present () : false;
  }

  bool transport_variable_sskel::
  custom_present ()
  {
    return this->transport_variable_impl_ ? this->transport_variable_impl_->custom_present () : false;
  }

  void transport_variable_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    if (this->name_serializer_)
      this->name_serializer_->_reset ();

    if (this->units_serializer_)
      this->units_serializer_->_reset ();

    if (this->ID_serializer_)
      this->ID_serializer_->_reset ();

    if (this->type_serializer_)
      this->type_serializer_->_reset ();

    if (this->ChEBI_ID_serializer_)
      this->ChEBI_ID_serializer_->_reset ();

    if (this->MeSH_ID_serializer_)
      this->MeSH_ID_serializer_->_reset ();

    if (this->DrugBank_ID_serializer_)
      this->DrugBank_ID_serializer_->_reset ();

    if (this->GMO_ID_serializer_)
      this->GMO_ID_serializer_->_reset ();

    if (this->GO_ID_serializer_)
      this->GO_ID_serializer_->_reset ();

    if (this->UniProt_ID_serializer_)
      this->UniProt_ID_serializer_->_reset ();

    if (this->PR_ID_serializer_)
      this->PR_ID_serializer_->_reset ();

    this->resetting_ = true;

    if (this->export_rate_serializer_)
      this->export_rate_serializer_->_reset ();

    if (this->export_rate_serializer_map_)
      this->export_rate_serializer_map_->reset ();

    if (this->export_rate_per_unit_surface_area_serializer_)
      this->export_rate_per_unit_surface_area_serializer_->_reset ();

    if (this->export_rate_per_unit_surface_area_serializer_map_)
      this->export_rate_per_unit_surface_area_serializer_map_->reset ();

    if (this->import_rate_serializer_)
      this->import_rate_serializer_->_reset ();

    if (this->import_rate_serializer_map_)
      this->import_rate_serializer_map_->reset ();

    if (this->import_rate_per_unit_surface_area_serializer_)
      this->import_rate_per_unit_surface_area_serializer_->_reset ();

    if (this->import_rate_per_unit_surface_area_serializer_map_)
      this->import_rate_per_unit_surface_area_serializer_map_->reset ();

    if (this->saturation_density_serializer_)
      this->saturation_density_serializer_->_reset ();

    if (this->saturation_density_serializer_map_)
      this->saturation_density_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* transport_variable_sskel::
  _static_type ()
  {
    return "transport_variable phenotype_common";
  }

  const char* transport_variable_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // geometrical_parameters_sskel
  //

  bool geometrical_parameters_sskel::
  units_present ()
  {
    return this->geometrical_parameters_impl_ ? this->geometrical_parameters_impl_->units_present () : false;
  }

  bool geometrical_parameters_sskel::
  aspect_ratio_present ()
  {
    return this->geometrical_parameters_impl_ ? this->geometrical_parameters_impl_->aspect_ratio_present () : false;
  }

  bool geometrical_parameters_sskel::
  circularity_present ()
  {
    return this->geometrical_parameters_impl_ ? this->geometrical_parameters_impl_->circularity_present () : false;
  }

  bool geometrical_parameters_sskel::
  eccentricity_present ()
  {
    return this->geometrical_parameters_impl_ ? this->geometrical_parameters_impl_->eccentricity_present () : false;
  }

  bool geometrical_parameters_sskel::
  sphericity_present ()
  {
    return this->geometrical_parameters_impl_ ? this->geometrical_parameters_impl_->sphericity_present () : false;
  }

  bool geometrical_parameters_sskel::
  custom_present ()
  {
    return this->geometrical_parameters_impl_ ? this->geometrical_parameters_impl_->custom_present () : false;
  }

  void geometrical_parameters_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    if (this->units_serializer_)
      this->units_serializer_->_reset ();

    this->resetting_ = true;

    if (this->aspect_ratio_serializer_)
      this->aspect_ratio_serializer_->_reset ();

    if (this->aspect_ratio_serializer_map_)
      this->aspect_ratio_serializer_map_->reset ();

    if (this->circularity_serializer_)
      this->circularity_serializer_->_reset ();

    if (this->circularity_serializer_map_)
      this->circularity_serializer_map_->reset ();

    if (this->eccentricity_serializer_)
      this->eccentricity_serializer_->_reset ();

    if (this->eccentricity_serializer_map_)
      this->eccentricity_serializer_map_->reset ();

    if (this->sphericity_serializer_)
      this->sphericity_serializer_->_reset ();

    if (this->sphericity_serializer_map_)
      this->sphericity_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* geometrical_parameters_sskel::
  _static_type ()
  {
    return "geometrical_parameters phenotype_common";
  }

  const char* geometrical_parameters_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // lengths_sskel
  //

  bool lengths_sskel::
  units_present ()
  {
    return this->lengths_impl_ ? this->lengths_impl_->units_present () : false;
  }

  bool lengths_sskel::
  diameter_present ()
  {
    return this->lengths_impl_ ? this->lengths_impl_->diameter_present () : false;
  }

  bool lengths_sskel::
  major_axis_present ()
  {
    return this->lengths_impl_ ? this->lengths_impl_->major_axis_present () : false;
  }

  bool lengths_sskel::
  minor_axis_present ()
  {
    return this->lengths_impl_ ? this->lengths_impl_->minor_axis_present () : false;
  }

  bool lengths_sskel::
  perimeter_present ()
  {
    return this->lengths_impl_ ? this->lengths_impl_->perimeter_present () : false;
  }

  bool lengths_sskel::
  radius_present ()
  {
    return this->lengths_impl_ ? this->lengths_impl_->radius_present () : false;
  }

  bool lengths_sskel::
  custom_present ()
  {
    return this->lengths_impl_ ? this->lengths_impl_->custom_present () : false;
  }

  void lengths_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    if (this->units_serializer_)
      this->units_serializer_->_reset ();

    this->resetting_ = true;

    if (this->diameter_serializer_)
      this->diameter_serializer_->_reset ();

    if (this->diameter_serializer_map_)
      this->diameter_serializer_map_->reset ();

    if (this->major_axis_serializer_)
      this->major_axis_serializer_->_reset ();

    if (this->major_axis_serializer_map_)
      this->major_axis_serializer_map_->reset ();

    if (this->minor_axis_serializer_)
      this->minor_axis_serializer_->_reset ();

    if (this->minor_axis_serializer_map_)
      this->minor_axis_serializer_map_->reset ();

    if (this->perimeter_serializer_)
      this->perimeter_serializer_->_reset ();

    if (this->perimeter_serializer_map_)
      this->perimeter_serializer_map_->reset ();

    if (this->radius_serializer_)
      this->radius_serializer_->_reset ();

    if (this->radius_serializer_map_)
      this->radius_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* lengths_sskel::
  _static_type ()
  {
    return "lengths phenotype_common";
  }

  const char* lengths_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // areas_3D_sskel
  //

  bool areas_3D_sskel::
  units_present ()
  {
    return this->areas_3D_impl_ ? this->areas_3D_impl_->units_present () : false;
  }

  bool areas_3D_sskel::
  free_surface_area_present ()
  {
    return this->areas_3D_impl_ ? this->areas_3D_impl_->free_surface_area_present () : false;
  }

  bool areas_3D_sskel::
  total_surface_area_present ()
  {
    return this->areas_3D_impl_ ? this->areas_3D_impl_->total_surface_area_present () : false;
  }

  bool areas_3D_sskel::
  custom_present ()
  {
    return this->areas_3D_impl_ ? this->areas_3D_impl_->custom_present () : false;
  }

  void areas_3D_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    if (this->units_serializer_)
      this->units_serializer_->_reset ();

    this->resetting_ = true;

    if (this->free_surface_area_serializer_)
      this->free_surface_area_serializer_->_reset ();

    if (this->free_surface_area_serializer_map_)
      this->free_surface_area_serializer_map_->reset ();

    if (this->total_surface_area_serializer_)
      this->total_surface_area_serializer_->_reset ();

    if (this->total_surface_area_serializer_map_)
      this->total_surface_area_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* areas_3D_sskel::
  _static_type ()
  {
    return "areas_3D phenotype_common";
  }

  const char* areas_3D_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // areas_2D_sskel
  //

  bool areas_2D_sskel::
  units_present ()
  {
    return this->areas_2D_impl_ ? this->areas_2D_impl_->units_present () : false;
  }

  bool areas_2D_sskel::
  total_area_present ()
  {
    return this->areas_2D_impl_ ? this->areas_2D_impl_->total_area_present () : false;
  }

  bool areas_2D_sskel::
  custom_present ()
  {
    return this->areas_2D_impl_ ? this->areas_2D_impl_->custom_present () : false;
  }

  void areas_2D_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    if (this->units_serializer_)
      this->units_serializer_->_reset ();

    this->resetting_ = true;

    if (this->total_area_serializer_)
      this->total_area_serializer_->_reset ();

    if (this->total_area_serializer_map_)
      this->total_area_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* areas_2D_sskel::
  _static_type ()
  {
    return "areas_2D phenotype_common";
  }

  const char* areas_2D_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // volumes_sskel
  //

  bool volumes_sskel::
  units_present ()
  {
    return this->volumes_impl_ ? this->volumes_impl_->units_present () : false;
  }

  bool volumes_sskel::
  fluid_volume_present ()
  {
    return this->volumes_impl_ ? this->volumes_impl_->fluid_volume_present () : false;
  }

  bool volumes_sskel::
  fluid_volume_fraction_present ()
  {
    return this->volumes_impl_ ? this->volumes_impl_->fluid_volume_fraction_present () : false;
  }

  bool volumes_sskel::
  solid_calcified_volume_present ()
  {
    return this->volumes_impl_ ? this->volumes_impl_->solid_calcified_volume_present () : false;
  }

  bool volumes_sskel::
  solid_volume_present ()
  {
    return this->volumes_impl_ ? this->volumes_impl_->solid_volume_present () : false;
  }

  bool volumes_sskel::
  solid_volume_fraction_present ()
  {
    return this->volumes_impl_ ? this->volumes_impl_->solid_volume_fraction_present () : false;
  }

  bool volumes_sskel::
  total_volume_present ()
  {
    return this->volumes_impl_ ? this->volumes_impl_->total_volume_present () : false;
  }

  bool volumes_sskel::
  custom_present ()
  {
    return this->volumes_impl_ ? this->volumes_impl_->custom_present () : false;
  }

  void volumes_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    if (this->units_serializer_)
      this->units_serializer_->_reset ();

    this->resetting_ = true;

    if (this->fluid_volume_serializer_)
      this->fluid_volume_serializer_->_reset ();

    if (this->fluid_volume_serializer_map_)
      this->fluid_volume_serializer_map_->reset ();

    if (this->fluid_volume_fraction_serializer_)
      this->fluid_volume_fraction_serializer_->_reset ();

    if (this->fluid_volume_fraction_serializer_map_)
      this->fluid_volume_fraction_serializer_map_->reset ();

    if (this->solid_calcified_volume_serializer_)
      this->solid_calcified_volume_serializer_->_reset ();

    if (this->solid_calcified_volume_serializer_map_)
      this->solid_calcified_volume_serializer_map_->reset ();

    if (this->solid_volume_serializer_)
      this->solid_volume_serializer_->_reset ();

    if (this->solid_volume_serializer_map_)
      this->solid_volume_serializer_map_->reset ();

    if (this->solid_volume_fraction_serializer_)
      this->solid_volume_fraction_serializer_->_reset ();

    if (this->solid_volume_fraction_serializer_map_)
      this->solid_volume_fraction_serializer_map_->reset ();

    if (this->total_volume_serializer_)
      this->total_volume_serializer_->_reset ();

    if (this->total_volume_serializer_map_)
      this->total_volume_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* volumes_sskel::
  _static_type ()
  {
    return "volumes phenotype_common";
  }

  const char* volumes_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // geometrical_properties_sskel
  //

  bool geometrical_properties_sskel::
  parameters_present ()
  {
    return this->geometrical_properties_impl_ ? this->geometrical_properties_impl_->parameters_present () : false;
  }

  bool geometrical_properties_sskel::
  lengths_present ()
  {
    return this->geometrical_properties_impl_ ? this->geometrical_properties_impl_->lengths_present () : false;
  }

  bool geometrical_properties_sskel::
  areas_present ()
  {
    return this->geometrical_properties_impl_ ? this->geometrical_properties_impl_->areas_present () : false;
  }

  bool geometrical_properties_sskel::
  volumes_present ()
  {
    return this->geometrical_properties_impl_ ? this->geometrical_properties_impl_->volumes_present () : false;
  }

  bool geometrical_properties_sskel::
  cross_section_next ()
  {
    return this->geometrical_properties_impl_ ? this->geometrical_properties_impl_->cross_section_next () : false;
  }

  bool geometrical_properties_sskel::
  custom_present ()
  {
    return this->geometrical_properties_impl_ ? this->geometrical_properties_impl_->custom_present () : false;
  }

  void geometrical_properties_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->parameters_serializer_)
      this->parameters_serializer_->_reset ();

    if (this->parameters_serializer_map_)
      this->parameters_serializer_map_->reset ();

    if (this->lengths_serializer_)
      this->lengths_serializer_->_reset ();

    if (this->lengths_serializer_map_)
      this->lengths_serializer_map_->reset ();

    if (this->areas_serializer_)
      this->areas_serializer_->_reset ();

    if (this->areas_serializer_map_)
      this->areas_serializer_map_->reset ();

    if (this->volumes_serializer_)
      this->volumes_serializer_->_reset ();

    if (this->volumes_serializer_map_)
      this->volumes_serializer_map_->reset ();

    if (this->cross_section_serializer_)
      this->cross_section_serializer_->_reset ();

    if (this->cross_section_serializer_map_)
      this->cross_section_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* geometrical_properties_sskel::
  _static_type ()
  {
    return "geometrical_properties phenotype_common";
  }

  const char* geometrical_properties_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // cross_section_sskel
  //

  bool cross_section_sskel::
  parameters_present ()
  {
    return this->cross_section_impl_ ? this->cross_section_impl_->parameters_present () : false;
  }

  bool cross_section_sskel::
  lengths_present ()
  {
    return this->cross_section_impl_ ? this->cross_section_impl_->lengths_present () : false;
  }

  bool cross_section_sskel::
  areas_present ()
  {
    return this->cross_section_impl_ ? this->cross_section_impl_->areas_present () : false;
  }

  bool cross_section_sskel::
  custom_present ()
  {
    return this->cross_section_impl_ ? this->cross_section_impl_->custom_present () : false;
  }

  void cross_section_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->parameters_serializer_)
      this->parameters_serializer_->_reset ();

    if (this->parameters_serializer_map_)
      this->parameters_serializer_map_->reset ();

    if (this->lengths_serializer_)
      this->lengths_serializer_->_reset ();

    if (this->lengths_serializer_map_)
      this->lengths_serializer_map_->reset ();

    if (this->areas_serializer_)
      this->areas_serializer_->_reset ();

    if (this->areas_serializer_map_)
      this->areas_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* cross_section_sskel::
  _static_type ()
  {
    return "cross_section phenotype_common";
  }

  const char* cross_section_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // mass_sskel
  //

  bool mass_sskel::
  biomass_present ()
  {
    return this->mass_impl_ ? this->mass_impl_->biomass_present () : false;
  }

  bool mass_sskel::
  fluid_mass_present ()
  {
    return this->mass_impl_ ? this->mass_impl_->fluid_mass_present () : false;
  }

  bool mass_sskel::
  total_mass_present ()
  {
    return this->mass_impl_ ? this->mass_impl_->total_mass_present () : false;
  }

  void mass_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->biomass_serializer_)
      this->biomass_serializer_->_reset ();

    if (this->biomass_serializer_map_)
      this->biomass_serializer_map_->reset ();

    if (this->fluid_mass_serializer_)
      this->fluid_mass_serializer_->_reset ();

    if (this->fluid_mass_serializer_map_)
      this->fluid_mass_serializer_map_->reset ();

    if (this->total_mass_serializer_)
      this->total_mass_serializer_->_reset ();

    if (this->total_mass_serializer_map_)
      this->total_mass_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* mass_sskel::
  _static_type ()
  {
    return "mass phenotype_common";
  }

  const char* mass_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }
}

namespace phenotype_common
{
  // Element validation and serialization for adhesion_sskel.
  //
  void adhesion_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // adhesion_bond_breaking_rate
    //
    if (this->adhesion_bond_breaking_rate_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->adhesion_bond_breaking_rate ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->adhesion_bond_breaking_rate_serializer_ != 0)
        s = this->adhesion_bond_breaking_rate_serializer_;
      else if (this->adhesion_bond_breaking_rate_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->adhesion_bond_breaking_rate_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("adhesion_bond_breaking_rate");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // adhesion_bond_formation_rate
    //
    if (this->adhesion_bond_formation_rate_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->adhesion_bond_formation_rate ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->adhesion_bond_formation_rate_serializer_ != 0)
        s = this->adhesion_bond_formation_rate_serializer_;
      else if (this->adhesion_bond_formation_rate_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->adhesion_bond_formation_rate_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("adhesion_bond_formation_rate");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // adhesion_spring_constant
    //
    if (this->adhesion_spring_constant_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->adhesion_spring_constant ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->adhesion_spring_constant_serializer_ != 0)
        s = this->adhesion_spring_constant_serializer_;
      else if (this->adhesion_spring_constant_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->adhesion_spring_constant_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("adhesion_spring_constant");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // adhesion_receptor_density
    //
    if (this->adhesion_receptor_density_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->adhesion_receptor_density ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->adhesion_receptor_density_serializer_ != 0)
        s = this->adhesion_receptor_density_serializer_;
      else if (this->adhesion_receptor_density_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->adhesion_receptor_density_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("adhesion_receptor_density");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // surface_binding_energy
    //
    if (this->surface_binding_energy_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->surface_binding_energy ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->surface_binding_energy_serializer_ != 0)
        s = this->surface_binding_energy_serializer_;
      else if (this->surface_binding_energy_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->surface_binding_energy_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("surface_binding_energy");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // number_of_adhered_cells
    //
    if (this->number_of_adhered_cells_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->number_of_adhered_cells ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->number_of_adhered_cells_serializer_ != 0)
        s = this->number_of_adhered_cells_serializer_;
      else if (this->number_of_adhered_cells_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->number_of_adhered_cells_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("number_of_adhered_cells");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // maximum_number_of_adhered_cells
    //
    if (this->maximum_number_of_adhered_cells_present ())
    {
      ctx.type_id (0);
      const ::common::units_unsignedShort& r = this->maximum_number_of_adhered_cells ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_unsignedShort_sskel* s = 0;

      if (t == 0 && this->maximum_number_of_adhered_cells_serializer_ != 0)
        s = this->maximum_number_of_adhered_cells_serializer_;
      else if (this->maximum_number_of_adhered_cells_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->maximum_number_of_adhered_cells_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_unsignedShort_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_unsignedShort_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("maximum_number_of_adhered_cells");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // adhered_surface_area
    //
    if (this->adhered_surface_area_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->adhered_surface_area ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->adhered_surface_area_serializer_ != 0)
        s = this->adhered_surface_area_serializer_;
      else if (this->adhered_surface_area_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->adhered_surface_area_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("adhered_surface_area");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // maximum_adhered_surface_area
    //
    if (this->maximum_adhered_surface_area_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->maximum_adhered_surface_area ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->maximum_adhered_surface_area_serializer_ != 0)
        s = this->maximum_adhered_surface_area_serializer_;
      else if (this->maximum_adhered_surface_area_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->maximum_adhered_surface_area_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("maximum_adhered_surface_area");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // adhesion_force_per_surface_area
    //
    if (this->adhesion_force_per_surface_area_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->adhesion_force_per_surface_area ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->adhesion_force_per_surface_area_serializer_ != 0)
        s = this->adhesion_force_per_surface_area_serializer_;
      else if (this->adhesion_force_per_surface_area_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->adhesion_force_per_surface_area_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("adhesion_force_per_surface_area");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // adhesion_probability
    //
    if (this->adhesion_probability_present ())
    {
      ctx.type_id (0);
      const ::common::units_fraction& r = this->adhesion_probability ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_fraction_sskel* s = 0;

      if (t == 0 && this->adhesion_probability_serializer_ != 0)
        s = this->adhesion_probability_serializer_;
      else if (this->adhesion_probability_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->adhesion_probability_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_fraction_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_fraction_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("adhesion_probability");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // detachment_proability
    //
    if (this->detachment_proability_present ())
    {
      ctx.type_id (0);
      const ::common::units_fraction& r = this->detachment_proability ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_fraction_sskel* s = 0;

      if (t == 0 && this->detachment_proability_serializer_ != 0)
        s = this->detachment_proability_serializer_;
      else if (this->detachment_proability_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->detachment_proability_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_fraction_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_fraction_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("detachment_proability");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // rolling_observation
    //
    while (this->rolling_observation_next ())
    {
      ctx.type_id (0);
      const ::phenotype_common::rolling_observation& r = this->rolling_observation ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::phenotype_common::rolling_observation_sskel* s = 0;

      if (t == 0 && this->rolling_observation_serializer_ != 0)
        s = this->rolling_observation_serializer_;
      else if (this->rolling_observation_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->rolling_observation_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::phenotype_common::rolling_observation_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::phenotype_common::rolling_observation_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("rolling_observation");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for rolling_observation_sskel.
  //
  void rolling_observation_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // rolling_velocity
    //
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->rolling_velocity ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->rolling_velocity_serializer_ != 0)
        s = this->rolling_velocity_serializer_;
      else if (this->rolling_velocity_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->rolling_velocity_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("rolling_velocity");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    // shear_stress
    //
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->shear_stress ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->shear_stress_serializer_ != 0)
        s = this->shear_stress_serializer_;
      else if (this->shear_stress_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->shear_stress_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("shear_stress");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }
  }

  // Element validation and serialization for friction_sskel.
  //
  void friction_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // compression
    //
    if (this->compression_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->compression ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->compression_serializer_ != 0)
        s = this->compression_serializer_;
      else if (this->compression_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->compression_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("compression");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // ECM
    //
    if (this->ECM_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->ECM ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->ECM_serializer_ != 0)
        s = this->ECM_serializer_;
      else if (this->ECM_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->ECM_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("ECM");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // shear
    //
    if (this->shear_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->shear ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->shear_serializer_ != 0)
        s = this->shear_serializer_;
      else if (this->shear_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->shear_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("shear");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for mechanics_sskel.
  //
  void mechanics_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // friction
    //
    if (this->friction_present ())
    {
      ctx.type_id (0);
      const ::phenotype_common::friction& r = this->friction ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::phenotype_common::friction_sskel* s = 0;

      if (t == 0 && this->friction_serializer_ != 0)
        s = this->friction_serializer_;
      else if (this->friction_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->friction_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::phenotype_common::friction_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::phenotype_common::friction_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("friction");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // maximum_cell_deformation
    //
    if (this->maximum_cell_deformation_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->maximum_cell_deformation ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->maximum_cell_deformation_serializer_ != 0)
        s = this->maximum_cell_deformation_serializer_;
      else if (this->maximum_cell_deformation_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->maximum_cell_deformation_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("maximum_cell_deformation");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // mechanical_pressure
    //
    if (this->mechanical_pressure_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->mechanical_pressure ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->mechanical_pressure_serializer_ != 0)
        s = this->mechanical_pressure_serializer_;
      else if (this->mechanical_pressure_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->mechanical_pressure_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("mechanical_pressure");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // indentation_observation
    //
    while (this->indentation_observation_next ())
    {
      ctx.type_id (0);
      const ::phenotype_common::indentation_observation& r = this->indentation_observation ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::phenotype_common::indentation_observation_sskel* s = 0;

      if (t == 0 && this->indentation_observation_serializer_ != 0)
        s = this->indentation_observation_serializer_;
      else if (this->indentation_observation_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->indentation_observation_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::phenotype_common::indentation_observation_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::phenotype_common::indentation_observation_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("indentation_observation");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // poisson_ratio
    //
    if (this->poisson_ratio_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->poisson_ratio ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->poisson_ratio_serializer_ != 0)
        s = this->poisson_ratio_serializer_;
      else if (this->poisson_ratio_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->poisson_ratio_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("poisson_ratio");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // youngs_modulus
    //
    if (this->youngs_modulus_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->youngs_modulus ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->youngs_modulus_serializer_ != 0)
        s = this->youngs_modulus_serializer_;
      else if (this->youngs_modulus_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->youngs_modulus_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("youngs_modulus");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for indentation_observation_sskel.
  //
  void indentation_observation_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // depth
    //
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->depth ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->depth_serializer_ != 0)
        s = this->depth_serializer_;
      else if (this->depth_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->depth_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("depth");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    // poisson_ratio
    //
    if (this->poisson_ratio_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->poisson_ratio ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->poisson_ratio_serializer_ != 0)
        s = this->poisson_ratio_serializer_;
      else if (this->poisson_ratio_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->poisson_ratio_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("poisson_ratio");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // youngs_modulus
    //
    if (this->youngs_modulus_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->youngs_modulus ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->youngs_modulus_serializer_ != 0)
        s = this->youngs_modulus_serializer_;
      else if (this->youngs_modulus_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->youngs_modulus_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("youngs_modulus");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for motility_sskel.
  //
  void motility_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // unrestricted
    //
    while (this->unrestricted_next ())
    {
      ctx.type_id (0);
      const ::phenotype_common::motility_types& r = this->unrestricted ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::phenotype_common::motility_types_sskel* s = 0;

      if (t == 0 && this->unrestricted_serializer_ != 0)
        s = this->unrestricted_serializer_;
      else if (this->unrestricted_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->unrestricted_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::phenotype_common::motility_types_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::phenotype_common::motility_types_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("unrestricted");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // restricted
    //
    while (this->restricted_next ())
    {
      ctx.type_id (0);
      const ::phenotype_common::motility_types& r = this->restricted ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::phenotype_common::motility_types_sskel* s = 0;

      if (t == 0 && this->restricted_serializer_ != 0)
        s = this->restricted_serializer_;
      else if (this->restricted_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->restricted_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::phenotype_common::motility_types_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::phenotype_common::motility_types_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("restricted");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for motility_types_sskel.
  //
  void motility_types_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // timescale
    //
    if (this->timescale_present ())
    {
      ctx.type_id (0);
      const ::phenotype_common::timescale& r = this->timescale ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::phenotype_common::timescale_sskel* s = 0;

      if (t == 0 && this->timescale_serializer_ != 0)
        s = this->timescale_serializer_;
      else if (this->timescale_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->timescale_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::phenotype_common::timescale_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::phenotype_common::timescale_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("timescale");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // restriction
    //
    if (this->restriction_present ())
    {
      ctx.type_id (0);
      const ::variables::experimental_conditions& r = this->restriction ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::variables::experimental_conditions_sskel* s = 0;

      if (t == 0 && this->restriction_serializer_ != 0)
        s = this->restriction_serializer_;
      else if (this->restriction_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->restriction_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::variables::experimental_conditions_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::variables::experimental_conditions_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("restriction");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // net_displacement
    //
    if (this->net_displacement_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->net_displacement ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->net_displacement_serializer_ != 0)
        s = this->net_displacement_serializer_;
      else if (this->net_displacement_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->net_displacement_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("net_displacement");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // total_displacement
    //
    if (this->total_displacement_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->total_displacement ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->total_displacement_serializer_ != 0)
        s = this->total_displacement_serializer_;
      else if (this->total_displacement_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->total_displacement_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("total_displacement");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // mean_square_displacement
    //
    if (this->mean_square_displacement_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->mean_square_displacement ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->mean_square_displacement_serializer_ != 0)
        s = this->mean_square_displacement_serializer_;
      else if (this->mean_square_displacement_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->mean_square_displacement_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("mean_square_displacement");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // mean_speed
    //
    if (this->mean_speed_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->mean_speed ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->mean_speed_serializer_ != 0)
        s = this->mean_speed_serializer_;
      else if (this->mean_speed_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->mean_speed_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("mean_speed");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // net_speed
    //
    if (this->net_speed_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->net_speed ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->net_speed_serializer_ != 0)
        s = this->net_speed_serializer_;
      else if (this->net_speed_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->net_speed_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("net_speed");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // persistence
    //
    if (this->persistence_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->persistence ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->persistence_serializer_ != 0)
        s = this->persistence_serializer_;
      else if (this->persistence_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->persistence_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("persistence");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // mean_path_length
    //
    if (this->mean_path_length_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->mean_path_length ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->mean_path_length_serializer_ != 0)
        s = this->mean_path_length_serializer_;
      else if (this->mean_path_length_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->mean_path_length_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("mean_path_length");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // diffusion_coefficient
    //
    if (this->diffusion_coefficient_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal& r = this->diffusion_coefficient ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_sskel* s = 0;

      if (t == 0 && this->diffusion_coefficient_serializer_ != 0)
        s = this->diffusion_coefficient_serializer_;
      else if (this->diffusion_coefficient_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->diffusion_coefficient_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("diffusion_coefficient");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for transport_processes_sskel.
  //
  void transport_processes_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // variable
    //
    {
      size_t i = 0;
      for (; this->variable_next (); ++i)
      {
        ctx.type_id (0);
        const ::phenotype_common::transport_variable& r = this->variable ();

        const void* t = ctx.type_id ();
        const char* dt = 0;
        ::phenotype_common::transport_variable_sskel* s = 0;

        if (t == 0 && this->variable_serializer_ != 0)
          s = this->variable_serializer_;
        else if (this->variable_serializer_map_ != 0)
        {
          ::xml_schema::serializer_base* b = this->variable_serializer_map_->find (t);

          if (b != 0)
          {
            dt = b->_dynamic_type ();
            const char* st = ::phenotype_common::transport_variable_sskel::_static_type ();

            if (strcmp (dt, st) == 0)
              dt = 0;

            if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
            {
              ctx.schema_error (::xsde::cxx::schema_error::not_derived);
              return;
            }

            s = static_cast< ::phenotype_common::transport_variable_sskel* > (b);
          }
        }

        if (s)
        {
          s->pre (r);
          this->_start_element ("variable");
          if (dt != 0)
            this->_set_type (dt);

          s->_pre_impl (ctx);

          if (ctx.error_type ())
            return;

          s->_serialize_attributes ();

          if (ctx.error_type ())
            return;

          s->_serialize_content ();

          if (ctx.error_type ())
            return;

          s->_post_impl ();

          if (ctx.error_type ())
            return;

          this->_end_element ();
          s->post ();
        }
        else
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return;
        }
      }

      if (i < 1UL)
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }
  }

  // Element validation and serialization for transport_variable_sskel.
  //
  void transport_variable_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    if (this->all_present ())
    {
      // export_rate
      //
      if (this->export_rate_present ())
      {
        ctx.type_id (0);
        const ::common::units_decimal& r = this->export_rate ();

        const void* t = ctx.type_id ();
        const char* dt = 0;
        ::common::units_decimal_sskel* s = 0;

        if (t == 0 && this->export_rate_serializer_ != 0)
          s = this->export_rate_serializer_;
        else if (this->export_rate_serializer_map_ != 0)
        {
          ::xml_schema::serializer_base* b = this->export_rate_serializer_map_->find (t);

          if (b != 0)
          {
            dt = b->_dynamic_type ();
            const char* st = ::common::units_decimal_sskel::_static_type ();

            if (strcmp (dt, st) == 0)
              dt = 0;

            if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
            {
              ctx.schema_error (::xsde::cxx::schema_error::not_derived);
              return;
            }

            s = static_cast< ::common::units_decimal_sskel* > (b);
          }
        }

        if (s)
        {
          s->pre (r);
          this->_start_element ("export_rate");
          if (dt != 0)
            this->_set_type (dt);

          s->_pre_impl (ctx);

          if (ctx.error_type ())
            return;

          s->_serialize_attributes ();

          if (ctx.error_type ())
            return;

          s->_serialize_content ();

          if (ctx.error_type ())
            return;

          s->_post_impl ();

          if (ctx.error_type ())
            return;

          this->_end_element ();
          s->post ();
        }
      }

      // export_rate_per_unit_surface_area
      //
      if (this->export_rate_per_unit_surface_area_present ())
      {
        ctx.type_id (0);
        const ::common::units_decimal& r = this->export_rate_per_unit_surface_area ();

        const void* t = ctx.type_id ();
        const char* dt = 0;
        ::common::units_decimal_sskel* s = 0;

        if (t == 0 && this->export_rate_per_unit_surface_area_serializer_ != 0)
          s = this->export_rate_per_unit_surface_area_serializer_;
        else if (this->export_rate_per_unit_surface_area_serializer_map_ != 0)
        {
          ::xml_schema::serializer_base* b = this->export_rate_per_unit_surface_area_serializer_map_->find (t);

          if (b != 0)
          {
            dt = b->_dynamic_type ();
            const char* st = ::common::units_decimal_sskel::_static_type ();

            if (strcmp (dt, st) == 0)
              dt = 0;

            if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
            {
              ctx.schema_error (::xsde::cxx::schema_error::not_derived);
              return;
            }

            s = static_cast< ::common::units_decimal_sskel* > (b);
          }
        }

        if (s)
        {
          s->pre (r);
          this->_start_element ("export_rate_per_unit_surface_area");
          if (dt != 0)
            this->_set_type (dt);

          s->_pre_impl (ctx);

          if (ctx.error_type ())
            return;

          s->_serialize_attributes ();

          if (ctx.error_type ())
            return;

          s->_serialize_content ();

          if (ctx.error_type ())
            return;

          s->_post_impl ();

          if (ctx.error_type ())
            return;

          this->_end_element ();
          s->post ();
        }
      }

      // import_rate
      //
      if (this->import_rate_present ())
      {
        ctx.type_id (0);
        const ::common::units_decimal& r = this->import_rate ();

        const void* t = ctx.type_id ();
        const char* dt = 0;
        ::common::units_decimal_sskel* s = 0;

        if (t == 0 && this->import_rate_serializer_ != 0)
          s = this->import_rate_serializer_;
        else if (this->import_rate_serializer_map_ != 0)
        {
          ::xml_schema::serializer_base* b = this->import_rate_serializer_map_->find (t);

          if (b != 0)
          {
            dt = b->_dynamic_type ();
            const char* st = ::common::units_decimal_sskel::_static_type ();

            if (strcmp (dt, st) == 0)
              dt = 0;

            if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
            {
              ctx.schema_error (::xsde::cxx::schema_error::not_derived);
              return;
            }

            s = static_cast< ::common::units_decimal_sskel* > (b);
          }
        }

        if (s)
        {
          s->pre (r);
          this->_start_element ("import_rate");
          if (dt != 0)
            this->_set_type (dt);

          s->_pre_impl (ctx);

          if (ctx.error_type ())
            return;

          s->_serialize_attributes ();

          if (ctx.error_type ())
            return;

          s->_serialize_content ();

          if (ctx.error_type ())
            return;

          s->_post_impl ();

          if (ctx.error_type ())
            return;

          this->_end_element ();
          s->post ();
        }
      }

      // import_rate_per_unit_surface_area
      //
      if (this->import_rate_per_unit_surface_area_present ())
      {
        ctx.type_id (0);
        const ::common::units_decimal& r = this->import_rate_per_unit_surface_area ();

        const void* t = ctx.type_id ();
        const char* dt = 0;
        ::common::units_decimal_sskel* s = 0;

        if (t == 0 && this->import_rate_per_unit_surface_area_serializer_ != 0)
          s = this->import_rate_per_unit_surface_area_serializer_;
        else if (this->import_rate_per_unit_surface_area_serializer_map_ != 0)
        {
          ::xml_schema::serializer_base* b = this->import_rate_per_unit_surface_area_serializer_map_->find (t);

          if (b != 0)
          {
            dt = b->_dynamic_type ();
            const char* st = ::common::units_decimal_sskel::_static_type ();

            if (strcmp (dt, st) == 0)
              dt = 0;

            if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
            {
              ctx.schema_error (::xsde::cxx::schema_error::not_derived);
              return;
            }

            s = static_cast< ::common::units_decimal_sskel* > (b);
          }
        }

        if (s)
        {
          s->pre (r);
          this->_start_element ("import_rate_per_unit_surface_area");
          if (dt != 0)
            this->_set_type (dt);

          s->_pre_impl (ctx);

          if (ctx.error_type ())
            return;

          s->_serialize_attributes ();

          if (ctx.error_type ())
            return;

          s->_serialize_content ();

          if (ctx.error_type ())
            return;

          s->_post_impl ();

          if (ctx.error_type ())
            return;

          this->_end_element ();
          s->post ();
        }
      }

      // saturation_density
      //
      if (this->saturation_density_present ())
      {
        ctx.type_id (0);
        const ::common::units_decimal& r = this->saturation_density ();

        const void* t = ctx.type_id ();
        const char* dt = 0;
        ::common::units_decimal_sskel* s = 0;

        if (t == 0 && this->saturation_density_serializer_ != 0)
          s = this->saturation_density_serializer_;
        else if (this->saturation_density_serializer_map_ != 0)
        {
          ::xml_schema::serializer_base* b = this->saturation_density_serializer_map_->find (t);

          if (b != 0)
          {
            dt = b->_dynamic_type ();
            const char* st = ::common::units_decimal_sskel::_static_type ();

            if (strcmp (dt, st) == 0)
              dt = 0;

            if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
            {
              ctx.schema_error (::xsde::cxx::schema_error::not_derived);
              return;
            }

            s = static_cast< ::common::units_decimal_sskel* > (b);
          }
        }

        if (s)
        {
          s->pre (r);
          this->_start_element ("saturation_density");
          if (dt != 0)
            this->_set_type (dt);

          s->_pre_impl (ctx);

          if (ctx.error_type ())
            return;

          s->_serialize_attributes ();

          if (ctx.error_type ())
            return;

          s->_serialize_content ();

          if (ctx.error_type ())
            return;

          s->_post_impl ();

          if (ctx.error_type ())
            return;

          this->_end_element ();
          s->post ();
        }
      }

      // custom
      //
      if (this->custom_present ())
      {
        ctx.type_id (0);
        const ::common::custom& r = this->custom ();

        const void* t = ctx.type_id ();
        const char* dt = 0;
        ::common::custom_sskel* s = 0;

        if (t == 0 && this->custom_serializer_ != 0)
          s = this->custom_serializer_;
        else if (this->custom_serializer_map_ != 0)
        {
          ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

          if (b != 0)
          {
            dt = b->_dynamic_type ();
            const char* st = ::common::custom_sskel::_static_type ();

            if (strcmp (dt, st) == 0)
              dt = 0;

            if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
            {
              ctx.schema_error (::xsde::cxx::schema_error::not_derived);
              return;
            }

            s = static_cast< ::common::custom_sskel* > (b);
          }
        }

        if (s)
        {
          s->pre (r);
          this->_start_element ("custom");
          if (dt != 0)
            this->_set_type (dt);

          s->_pre_impl (ctx);

          if (ctx.error_type ())
            return;

          s->_serialize_attributes ();

          if (ctx.error_type ())
            return;

          s->_serialize_content ();

          if (ctx.error_type ())
            return;

          s->_post_impl ();

          if (ctx.error_type ())
            return;

          this->_end_element ();
          s->post ();
        }
      }
    }
  }

  // Element validation and serialization for geometrical_parameters_sskel.
  //
  void geometrical_parameters_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // aspect_ratio
    //
    if (this->aspect_ratio_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->aspect_ratio ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->aspect_ratio_serializer_ != 0)
        s = this->aspect_ratio_serializer_;
      else if (this->aspect_ratio_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->aspect_ratio_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("aspect_ratio");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // circularity
    //
    if (this->circularity_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->circularity ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->circularity_serializer_ != 0)
        s = this->circularity_serializer_;
      else if (this->circularity_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->circularity_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("circularity");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // eccentricity
    //
    if (this->eccentricity_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->eccentricity ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->eccentricity_serializer_ != 0)
        s = this->eccentricity_serializer_;
      else if (this->eccentricity_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->eccentricity_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("eccentricity");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // sphericity
    //
    if (this->sphericity_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->sphericity ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->sphericity_serializer_ != 0)
        s = this->sphericity_serializer_;
      else if (this->sphericity_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->sphericity_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("sphericity");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for lengths_sskel.
  //
  void lengths_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // diameter
    //
    if (this->diameter_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->diameter ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->diameter_serializer_ != 0)
        s = this->diameter_serializer_;
      else if (this->diameter_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->diameter_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("diameter");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // major_axis
    //
    if (this->major_axis_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->major_axis ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->major_axis_serializer_ != 0)
        s = this->major_axis_serializer_;
      else if (this->major_axis_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->major_axis_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("major_axis");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // minor_axis
    //
    if (this->minor_axis_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->minor_axis ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->minor_axis_serializer_ != 0)
        s = this->minor_axis_serializer_;
      else if (this->minor_axis_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->minor_axis_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("minor_axis");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // perimeter
    //
    if (this->perimeter_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->perimeter ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->perimeter_serializer_ != 0)
        s = this->perimeter_serializer_;
      else if (this->perimeter_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->perimeter_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("perimeter");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // radius
    //
    if (this->radius_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->radius ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->radius_serializer_ != 0)
        s = this->radius_serializer_;
      else if (this->radius_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->radius_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("radius");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for areas_3D_sskel.
  //
  void areas_3D_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // free_surface_area
    //
    if (this->free_surface_area_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->free_surface_area ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->free_surface_area_serializer_ != 0)
        s = this->free_surface_area_serializer_;
      else if (this->free_surface_area_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->free_surface_area_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("free_surface_area");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // total_surface_area
    //
    if (this->total_surface_area_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->total_surface_area ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->total_surface_area_serializer_ != 0)
        s = this->total_surface_area_serializer_;
      else if (this->total_surface_area_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->total_surface_area_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("total_surface_area");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for areas_2D_sskel.
  //
  void areas_2D_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // total_area
    //
    if (this->total_area_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->total_area ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->total_area_serializer_ != 0)
        s = this->total_area_serializer_;
      else if (this->total_area_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->total_area_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("total_area");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for volumes_sskel.
  //
  void volumes_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // fluid_volume
    //
    if (this->fluid_volume_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->fluid_volume ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->fluid_volume_serializer_ != 0)
        s = this->fluid_volume_serializer_;
      else if (this->fluid_volume_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->fluid_volume_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("fluid_volume");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // fluid_volume_fraction
    //
    if (this->fluid_volume_fraction_present ())
    {
      ctx.type_id (0);
      const ::common::units_fraction& r = this->fluid_volume_fraction ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_fraction_sskel* s = 0;

      if (t == 0 && this->fluid_volume_fraction_serializer_ != 0)
        s = this->fluid_volume_fraction_serializer_;
      else if (this->fluid_volume_fraction_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->fluid_volume_fraction_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_fraction_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_fraction_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("fluid_volume_fraction");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // solid_calcified_volume
    //
    if (this->solid_calcified_volume_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->solid_calcified_volume ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->solid_calcified_volume_serializer_ != 0)
        s = this->solid_calcified_volume_serializer_;
      else if (this->solid_calcified_volume_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->solid_calcified_volume_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("solid_calcified_volume");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // solid_volume
    //
    if (this->solid_volume_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->solid_volume ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->solid_volume_serializer_ != 0)
        s = this->solid_volume_serializer_;
      else if (this->solid_volume_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->solid_volume_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("solid_volume");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // solid_volume_fraction
    //
    if (this->solid_volume_fraction_present ())
    {
      ctx.type_id (0);
      const ::common::units_fraction& r = this->solid_volume_fraction ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_fraction_sskel* s = 0;

      if (t == 0 && this->solid_volume_fraction_serializer_ != 0)
        s = this->solid_volume_fraction_serializer_;
      else if (this->solid_volume_fraction_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->solid_volume_fraction_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_fraction_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_fraction_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("solid_volume_fraction");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // total_volume
    //
    if (this->total_volume_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->total_volume ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->total_volume_serializer_ != 0)
        s = this->total_volume_serializer_;
      else if (this->total_volume_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->total_volume_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("total_volume");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for geometrical_properties_sskel.
  //
  void geometrical_properties_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // parameters
    //
    if (this->parameters_present ())
    {
      ctx.type_id (0);
      const ::phenotype_common::geometrical_parameters& r = this->parameters ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::phenotype_common::geometrical_parameters_sskel* s = 0;

      if (t == 0 && this->parameters_serializer_ != 0)
        s = this->parameters_serializer_;
      else if (this->parameters_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->parameters_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::phenotype_common::geometrical_parameters_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::phenotype_common::geometrical_parameters_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("parameters");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // lengths
    //
    if (this->lengths_present ())
    {
      ctx.type_id (0);
      const ::phenotype_common::lengths& r = this->lengths ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::phenotype_common::lengths_sskel* s = 0;

      if (t == 0 && this->lengths_serializer_ != 0)
        s = this->lengths_serializer_;
      else if (this->lengths_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->lengths_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::phenotype_common::lengths_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::phenotype_common::lengths_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("lengths");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // areas
    //
    if (this->areas_present ())
    {
      ctx.type_id (0);
      const ::phenotype_common::areas_3D& r = this->areas ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::phenotype_common::areas_3D_sskel* s = 0;

      if (t == 0 && this->areas_serializer_ != 0)
        s = this->areas_serializer_;
      else if (this->areas_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->areas_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::phenotype_common::areas_3D_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::phenotype_common::areas_3D_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("areas");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // volumes
    //
    if (this->volumes_present ())
    {
      ctx.type_id (0);
      const ::phenotype_common::volumes& r = this->volumes ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::phenotype_common::volumes_sskel* s = 0;

      if (t == 0 && this->volumes_serializer_ != 0)
        s = this->volumes_serializer_;
      else if (this->volumes_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->volumes_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::phenotype_common::volumes_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::phenotype_common::volumes_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("volumes");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // cross_section
    //
    while (this->cross_section_next ())
    {
      ctx.type_id (0);
      const ::phenotype_common::cross_section& r = this->cross_section ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::phenotype_common::cross_section_sskel* s = 0;

      if (t == 0 && this->cross_section_serializer_ != 0)
        s = this->cross_section_serializer_;
      else if (this->cross_section_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->cross_section_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::phenotype_common::cross_section_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::phenotype_common::cross_section_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("cross_section");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for cross_section_sskel.
  //
  void cross_section_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // parameters
    //
    if (this->parameters_present ())
    {
      ctx.type_id (0);
      const ::phenotype_common::geometrical_parameters& r = this->parameters ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::phenotype_common::geometrical_parameters_sskel* s = 0;

      if (t == 0 && this->parameters_serializer_ != 0)
        s = this->parameters_serializer_;
      else if (this->parameters_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->parameters_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::phenotype_common::geometrical_parameters_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::phenotype_common::geometrical_parameters_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("parameters");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // lengths
    //
    if (this->lengths_present ())
    {
      ctx.type_id (0);
      const ::phenotype_common::lengths& r = this->lengths ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::phenotype_common::lengths_sskel* s = 0;

      if (t == 0 && this->lengths_serializer_ != 0)
        s = this->lengths_serializer_;
      else if (this->lengths_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->lengths_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::phenotype_common::lengths_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::phenotype_common::lengths_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("lengths");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // areas
    //
    if (this->areas_present ())
    {
      ctx.type_id (0);
      const ::phenotype_common::areas_2D& r = this->areas ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::phenotype_common::areas_2D_sskel* s = 0;

      if (t == 0 && this->areas_serializer_ != 0)
        s = this->areas_serializer_;
      else if (this->areas_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->areas_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::phenotype_common::areas_2D_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::phenotype_common::areas_2D_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("areas");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for mass_sskel.
  //
  void mass_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // biomass
    //
    if (this->biomass_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->biomass ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->biomass_serializer_ != 0)
        s = this->biomass_serializer_;
      else if (this->biomass_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->biomass_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("biomass");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // fluid_mass
    //
    if (this->fluid_mass_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->fluid_mass ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->fluid_mass_serializer_ != 0)
        s = this->fluid_mass_serializer_;
      else if (this->fluid_mass_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->fluid_mass_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("fluid_mass");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // total_mass
    //
    if (this->total_mass_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->total_mass ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->total_mass_serializer_ != 0)
        s = this->total_mass_serializer_;
      else if (this->total_mass_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->total_mass_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("total_mass");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }
}

namespace phenotype_common
{
  // Attribute validation and serialization for motility_types_sskel.
  //
  void motility_types_sskel::
  _serialize_attributes ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // ID
    //
    if (this->ID_present ())
    {
      unsigned int r = this->ID ();

      if (this->ID_serializer_)
      {
        this->ID_serializer_->pre (r);
        this->_start_attribute ("ID");
        this->ID_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->ID_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->ID_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->ID_serializer_->post ();
      }
    }
  }

  // Attribute validation and serialization for timescale_sskel.
  //
  void timescale_sskel::
  _serialize_attributes ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    typedef ::common::units_decimal_sskel base;
    base::_serialize_attributes ();

    if (ctx.error_type ())
      return;

    // mitotic
    //
    if (this->mitotic_present ())
    {
      bool r = this->mitotic ();

      if (this->mitotic_serializer_)
      {
        this->mitotic_serializer_->pre (r);
        this->_start_attribute ("mitotic");
        this->mitotic_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->mitotic_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->mitotic_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->mitotic_serializer_->post ();
      }
    }
  }

  // Attribute validation and serialization for transport_variable_sskel.
  //
  void transport_variable_sskel::
  _serialize_attributes ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // name
    //
    {
      const ::std::string& r = this->name ();

      if (this->name_serializer_)
      {
        this->name_serializer_->pre (r);
        this->_start_attribute ("name");
        this->name_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->name_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->name_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->name_serializer_->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_attribute);
        return;
      }
    }

    // units
    //
    if (this->units_present ())
    {
      const ::std::string& r = this->units ();

      if (this->units_serializer_)
      {
        this->units_serializer_->pre (r);
        this->_start_attribute ("units");
        this->units_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->units_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->units_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->units_serializer_->post ();
      }
    }

    // ID
    //
    if (this->ID_present ())
    {
      unsigned long long r = this->ID ();

      if (this->ID_serializer_)
      {
        this->ID_serializer_->pre (r);
        this->_start_attribute ("ID");
        this->ID_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->ID_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->ID_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->ID_serializer_->post ();
      }
    }

    // type
    //
    if (this->type_present ())
    {
      const ::variables::amount_type& r = this->type ();

      if (this->type_serializer_)
      {
        this->type_serializer_->pre (r);
        this->_start_attribute ("type");
        this->type_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->type_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->type_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->type_serializer_->post ();
      }
    }

    // ChEBI_ID
    //
    if (this->ChEBI_ID_present ())
    {
      const ::std::string& r = this->ChEBI_ID ();

      if (this->ChEBI_ID_serializer_)
      {
        this->ChEBI_ID_serializer_->pre (r);
        this->_start_attribute ("ChEBI_ID");
        this->ChEBI_ID_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->ChEBI_ID_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->ChEBI_ID_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->ChEBI_ID_serializer_->post ();
      }
    }

    // MeSH_ID
    //
    if (this->MeSH_ID_present ())
    {
      const ::std::string& r = this->MeSH_ID ();

      if (this->MeSH_ID_serializer_)
      {
        this->MeSH_ID_serializer_->pre (r);
        this->_start_attribute ("MeSH_ID");
        this->MeSH_ID_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->MeSH_ID_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->MeSH_ID_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->MeSH_ID_serializer_->post ();
      }
    }

    // DrugBank_ID
    //
    if (this->DrugBank_ID_present ())
    {
      const ::std::string& r = this->DrugBank_ID ();

      if (this->DrugBank_ID_serializer_)
      {
        this->DrugBank_ID_serializer_->pre (r);
        this->_start_attribute ("DrugBank_ID");
        this->DrugBank_ID_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->DrugBank_ID_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->DrugBank_ID_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->DrugBank_ID_serializer_->post ();
      }
    }

    // GMO_ID
    //
    if (this->GMO_ID_present ())
    {
      const ::std::string& r = this->GMO_ID ();

      if (this->GMO_ID_serializer_)
      {
        this->GMO_ID_serializer_->pre (r);
        this->_start_attribute ("GMO_ID");
        this->GMO_ID_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->GMO_ID_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->GMO_ID_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->GMO_ID_serializer_->post ();
      }
    }

    // GO_ID
    //
    if (this->GO_ID_present ())
    {
      const ::std::string& r = this->GO_ID ();

      if (this->GO_ID_serializer_)
      {
        this->GO_ID_serializer_->pre (r);
        this->_start_attribute ("GO_ID");
        this->GO_ID_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->GO_ID_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->GO_ID_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->GO_ID_serializer_->post ();
      }
    }

    // UniProt_ID
    //
    if (this->UniProt_ID_present ())
    {
      const ::std::string& r = this->UniProt_ID ();

      if (this->UniProt_ID_serializer_)
      {
        this->UniProt_ID_serializer_->pre (r);
        this->_start_attribute ("UniProt_ID");
        this->UniProt_ID_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->UniProt_ID_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->UniProt_ID_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->UniProt_ID_serializer_->post ();
      }
    }

    // PR_ID
    //
    if (this->PR_ID_present ())
    {
      const ::std::string& r = this->PR_ID ();

      if (this->PR_ID_serializer_)
      {
        this->PR_ID_serializer_->pre (r);
        this->_start_attribute ("PR_ID");
        this->PR_ID_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->PR_ID_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->PR_ID_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->PR_ID_serializer_->post ();
      }
    }
  }

  // Attribute validation and serialization for geometrical_parameters_sskel.
  //
  void geometrical_parameters_sskel::
  _serialize_attributes ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // units
    //
    if (this->units_present ())
    {
      const ::std::string& r = this->units ();

      if (this->units_serializer_)
      {
        this->units_serializer_->pre (r);
        this->_start_attribute ("units");
        this->units_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->units_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->units_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->units_serializer_->post ();
      }
    }
  }

  // Attribute validation and serialization for lengths_sskel.
  //
  void lengths_sskel::
  _serialize_attributes ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // units
    //
    if (this->units_present ())
    {
      const ::std::string& r = this->units ();

      if (this->units_serializer_)
      {
        this->units_serializer_->pre (r);
        this->_start_attribute ("units");
        this->units_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->units_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->units_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->units_serializer_->post ();
      }
    }
  }

  // Attribute validation and serialization for areas_3D_sskel.
  //
  void areas_3D_sskel::
  _serialize_attributes ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // units
    //
    if (this->units_present ())
    {
      const ::std::string& r = this->units ();

      if (this->units_serializer_)
      {
        this->units_serializer_->pre (r);
        this->_start_attribute ("units");
        this->units_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->units_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->units_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->units_serializer_->post ();
      }
    }
  }

  // Attribute validation and serialization for areas_2D_sskel.
  //
  void areas_2D_sskel::
  _serialize_attributes ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // units
    //
    if (this->units_present ())
    {
      const ::std::string& r = this->units ();

      if (this->units_serializer_)
      {
        this->units_serializer_->pre (r);
        this->_start_attribute ("units");
        this->units_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->units_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->units_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->units_serializer_->post ();
      }
    }
  }

  // Attribute validation and serialization for volumes_sskel.
  //
  void volumes_sskel::
  _serialize_attributes ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // units
    //
    if (this->units_present ())
    {
      const ::std::string& r = this->units ();

      if (this->units_serializer_)
      {
        this->units_serializer_->pre (r);
        this->_start_attribute ("units");
        this->units_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->units_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->units_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->units_serializer_->post ();
      }
    }
  }
}

// Begin epilogue.
//
//
// End epilogue.

