// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "cell.hpp"

#include <stdlib.h>
#include <new>

#include <xsde/cxx/guard.hxx>

namespace cell
{
  // population_definition
  //

  population_definition::
  population_definition ()
  {
    this->ID_present_ = false;
    this->name_present_ = false;
    this->units_present_ = false;
    this->phenotype_dataset_ = 0;
    this->custom_ = 0;
  }

  population_definition::
  ~population_definition ()
  {
    delete this->phenotype_dataset_;
    delete this->custom_;
  }

  void population_definition::
  _copy (population_definition& c) const
  {
    XSDE_UNUSED (c);

    if (this->ID_present ())
      c.ID (this->ID ());

    if (this->name_present ())
      c.name (this->name ());

    if (this->units_present ())
      c.units (this->units ());

    if (this->phenotype_dataset_present ())
    {
      ::phenotype_dataset::phenotype_dataset* m = this->phenotype_dataset ()._clone ();
      c.phenotype_dataset (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  population_definition* population_definition::
  _clone () const
  {
    population_definition* c = new population_definition;
    ::xsde::cxx::guard< population_definition > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // population_definitions
  //

  population_definitions::
  population_definitions ()
  {
    this->custom_ = 0;
  }

  population_definitions::
  ~population_definitions ()
  {
    delete this->custom_;
  }

  void population_definitions::
  _copy (population_definitions& c) const
  {
    XSDE_UNUSED (c);

    this->population_definition ().copy (c.population_definition ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  population_definitions* population_definitions::
  _clone () const
  {
    population_definitions* c = new population_definitions;
    ::xsde::cxx::guard< population_definitions > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // cell
  //

  cell::
  cell ()
  {
    this->ID_present_ = false;
    this->phenotype_dataset_ = 0;
    this->state_ = 0;
    this->custom_ = 0;
  }

  cell::
  ~cell ()
  {
    delete this->phenotype_dataset_;
    delete this->state_;
    delete this->custom_;
  }

  void cell::
  _copy (cell& c) const
  {
    XSDE_UNUSED (c);

    if (this->ID_present ())
      c.ID (this->ID ());

    if (this->phenotype_dataset_present ())
    {
      ::phenotype_dataset::phenotype_dataset* m = this->phenotype_dataset ()._clone ();
      c.phenotype_dataset (m);
    }

    if (this->state_present ())
    {
      ::state::state* m = this->state ()._clone ();
      c.state (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  cell* cell::
  _clone () const
  {
    cell* c = new cell;
    ::xsde::cxx::guard< cell > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // cell_population_individual
  //

  cell_population_individual::
  cell_population_individual ()
  {
    this->type_present_ = false;
    this->population_ID_present_ = false;
    this->custom_ = 0;
  }

  cell_population_individual::
  ~cell_population_individual ()
  {
    delete this->custom_;
  }

  void cell_population_individual::
  _copy (cell_population_individual& c) const
  {
    XSDE_UNUSED (c);

    if (this->type_present ())
      c.type (this->type ());

    if (this->population_ID_present ())
      c.population_ID (this->population_ID ());

    this->cell ().copy (c.cell ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  cell_population_individual* cell_population_individual::
  _clone () const
  {
    cell_population_individual* c = new cell_population_individual;
    ::xsde::cxx::guard< cell_population_individual > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // cell_population_aggregate
  //

  cell_population_aggregate::
  cell_population_aggregate ()
  {
    this->type_present_ = false;
    this->population_ID_present_ = false;
    this->value_ = 0;
    this->sequence_ = 0;
  }

  cell_population_aggregate::
  ~cell_population_aggregate ()
  {
    delete this->value_;
    delete this->sequence_;
  }

  void cell_population_aggregate::
  _copy (cell_population_aggregate& c) const
  {
    XSDE_UNUSED (c);

    if (this->type_present ())
      c.type (this->type ());

    if (this->population_ID_present ())
      c.population_ID (this->population_ID ());

    if (this->value_present ())
    {
      ::common::units_decimal* m = this->value ()._clone ();
      c.value (m);
    }

    if (this->sequence_present ())
    {
      sequence_type* m = this->sequence ()._clone ();
      c.sequence (m);
    }
  }

  cell_population_aggregate* cell_population_aggregate::
  _clone () const
  {
    cell_population_aggregate* c = new cell_population_aggregate;
    ::xsde::cxx::guard< cell_population_aggregate > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  cell_population_aggregate::sequence_type::
  sequence_type ()
  {
    this->phenotype_dataset_ = 0;
    this->state_ = 0;
    this->custom_ = 0;
  }

  cell_population_aggregate::sequence_type::
  ~sequence_type ()
  {
    delete this->phenotype_dataset_;
    delete this->state_;
    delete this->custom_;
  }

  void cell_population_aggregate::sequence_type::
  _copy (sequence_type& c) const
  {
    if (this->phenotype_dataset_present ())
    {
      ::phenotype_dataset::phenotype_dataset* m = this->phenotype_dataset ()._clone ();
      c.phenotype_dataset (m);
    }

    if (this->state_present ())
    {
      ::state::state* m = this->state ()._clone ();
      c.state (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  cell_population_aggregate::sequence_type* cell_population_aggregate::sequence_type::
  _clone () const
  {
    sequence_type* c = new sequence_type;
    ::xsde::cxx::guard< sequence_type > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // population_vector
  //

  population_vector::
  population_vector ()
  {
    this->voxel_ID_ = 0;
    this->value_ = 0;
    this->custom_ = 0;
  }

  population_vector::
  ~population_vector ()
  {
    delete this->voxel_ID_;
    delete this->value_;
    delete this->custom_;
  }

  void population_vector::
  _copy (population_vector& c) const
  {
    XSDE_UNUSED (c);

    if (this->voxel_ID_present ())
    {
      ::common::unsigned_int_list* m = this->voxel_ID ()._clone ();
      c.voxel_ID (m);
    }

    if (this->value_present ())
    {
      ::common::units_double_list* m = this->value ()._clone ();
      c.value (m);
    }

    this->cell_population ().copy (c.cell_population ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  population_vector* population_vector::
  _clone () const
  {
    population_vector* c = new population_vector;
    ::xsde::cxx::guard< population_vector > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // cell_populations
  //

  cell_populations::
  cell_populations ()
  {
    this->cell_population_ = 0;
  }

  cell_populations::
  ~cell_populations ()
  {
    delete this->cell_population_;
  }

  void cell_populations::
  _copy (cell_populations& c) const
  {
    XSDE_UNUSED (c);

    this->population_vector ().copy (c.population_vector ());

    if (this->cell_population_present ())
    {
      ::cell::cell_population_individual* m = this->cell_population ()._clone ();
      c.cell_population (m);
    }
  }

  cell_populations* cell_populations::
  _clone () const
  {
    cell_populations* c = new cell_populations;
    ::xsde::cxx::guard< cell_populations > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // cellular_information
  //

  cellular_information::
  cellular_information ()
  {
    this->DCLs_ = 0;
    this->population_definitions_ = 0;
    this->mesh_ = 0;
    this->cell_populations_ = 0;
  }

  cellular_information::
  ~cellular_information ()
  {
    delete this->DCLs_;
    delete this->population_definitions_;
    delete this->mesh_;
    delete this->cell_populations_;
  }

  void cellular_information::
  _copy (cellular_information& c) const
  {
    XSDE_UNUSED (c);

    if (this->DCLs_present ())
    {
      ::cell_line::DCLs* m = this->DCLs ()._clone ();
      c.DCLs (m);
    }

    if (this->population_definitions_present ())
    {
      ::cell::population_definitions* m = this->population_definitions ()._clone ();
      c.population_definitions (m);
    }

    if (this->mesh_present ())
    {
      ::mesh::mesh* m = this->mesh ()._clone ();
      c.mesh (m);
    }

    if (this->cell_populations_present ())
    {
      ::cell::cell_populations* m = this->cell_populations ()._clone ();
      c.cell_populations (m);
    }
  }

  cellular_information* cellular_information::
  _clone () const
  {
    cellular_information* c = new cellular_information;
    ::xsde::cxx::guard< cellular_information > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

