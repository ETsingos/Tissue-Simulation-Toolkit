// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CELL_HPP
#define CELL_HPP

#include <xsde/cxx/version.hxx>

#if (XSDE_INT_VERSION != 3020000L)
#error XSD/e runtime version mismatch
#endif

#include <xsde/cxx/config.hxx>

#ifndef XSDE_ENCODING_UTF8
#error the generated code uses the UTF-8 encodingwhile the XSD/e runtime does not (reconfigure the runtime or change the --char-encoding value)
#endif

#ifndef XSDE_STL
#error the generated code uses STL while the XSD/e runtime does not (reconfigure the runtime or add --no-stl)
#endif

#ifndef XSDE_EXCEPTIONS
#error the generated code uses exceptions while the XSD/e runtime does not (reconfigure the runtime or add --no-exceptions)
#endif

#ifndef XSDE_LONGLONG
#error the generated code uses long long while the XSD/e runtime does not (reconfigure the runtime or add --no-long-long)
#endif

#ifdef XSDE_CUSTOM_ALLOCATOR
#error the XSD/e runtime uses custom allocator while the generated code does not (reconfigure the runtime or add --custom-allocator)
#endif

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "cell-fwd.hpp"

#ifndef XSDE_DONT_INCLUDE_INLINE
#define XSDE_DONT_INCLUDE_INLINE

#include "common.hpp"

#include "phenotype_dataset.hpp"

#include "mesh.hpp"

#include "cell_line.hpp"

#include "state.hpp"

#undef XSDE_DONT_INCLUDE_INLINE
#else

#include "common.hpp"

#include "phenotype_dataset.hpp"

#include "mesh.hpp"

#include "cell_line.hpp"

#include "state.hpp"

#endif // XSDE_DONT_INCLUDE_INLINE

namespace cell
{
  // population_definition (variable-length)
  //
  class population_definition
  {
    private:
    population_definition (const population_definition&);
    population_definition& operator= (const population_definition&);

    public:
    population_definition ();

    population_definition*
    _clone () const;

    ~population_definition ();

    // ID
    //
    bool
    ID_present () const;

    void
    ID_present (bool);

    unsigned int
    ID () const;

    unsigned int&
    ID ();

    void
    ID (unsigned int);

    // name
    //
    bool
    name_present () const;

    void
    name_present (bool);

    const ::std::string&
    name () const;

    ::std::string&
    name ();

    void
    name (const ::std::string&);

    // units
    //
    bool
    units_present () const;

    void
    units_present (bool);

    const ::std::string&
    units () const;

    ::std::string&
    units ();

    void
    units (const ::std::string&);

    // phenotype_dataset
    //
    bool
    phenotype_dataset_present () const;

    const ::phenotype_dataset::phenotype_dataset&
    phenotype_dataset () const;

    ::phenotype_dataset::phenotype_dataset&
    phenotype_dataset ();

    void
    phenotype_dataset (::phenotype_dataset::phenotype_dataset*);

    ::phenotype_dataset::phenotype_dataset*
    phenotype_dataset_detach ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (population_definition&) const;

    private:
    unsigned int ID_;
    unsigned char ID_present_;
    ::std::string name_;
    unsigned char name_present_;
    ::std::string units_;
    unsigned char units_present_;
    ::phenotype_dataset::phenotype_dataset* phenotype_dataset_;
    ::common::custom* custom_;
  };

  // population_definitions (variable-length)
  //
  class population_definitions
  {
    private:
    population_definitions (const population_definitions&);
    population_definitions& operator= (const population_definitions&);

    public:
    population_definitions ();

    population_definitions*
    _clone () const;

    ~population_definitions ();

    // population_definition
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::cell::population_definition > population_definition_sequence;
    typedef population_definition_sequence::iterator population_definition_iterator;
    typedef population_definition_sequence::const_iterator population_definition_const_iterator;

    const population_definition_sequence&
    population_definition () const;

    population_definition_sequence&
    population_definition ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (population_definitions&) const;

    private:
    population_definition_sequence population_definition_;
    ::common::custom* custom_;
  };

  // cell (variable-length)
  //
  class cell
  {
    private:
    cell (const cell&);
    cell& operator= (const cell&);

    public:
    cell ();

    cell*
    _clone () const;

    ~cell ();

    // ID
    //
    bool
    ID_present () const;

    void
    ID_present (bool);

    unsigned int
    ID () const;

    unsigned int&
    ID ();

    void
    ID (unsigned int);

    // phenotype_dataset
    //
    bool
    phenotype_dataset_present () const;

    const ::phenotype_dataset::phenotype_dataset&
    phenotype_dataset () const;

    ::phenotype_dataset::phenotype_dataset&
    phenotype_dataset ();

    void
    phenotype_dataset (::phenotype_dataset::phenotype_dataset*);

    ::phenotype_dataset::phenotype_dataset*
    phenotype_dataset_detach ();

    // state
    //
    bool
    state_present () const;

    const ::state::state&
    state () const;

    ::state::state&
    state ();

    void
    state (::state::state*);

    ::state::state*
    state_detach ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (cell&) const;

    private:
    unsigned int ID_;
    unsigned char ID_present_;
    ::phenotype_dataset::phenotype_dataset* phenotype_dataset_;
    ::state::state* state_;
    ::common::custom* custom_;
  };

  // cell_population_individual (variable-length)
  //
  class cell_population_individual
  {
    private:
    cell_population_individual (const cell_population_individual&);
    cell_population_individual& operator= (const cell_population_individual&);

    public:
    cell_population_individual ();

    cell_population_individual*
    _clone () const;

    ~cell_population_individual ();

    // type
    //
    bool
    type_present () const;

    void
    type_present (bool);

    const ::std::string&
    type () const;

    ::std::string&
    type ();

    void
    type (const ::std::string&);

    // population_ID
    //
    bool
    population_ID_present () const;

    void
    population_ID_present (bool);

    unsigned int
    population_ID () const;

    unsigned int&
    population_ID ();

    void
    population_ID (unsigned int);

    // cell
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::cell::cell > cell_sequence;
    typedef cell_sequence::iterator cell_iterator;
    typedef cell_sequence::const_iterator cell_const_iterator;

    const cell_sequence&
    cell () const;

    cell_sequence&
    cell ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (cell_population_individual&) const;

    private:
    ::std::string type_;
    unsigned char type_present_;
    unsigned int population_ID_;
    unsigned char population_ID_present_;
    cell_sequence cell_;
    ::common::custom* custom_;
  };

  // cell_population_aggregate (variable-length)
  //
  class cell_population_aggregate
  {
    private:
    cell_population_aggregate (const cell_population_aggregate&);
    cell_population_aggregate& operator= (const cell_population_aggregate&);

    public:
    cell_population_aggregate ();

    cell_population_aggregate*
    _clone () const;

    ~cell_population_aggregate ();

    // type
    //
    bool
    type_present () const;

    void
    type_present (bool);

    const ::std::string&
    type () const;

    ::std::string&
    type ();

    void
    type (const ::std::string&);

    // population_ID
    //
    bool
    population_ID_present () const;

    void
    population_ID_present (bool);

    unsigned int
    population_ID () const;

    unsigned int&
    population_ID ();

    void
    population_ID (unsigned int);

    // value
    //
    bool
    value_present () const;

    const ::common::units_decimal&
    value () const;

    ::common::units_decimal&
    value ();

    void
    value (::common::units_decimal*);

    ::common::units_decimal*
    value_detach ();

    // sequence (variable-length)
    //
    class sequence_type
    {
      public:
      sequence_type ();

      sequence_type*
      _clone () const;

      ~sequence_type ();

      private:
      sequence_type (const sequence_type&);
      sequence_type& operator= (const sequence_type&);

      public:
      // phenotype_dataset
      //
      bool
      phenotype_dataset_present () const;

      const ::phenotype_dataset::phenotype_dataset&
      phenotype_dataset () const;

      ::phenotype_dataset::phenotype_dataset&
      phenotype_dataset ();

      void
      phenotype_dataset (::phenotype_dataset::phenotype_dataset*);

      ::phenotype_dataset::phenotype_dataset*
      phenotype_dataset_detach ();

      // state
      //
      bool
      state_present () const;

      const ::state::state&
      state () const;

      ::state::state&
      state ();

      void
      state (::state::state*);

      ::state::state*
      state_detach ();

      // custom
      //
      bool
      custom_present () const;

      const ::common::custom&
      custom () const;

      ::common::custom&
      custom ();

      void
      custom (::common::custom*);

      ::common::custom*
      custom_detach ();

      void
      _copy (sequence_type&) const;

      private:
      ::phenotype_dataset::phenotype_dataset* phenotype_dataset_;
      ::state::state* state_;
      ::common::custom* custom_;
    };

    bool
    sequence_present () const;

    const sequence_type&
    sequence () const;

    sequence_type&
    sequence ();

    void
    sequence (sequence_type*);

    sequence_type*
    sequence_detach ();

    void
    _copy (cell_population_aggregate&) const;

    private:
    ::std::string type_;
    unsigned char type_present_;
    unsigned int population_ID_;
    unsigned char population_ID_present_;
    ::common::units_decimal* value_;
    sequence_type* sequence_;
  };

  // population_vector (variable-length)
  //
  class population_vector
  {
    private:
    population_vector (const population_vector&);
    population_vector& operator= (const population_vector&);

    public:
    population_vector ();

    population_vector*
    _clone () const;

    ~population_vector ();

    // voxel_ID
    //
    bool
    voxel_ID_present () const;

    const ::common::unsigned_int_list&
    voxel_ID () const;

    ::common::unsigned_int_list&
    voxel_ID ();

    void
    voxel_ID (::common::unsigned_int_list*);

    ::common::unsigned_int_list*
    voxel_ID_detach ();

    // value
    //
    bool
    value_present () const;

    const ::common::units_double_list&
    value () const;

    ::common::units_double_list&
    value ();

    void
    value (::common::units_double_list*);

    ::common::units_double_list*
    value_detach ();

    // cell_population
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::cell::cell_population_aggregate > cell_population_sequence;
    typedef cell_population_sequence::iterator cell_population_iterator;
    typedef cell_population_sequence::const_iterator cell_population_const_iterator;

    const cell_population_sequence&
    cell_population () const;

    cell_population_sequence&
    cell_population ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (population_vector&) const;

    private:
    ::common::unsigned_int_list* voxel_ID_;
    ::common::units_double_list* value_;
    cell_population_sequence cell_population_;
    ::common::custom* custom_;
  };

  // cell_populations (variable-length)
  //
  class cell_populations
  {
    private:
    cell_populations (const cell_populations&);
    cell_populations& operator= (const cell_populations&);

    public:
    cell_populations ();

    cell_populations*
    _clone () const;

    ~cell_populations ();

    // population_vector
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::cell::population_vector > population_vector_sequence;
    typedef population_vector_sequence::iterator population_vector_iterator;
    typedef population_vector_sequence::const_iterator population_vector_const_iterator;

    const population_vector_sequence&
    population_vector () const;

    population_vector_sequence&
    population_vector ();

    // cell_population
    //
    bool
    cell_population_present () const;

    const ::cell::cell_population_individual&
    cell_population () const;

    ::cell::cell_population_individual&
    cell_population ();

    void
    cell_population (::cell::cell_population_individual*);

    ::cell::cell_population_individual*
    cell_population_detach ();

    void
    _copy (cell_populations&) const;

    private:
    population_vector_sequence population_vector_;
    ::cell::cell_population_individual* cell_population_;
  };

  // cellular_information (variable-length)
  //
  class cellular_information
  {
    private:
    cellular_information (const cellular_information&);
    cellular_information& operator= (const cellular_information&);

    public:
    cellular_information ();

    cellular_information*
    _clone () const;

    ~cellular_information ();

    // DCLs
    //
    bool
    DCLs_present () const;

    const ::cell_line::DCLs&
    DCLs () const;

    ::cell_line::DCLs&
    DCLs ();

    void
    DCLs (::cell_line::DCLs*);

    ::cell_line::DCLs*
    DCLs_detach ();

    // population_definitions
    //
    bool
    population_definitions_present () const;

    const ::cell::population_definitions&
    population_definitions () const;

    ::cell::population_definitions&
    population_definitions ();

    void
    population_definitions (::cell::population_definitions*);

    ::cell::population_definitions*
    population_definitions_detach ();

    // mesh
    //
    bool
    mesh_present () const;

    const ::mesh::mesh&
    mesh () const;

    ::mesh::mesh&
    mesh ();

    void
    mesh (::mesh::mesh*);

    ::mesh::mesh*
    mesh_detach ();

    // cell_populations
    //
    bool
    cell_populations_present () const;

    const ::cell::cell_populations&
    cell_populations () const;

    ::cell::cell_populations&
    cell_populations ();

    void
    cell_populations (::cell::cell_populations*);

    ::cell::cell_populations*
    cell_populations_detach ();

    void
    _copy (cellular_information&) const;

    private:
    ::cell_line::DCLs* DCLs_;
    ::cell::population_definitions* population_definitions_;
    ::mesh::mesh* mesh_;
    ::cell::cell_populations* cell_populations_;
  };
}

#ifndef XSDE_DONT_INCLUDE_INLINE

#include "common.ipp"

#include "phenotype_dataset.ipp"

#include "mesh.ipp"

#include "cell_line.ipp"

#include "state.ipp"

#endif // XSDE_DONT_INCLUDE_INLINE

#ifndef XSDE_DONT_INCLUDE_INLINE
#include "cell.ipp"
#endif // XSDE_DONT_INCLUDE_INLINE

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

#endif // CELL_HPP
