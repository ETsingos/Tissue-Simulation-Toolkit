// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "pkpd.hpp"

#include <stdlib.h>
#include <new>

#include <xsde/cxx/guard.hxx>

namespace pkpd
{
  // pharmacokinetics
  //

  pharmacokinetics::
  pharmacokinetics ()
  {
    this->inactivation_rate_ = 0;
    this->half_life_ = 0;
  }

  pharmacokinetics::
  ~pharmacokinetics ()
  {
    delete this->inactivation_rate_;
    delete this->half_life_;
  }

  void pharmacokinetics::
  _copy (pharmacokinetics& c) const
  {
    XSDE_UNUSED (c);

    if (this->inactivation_rate_present ())
    {
      ::common::units_decimal* m = this->inactivation_rate ()._clone ();
      c.inactivation_rate (m);
    }

    if (this->half_life_present ())
    {
      ::common::units_decimal* m = this->half_life ()._clone ();
      c.half_life (m);
    }
  }

  pharmacokinetics* pharmacokinetics::
  _clone () const
  {
    pharmacokinetics* c = new pharmacokinetics;
    ::xsde::cxx::guard< pharmacokinetics > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // drug
  //

  drug::
  drug ()
  {
    this->choice_arm_ = choice_arm_tag (2);
  }

  drug::
  ~drug ()
  {
    this->choice_arm (choice_arm_tag (2));
  }

  void drug::
  choice_arm (choice_arm_tag x)
  {
    if (this->choice_arm_ == x)
      return;

    switch (this->choice_arm_)
    {
      case dose_tag:
      {
        delete this->choice_.dose_;
        break;
      }
      case pharmacokinetics_tag:
      {
        delete this->choice_.pharmacokinetics_;
        break;
      }
      default:
      break;
    }

    this->choice_arm_ = choice_arm_tag (2);

    switch (x)
    {
      case dose_tag:
      {
        this->choice_.dose_ = 0;
        break;
      }
      case pharmacokinetics_tag:
      {
        this->choice_.pharmacokinetics_ = 0;
        break;
      }
      default:
      break;
    }

    this->choice_arm_ = x;
  }

  void drug::
  _copy (drug& c) const
  {
    XSDE_UNUSED (c);

    c.choice_arm (this->choice_arm ());

    switch (this->choice_arm ())
    {
      case dose_tag:
      {
        {
          ::pkpd::dose* m = this->dose ()._clone ();
          c.dose (m);
        }

        break;
      }
      case pharmacokinetics_tag:
      {
        {
          ::pkpd::pharmacokinetics* m = this->pharmacokinetics ()._clone ();
          c.pharmacokinetics (m);
        }

        break;
      }
      default:
      break;
    }
  }

  drug* drug::
  _clone () const
  {
    drug* c = new drug;
    ::xsde::cxx::guard< drug > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // drug_dose
  //

  drug_dose::
  drug_dose ()
  {
    this->ID_present_ = false;
    this->ChEBI_ID_present_ = false;
    this->MeSH_ID_present_ = false;
    this->DrugBank_ID_present_ = false;
    this->GMO_ID_present_ = false;
    this->GO_ID_present_ = false;
    this->UniProt_ID_present_ = false;
    this->PR_ID_present_ = false;
    this->name_present_ = false;
    this->units_present_ = false;
    this->dose_ = 0;
  }

  drug_dose::
  ~drug_dose ()
  {
    delete this->dose_;
  }

  void drug_dose::
  _copy (drug_dose& c) const
  {
    XSDE_UNUSED (c);

    if (this->ID_present ())
      c.ID (this->ID ());

    if (this->ChEBI_ID_present ())
      c.ChEBI_ID (this->ChEBI_ID ());

    if (this->MeSH_ID_present ())
      c.MeSH_ID (this->MeSH_ID ());

    if (this->DrugBank_ID_present ())
      c.DrugBank_ID (this->DrugBank_ID ());

    if (this->GMO_ID_present ())
      c.GMO_ID (this->GMO_ID ());

    if (this->GO_ID_present ())
      c.GO_ID (this->GO_ID ());

    if (this->UniProt_ID_present ())
      c.UniProt_ID (this->UniProt_ID ());

    if (this->PR_ID_present ())
      c.PR_ID (this->PR_ID ());

    if (this->name_present ())
      c.name (this->name ());

    if (this->units_present ())
      c.units (this->units ());

    {
      ::pkpd::dose* m = this->dose ()._clone ();
      c.dose (m);
    }
  }

  drug_dose* drug_dose::
  _clone () const
  {
    drug_dose* c = new drug_dose;
    ::xsde::cxx::guard< drug_dose > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // drug_pk
  //

  drug_pk::
  drug_pk ()
  {
    this->ID_present_ = false;
    this->ChEBI_ID_present_ = false;
    this->MeSH_ID_present_ = false;
    this->DrugBank_ID_present_ = false;
    this->GMO_ID_present_ = false;
    this->GO_ID_present_ = false;
    this->UniProt_ID_present_ = false;
    this->PR_ID_present_ = false;
    this->name_present_ = false;
    this->units_present_ = false;
    this->pharmacokinetics_ = 0;
  }

  drug_pk::
  ~drug_pk ()
  {
    delete this->pharmacokinetics_;
  }

  void drug_pk::
  _copy (drug_pk& c) const
  {
    XSDE_UNUSED (c);

    if (this->ID_present ())
      c.ID (this->ID ());

    if (this->ChEBI_ID_present ())
      c.ChEBI_ID (this->ChEBI_ID ());

    if (this->MeSH_ID_present ())
      c.MeSH_ID (this->MeSH_ID ());

    if (this->DrugBank_ID_present ())
      c.DrugBank_ID (this->DrugBank_ID ());

    if (this->GMO_ID_present ())
      c.GMO_ID (this->GMO_ID ());

    if (this->GO_ID_present ())
      c.GO_ID (this->GO_ID ());

    if (this->UniProt_ID_present ())
      c.UniProt_ID (this->UniProt_ID ());

    if (this->PR_ID_present ())
      c.PR_ID (this->PR_ID ());

    if (this->name_present ())
      c.name (this->name ());

    if (this->units_present ())
      c.units (this->units ());

    if (this->pharmacokinetics_present ())
    {
      ::pkpd::pharmacokinetics* m = this->pharmacokinetics ()._clone ();
      c.pharmacokinetics (m);
    }
  }

  drug_pk* drug_pk::
  _clone () const
  {
    drug_pk* c = new drug_pk;
    ::xsde::cxx::guard< drug_pk > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // dose
  //

  dose::
  dose ()
  {
    this->type_present_ = false;
  }

  dose::
  ~dose ()
  {
  }

  void dose::
  _copy (dose& c) const
  {
    XSDE_UNUSED (c);

    const ::common::units_decimal& b = *this;
    b._copy (c);
    if (this->type_present ())
      c.type (this->type ());
  }

  dose* dose::
  _clone () const
  {
    dose* c = new dose;
    ::xsde::cxx::guard< dose > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // therapy
  //

  therapy::
  therapy ()
  {
  }

  therapy::
  ~therapy ()
  {
  }

  void therapy::
  _copy (therapy& c) const
  {
    XSDE_UNUSED (c);

    this->drug ().copy (c.drug ());
  }

  therapy* therapy::
  _clone () const
  {
    therapy* c = new therapy;
    ::xsde::cxx::guard< therapy > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // response
  //

  response::
  response ()
  {
    this->maximum_birth_inhibition_ = 0;
    this->maximum_birth_inhibition_time_ = 0;
    this->birth_inhibition_recovery_rate_ = 0;
    this->maximum_death_rate_ = 0;
    this->maximum_death_time_ = 0;
    this->death_recovery_rate_ = 0;
    this->custom_ = 0;
  }

  response::
  ~response ()
  {
    delete this->maximum_birth_inhibition_;
    delete this->maximum_birth_inhibition_time_;
    delete this->birth_inhibition_recovery_rate_;
    delete this->maximum_death_rate_;
    delete this->maximum_death_time_;
    delete this->death_recovery_rate_;
    delete this->custom_;
  }

  void response::
  _copy (response& c) const
  {
    XSDE_UNUSED (c);

    if (this->maximum_birth_inhibition_present ())
    {
      ::common::units_decimal* m = this->maximum_birth_inhibition ()._clone ();
      c.maximum_birth_inhibition (m);
    }

    if (this->maximum_birth_inhibition_time_present ())
    {
      ::common::units_decimal* m = this->maximum_birth_inhibition_time ()._clone ();
      c.maximum_birth_inhibition_time (m);
    }

    if (this->birth_inhibition_recovery_rate_present ())
    {
      ::common::units_decimal* m = this->birth_inhibition_recovery_rate ()._clone ();
      c.birth_inhibition_recovery_rate (m);
    }

    if (this->maximum_death_rate_present ())
    {
      ::common::units_decimal* m = this->maximum_death_rate ()._clone ();
      c.maximum_death_rate (m);
    }

    if (this->maximum_death_time_present ())
    {
      ::common::units_decimal* m = this->maximum_death_time ()._clone ();
      c.maximum_death_time (m);
    }

    if (this->death_recovery_rate_present ())
    {
      ::common::units_decimal* m = this->death_recovery_rate ()._clone ();
      c.death_recovery_rate (m);
    }

    this->response_observation ().copy (c.response_observation ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  response* response::
  _clone () const
  {
    response* c = new response;
    ::xsde::cxx::guard< response > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // response_observation
  //

  response_observation::
  response_observation ()
  {
    this->time_ = 0;
    this->birth_rate_ = 0;
    this->death_rate_ = 0;
    this->net_birth_rate_ = 0;
    this->net_death_rate_ = 0;
    this->apoptotic_duration_ = 0;
    this->percent_cell_viability_ = 0;
    this->custom_ = 0;
  }

  response_observation::
  ~response_observation ()
  {
    delete this->time_;
    delete this->birth_rate_;
    delete this->death_rate_;
    delete this->net_birth_rate_;
    delete this->net_death_rate_;
    delete this->apoptotic_duration_;
    delete this->percent_cell_viability_;
    delete this->custom_;
  }

  void response_observation::
  _copy (response_observation& c) const
  {
    XSDE_UNUSED (c);

    if (this->time_present ())
    {
      ::common::units_decimal* m = this->time ()._clone ();
      c.time (m);
    }

    if (this->birth_rate_present ())
    {
      ::common::units_decimal_nonnegative* m = this->birth_rate ()._clone ();
      c.birth_rate (m);
    }

    if (this->death_rate_present ())
    {
      ::common::units_decimal_nonnegative* m = this->death_rate ()._clone ();
      c.death_rate (m);
    }

    if (this->net_birth_rate_present ())
    {
      ::common::units_decimal* m = this->net_birth_rate ()._clone ();
      c.net_birth_rate (m);
    }

    if (this->net_death_rate_present ())
    {
      ::common::units_decimal* m = this->net_death_rate ()._clone ();
      c.net_death_rate (m);
    }

    if (this->apoptotic_duration_present ())
    {
      ::common::units_decimal* m = this->apoptotic_duration ()._clone ();
      c.apoptotic_duration (m);
    }

    if (this->percent_cell_viability_present ())
    {
      ::common::units_decimal* m = this->percent_cell_viability ()._clone ();
      c.percent_cell_viability (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  response_observation* response_observation::
  _clone () const
  {
    response_observation* c = new response_observation;
    ::xsde::cxx::guard< response_observation > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // pharmacodynamics
  //

  pharmacodynamics::
  pharmacodynamics ()
  {
  }

  pharmacodynamics::
  ~pharmacodynamics ()
  {
  }

  void pharmacodynamics::
  _copy (pharmacodynamics& c) const
  {
    XSDE_UNUSED (c);

    this->therapy_measurement_set ().copy (c.therapy_measurement_set ());
  }

  pharmacodynamics* pharmacodynamics::
  _clone () const
  {
    pharmacodynamics* c = new pharmacodynamics;
    ::xsde::cxx::guard< pharmacodynamics > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // therapy_measurement_set
  //

  therapy_measurement_set::
  therapy_measurement_set ()
  {
    this->ID_present_ = false;
    this->therapy_ = 0;
    this->response_ = 0;
  }

  therapy_measurement_set::
  ~therapy_measurement_set ()
  {
    delete this->therapy_;
    delete this->response_;
  }

  void therapy_measurement_set::
  _copy (therapy_measurement_set& c) const
  {
    XSDE_UNUSED (c);

    if (this->ID_present ())
      c.ID (this->ID ());

    {
      ::pkpd::therapy* m = this->therapy ()._clone ();
      c.therapy (m);
    }

    {
      ::pkpd::response* m = this->response ()._clone ();
      c.response (m);
    }
  }

  therapy_measurement_set* therapy_measurement_set::
  _clone () const
  {
    therapy_measurement_set* c = new therapy_measurement_set;
    ::xsde::cxx::guard< therapy_measurement_set > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // PKPD
  //

  PKPD::
  PKPD ()
  {
    this->pharmacodynamics_ = 0;
  }

  PKPD::
  ~PKPD ()
  {
    delete this->pharmacodynamics_;
  }

  void PKPD::
  _copy (PKPD& c) const
  {
    XSDE_UNUSED (c);

    this->drug ().copy (c.drug ());

    if (this->pharmacodynamics_present ())
    {
      ::pkpd::pharmacodynamics* m = this->pharmacodynamics ()._clone ();
      c.pharmacodynamics (m);
    }
  }

  PKPD* PKPD::
  _clone () const
  {
    PKPD* c = new PKPD;
    ::xsde::cxx::guard< PKPD > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

