// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "state-pimpl.hpp"

#include <xsde/cxx/parser/validating/string-common.hxx>

namespace state
{
  // phase_name_pimpl
  //

  phase_name_pimpl::
  phase_name_pimpl ()
  : phase_name_pskel (&base_impl_)
  {
  }

  void phase_name_pimpl::
  pre ()
  {
    this->base_impl_.pre ();
    this->phase_name_pimpl_state_.phase_name_ = ::state::phase_name ();
  }

  void phase_name_pimpl::
  GO_ID (const ::std::string& x)
  {
    this->phase_name_pimpl_state_.phase_name_.GO_ID (x);
  }

  ::state::phase_name phase_name_pimpl::
  post_phase_name ()
  {
    static_cast< ::std::string& > (this->phase_name_pimpl_state_.phase_name_) = 
    this->base_impl_.post_string ();
    return this->phase_name_pimpl_state_.phase_name_;
  }

  // phase_pimpl
  //

  phase_pimpl::
  phase_pimpl (bool b)
  {
    this->phase_pimpl_base_ = b;
    this->phase_pimpl_state_.phase_ = 0;
  }

  phase_pimpl::
  ~phase_pimpl ()
  {
    if (!this->phase_pimpl_base_ && this->phase_pimpl_state_.phase_)
      delete this->phase_pimpl_state_.phase_;
  }

  void phase_pimpl::
  _reset ()
  {
    phase_pskel::_reset ();

    if (!this->phase_pimpl_base_ && this->phase_pimpl_state_.phase_)
    {
      delete this->phase_pimpl_state_.phase_;
      this->phase_pimpl_state_.phase_ = 0;
    }
  }

  void phase_pimpl::
  pre_impl (::state::phase* x)
  {
    this->phase_pimpl_state_.phase_ = x;
  }

  void phase_pimpl::
  pre ()
  {
    ::state::phase* x = new ::state::phase;
    this->pre_impl (x);
  }

  void phase_pimpl::
  model_name (const ::std::string& x)
  {
    this->phase_pimpl_state_.phase_->model_name (x);
  }

  void phase_pimpl::
  phase_name (const ::state::phase_name& x)
  {
    this->phase_pimpl_state_.phase_->phase_name (x);
  }

  void phase_pimpl::
  cell_cycle_model_index (unsigned short x)
  {
    this->phase_pimpl_state_.phase_->cell_cycle_model_index (x);
  }

  void phase_pimpl::
  cell_cycle_phase_index (unsigned short x)
  {
    this->phase_pimpl_state_.phase_->cell_cycle_phase_index (x);
  }

  void phase_pimpl::
  elapsed_time (::common::units_decimal* x)
  {
    this->phase_pimpl_state_.phase_->elapsed_time (x);
  }

  void phase_pimpl::
  custom (::common::custom* x)
  {
    this->phase_pimpl_state_.phase_->custom (x);
  }

  ::state::phase* phase_pimpl::
  post_phase ()
  {
    ::state::phase* r = this->phase_pimpl_state_.phase_;
    this->phase_pimpl_state_.phase_ = 0;
    return r;
  }

  // orientation_formalism_pimpl
  //

  orientation_formalism_pimpl::
  orientation_formalism_pimpl ()
  : orientation_formalism_pskel (0)
  {
  }

  void orientation_formalism_pimpl::
  pre ()
  {
    this->orientation_formalism_pimpl_state_.str_.clear ();
  }

  void orientation_formalism_pimpl::
  _characters (const ::xsde::cxx::ro_string& s)
  {
    if (this->_facets ().whitespace_ == 2 &&
        this->orientation_formalism_pimpl_state_.str_.size () == 0)
    {
      ::xsde::cxx::ro_string tmp (s.data (), s.size ());

      if (::xsde::cxx::trim_left (tmp) != 0)
      {
        this->orientation_formalism_pimpl_state_.str_ += tmp;
      }
    }
    else
      this->orientation_formalism_pimpl_state_.str_ += s;
  }

  void orientation_formalism_pimpl::
  _post ()
  {
    ::xsde::cxx::parser::validating::string_common::validate_facets (
      this->orientation_formalism_pimpl_state_.str_,
      this->_facets (),
      this->_context ());
  }

  ::state::orientation_formalism orientation_formalism_pimpl::
  post_orientation_formalism ()
  {
    ::state::orientation_formalism::value_type v =
    static_cast< ::state::orientation_formalism::value_type > (0);
    const char* s = this->orientation_formalism_pimpl_state_.str_.c_str ();

    if (strcmp (s, "axis-angle") == 0)
      v = ::state::orientation_formalism::axis_angle;
    else if (strcmp (s, "quaternion") == 0)
      v = ::state::orientation_formalism::quaternion;
    else if (strcmp (s, "Euler Angles") == 0)
      v = ::state::orientation_formalism::Euler_Angles;
    else if (strcmp (s, "Tait-Bryan") == 0)
      v = ::state::orientation_formalism::Tait_Bryan;
    else if (strcmp (s, "polar") == 0)
      v = ::state::orientation_formalism::polar;
    else if (strcmp (s, "Polar") == 0)
      v = ::state::orientation_formalism::Polar;
    else if (strcmp (s, "Unit Vector") == 0)
      v = ::state::orientation_formalism::Unit_Vector;

    ::state::orientation_formalism r (v);
    return r;
  }

  // orientation_pimpl
  //

  orientation_pimpl::
  orientation_pimpl (bool b)
  : orientation_pskel (&base_impl_),
    base_impl_ (true)
  {
    this->orientation_pimpl_base_ = b;
    this->orientation_pimpl_state_.orientation_ = 0;
  }

  orientation_pimpl::
  ~orientation_pimpl ()
  {
    if (!this->orientation_pimpl_base_ && this->orientation_pimpl_state_.orientation_)
      delete this->orientation_pimpl_state_.orientation_;
  }

  void orientation_pimpl::
  _reset ()
  {
    orientation_pskel::_reset ();

    if (!this->orientation_pimpl_base_ && this->orientation_pimpl_state_.orientation_)
    {
      delete this->orientation_pimpl_state_.orientation_;
      this->orientation_pimpl_state_.orientation_ = 0;
    }
  }

  void orientation_pimpl::
  pre_impl (::state::orientation* x)
  {
    this->orientation_pimpl_state_.orientation_ = x;
    this->base_impl_.pre_impl (x);
  }

  void orientation_pimpl::
  pre ()
  {
    ::state::orientation* x = new ::state::orientation;
    this->pre_impl (x);
  }

  void orientation_pimpl::
  formalism (const ::state::orientation_formalism& x)
  {
    this->orientation_pimpl_state_.orientation_->formalism (x);
  }

  ::state::orientation* orientation_pimpl::
  post_orientation ()
  {
    this->base_impl_.post_units_double_list ();
    ::state::orientation* r = this->orientation_pimpl_state_.orientation_;
    this->orientation_pimpl_state_.orientation_ = 0;
    return r;
  }

  // cell_parts_pimpl
  //

  cell_parts_pimpl::
  cell_parts_pimpl (bool b)
  : cell_parts_pimpl_state_ (sizeof (cell_parts_pimpl_state ), &cell_parts_pimpl_state_first_)
  {
    this->cell_parts_pimpl_base_ = b;
  }

  cell_parts_pimpl::
  ~cell_parts_pimpl ()
  {
    for (; !this->cell_parts_pimpl_state_.empty (); this->cell_parts_pimpl_state_.pop ())
    {
      if (!this->cell_parts_pimpl_base_ && static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_)
        delete static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_;
    }
  }

  void cell_parts_pimpl::
  _reset ()
  {
    cell_parts_pskel::_reset ();

    for (; !this->cell_parts_pimpl_state_.empty (); this->cell_parts_pimpl_state_.pop ())
    {
      if (!this->cell_parts_pimpl_base_ && static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_)
        delete static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_;
    }
  }

  void cell_parts_pimpl::
  pre_impl (::state::cell_parts* x)
  {
    this->cell_parts_pimpl_state_.push ();
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_ = x;
  }

  void cell_parts_pimpl::
  pre ()
  {
    ::state::cell_parts* x = new ::state::cell_parts;
    this->pre_impl (x);
  }

  void cell_parts_pimpl::
  name (const ::std::string& x)
  {
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_->name (x);
  }

  void cell_parts_pimpl::
  ID (unsigned int x)
  {
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_->ID (x);
  }

  void cell_parts_pimpl::
  orientation (::state::orientation* x)
  {
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_->orientation (x);
  }

  void cell_parts_pimpl::
  position (::common::units_double_list* x)
  {
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_->position (x);
  }

  void cell_parts_pimpl::
  velocity (::common::units_double_list* x)
  {
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_->velocity (x);
  }

  void cell_parts_pimpl::
  voxels (::mesh::int_list_xpath* x)
  {
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_->voxels (x);
  }

  void cell_parts_pimpl::
  cell_part (::state::cell_parts* x)
  {
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_->cell_part ().push_back (x);
  }

  void cell_parts_pimpl::
  custom (::common::custom* x)
  {
    static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_->custom (x);
  }

  ::state::cell_parts* cell_parts_pimpl::
  post_cell_parts ()
  {
    ::state::cell_parts* r = static_cast< cell_parts_pimpl_state* > (this->cell_parts_pimpl_state_.top ())->cell_parts_;
    this->cell_parts_pimpl_state_.pop ();
    return r;
  }

  // state_pimpl
  //

  state_pimpl::
  state_pimpl (bool b)
  {
    this->state_pimpl_base_ = b;
    this->state_pimpl_state_.state_ = 0;
  }

  state_pimpl::
  ~state_pimpl ()
  {
    if (!this->state_pimpl_base_ && this->state_pimpl_state_.state_)
      delete this->state_pimpl_state_.state_;
  }

  void state_pimpl::
  _reset ()
  {
    state_pskel::_reset ();

    if (!this->state_pimpl_base_ && this->state_pimpl_state_.state_)
    {
      delete this->state_pimpl_state_.state_;
      this->state_pimpl_state_.state_ = 0;
    }
  }

  void state_pimpl::
  pre_impl (::state::state* x)
  {
    this->state_pimpl_state_.state_ = x;
  }

  void state_pimpl::
  pre ()
  {
    ::state::state* x = new ::state::state;
    this->pre_impl (x);
  }

  void state_pimpl::
  orientation (::state::orientation* x)
  {
    this->state_pimpl_state_.state_->orientation (x);
  }

  void state_pimpl::
  position (::common::units_double_list* x)
  {
    this->state_pimpl_state_.state_->position (x);
  }

  void state_pimpl::
  velocity (::common::units_double_list* x)
  {
    this->state_pimpl_state_.state_->velocity (x);
  }

  void state_pimpl::
  voxels (::mesh::int_list_xpath* x)
  {
    this->state_pimpl_state_.state_->voxels (x);
  }

  void state_pimpl::
  cell_part (::state::cell_parts* x)
  {
    this->state_pimpl_state_.state_->cell_part ().push_back (x);
  }

  void state_pimpl::
  phase (::state::phase* x)
  {
    this->state_pimpl_state_.state_->phase (x);
  }

  void state_pimpl::
  adhered_cells (::state::list_of_adhered_cells* x)
  {
    this->state_pimpl_state_.state_->adhered_cells (x);
  }

  void state_pimpl::
  custom (::common::custom* x)
  {
    this->state_pimpl_state_.state_->custom (x);
  }

  ::state::state* state_pimpl::
  post_state ()
  {
    ::state::state* r = this->state_pimpl_state_.state_;
    this->state_pimpl_state_.state_ = 0;
    return r;
  }

  // adhered_cell_pimpl
  //

  adhered_cell_pimpl::
  adhered_cell_pimpl (bool b)
  {
    this->adhered_cell_pimpl_base_ = b;
    this->adhered_cell_pimpl_state_.adhered_cell_ = 0;
  }

  adhered_cell_pimpl::
  ~adhered_cell_pimpl ()
  {
    if (!this->adhered_cell_pimpl_base_ && this->adhered_cell_pimpl_state_.adhered_cell_)
      delete this->adhered_cell_pimpl_state_.adhered_cell_;
  }

  void adhered_cell_pimpl::
  _reset ()
  {
    adhered_cell_pskel::_reset ();

    if (!this->adhered_cell_pimpl_base_ && this->adhered_cell_pimpl_state_.adhered_cell_)
    {
      delete this->adhered_cell_pimpl_state_.adhered_cell_;
      this->adhered_cell_pimpl_state_.adhered_cell_ = 0;
    }
  }

  void adhered_cell_pimpl::
  pre_impl (::state::adhered_cell* x)
  {
    this->adhered_cell_pimpl_state_.adhered_cell_ = x;
  }

  void adhered_cell_pimpl::
  pre ()
  {
    ::state::adhered_cell* x = new ::state::adhered_cell;
    this->pre_impl (x);
  }

  void adhered_cell_pimpl::
  ID (unsigned int x)
  {
    this->adhered_cell_pimpl_state_.adhered_cell_->ID (x);
  }

  void adhered_cell_pimpl::
  contact_area (::common::units_decimal_nonnegative* x)
  {
    this->adhered_cell_pimpl_state_.adhered_cell_->contact_area (x);
  }

  void adhered_cell_pimpl::
  contact (::phenotype_common::cross_section* x)
  {
    this->adhered_cell_pimpl_state_.adhered_cell_->contact (x);
  }

  void adhered_cell_pimpl::
  custom (::common::custom* x)
  {
    this->adhered_cell_pimpl_state_.adhered_cell_->custom (x);
  }

  ::state::adhered_cell* adhered_cell_pimpl::
  post_adhered_cell ()
  {
    ::state::adhered_cell* r = this->adhered_cell_pimpl_state_.adhered_cell_;
    this->adhered_cell_pimpl_state_.adhered_cell_ = 0;
    return r;
  }

  // list_of_adhered_cells_pimpl
  //

  list_of_adhered_cells_pimpl::
  list_of_adhered_cells_pimpl (bool b)
  {
    this->list_of_adhered_cells_pimpl_base_ = b;
    this->list_of_adhered_cells_pimpl_state_.list_of_adhered_cells_ = 0;
  }

  list_of_adhered_cells_pimpl::
  ~list_of_adhered_cells_pimpl ()
  {
    if (!this->list_of_adhered_cells_pimpl_base_ && this->list_of_adhered_cells_pimpl_state_.list_of_adhered_cells_)
      delete this->list_of_adhered_cells_pimpl_state_.list_of_adhered_cells_;
  }

  void list_of_adhered_cells_pimpl::
  _reset ()
  {
    list_of_adhered_cells_pskel::_reset ();

    if (!this->list_of_adhered_cells_pimpl_base_ && this->list_of_adhered_cells_pimpl_state_.list_of_adhered_cells_)
    {
      delete this->list_of_adhered_cells_pimpl_state_.list_of_adhered_cells_;
      this->list_of_adhered_cells_pimpl_state_.list_of_adhered_cells_ = 0;
    }
  }

  void list_of_adhered_cells_pimpl::
  pre_impl (::state::list_of_adhered_cells* x)
  {
    this->list_of_adhered_cells_pimpl_state_.list_of_adhered_cells_ = x;
  }

  void list_of_adhered_cells_pimpl::
  pre ()
  {
    ::state::list_of_adhered_cells* x = new ::state::list_of_adhered_cells;
    this->pre_impl (x);
  }

  void list_of_adhered_cells_pimpl::
  adhered_cell (::state::adhered_cell* x)
  {
    this->list_of_adhered_cells_pimpl_state_.list_of_adhered_cells_->adhered_cell ().push_back (x);
  }

  void list_of_adhered_cells_pimpl::
  custom (::common::custom* x)
  {
    this->list_of_adhered_cells_pimpl_state_.list_of_adhered_cells_->custom (x);
  }

  ::state::list_of_adhered_cells* list_of_adhered_cells_pimpl::
  post_list_of_adhered_cells ()
  {
    ::state::list_of_adhered_cells* r = this->list_of_adhered_cells_pimpl_state_.list_of_adhered_cells_;
    this->list_of_adhered_cells_pimpl_state_.list_of_adhered_cells_ = 0;
    return r;
  }
}

// Begin epilogue.
//
//
// End epilogue.

