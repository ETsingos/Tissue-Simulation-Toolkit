// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "common-pimpl.hpp"

#include <xsde/cxx/parser/validating/string-common.hxx>

namespace common
{
  // custom_base_pimpl
  //

  custom_base_pimpl::
  custom_base_pimpl (bool b)
  {
    this->custom_base_pimpl_base_ = b;
    this->custom_base_pimpl_state_.custom_ = 0;
  }

  custom_base_pimpl::
  ~custom_base_pimpl ()
  {
    if (!this->custom_base_pimpl_base_ && this->custom_base_pimpl_state_.custom_)
      delete this->custom_base_pimpl_state_.custom_;
  }

  void custom_base_pimpl::
  _reset ()
  {
    custom_pskel::_reset ();

    if (!this->custom_base_pimpl_base_ && this->custom_base_pimpl_state_.custom_)
    {
      delete this->custom_base_pimpl_state_.custom_;
      this->custom_base_pimpl_state_.custom_ = 0;
    }
  }

  void custom_base_pimpl::
  pre_impl (::common::custom* x)
  {
    this->custom_base_pimpl_state_.custom_ = x;
  }

  void custom_base_pimpl::
  pre ()
  {
    ::common::custom* x = new ::common::custom;
    this->pre_impl (x);
  }

  ::common::custom* custom_base_pimpl::
  post_custom ()
  {
    ::common::custom* r = this->custom_base_pimpl_state_.custom_;
    this->custom_base_pimpl_state_.custom_ = 0;
    return r;
  }

  // double_list_pimpl
  //

  double_list_pimpl::
  double_list_pimpl (bool b)
  {
    this->double_list_pimpl_base_ = b;
    this->double_list_ = 0;
  }

  double_list_pimpl::
  ~double_list_pimpl ()
  {
    if (!this->double_list_pimpl_base_ && this->double_list_)
      delete this->double_list_;
  }

  void double_list_pimpl::
  _reset ()
  {
    double_list_pskel::_reset ();

    if (!this->double_list_pimpl_base_ && this->double_list_)
    {
      delete this->double_list_;
      this->double_list_ = 0;
    }
  }

  void double_list_pimpl::
  pre_impl (::common::double_list* x)
  {
    this->double_list_ = x;
  }

  void double_list_pimpl::
  pre ()
  {
    ::common::double_list* x = new ::common::double_list;
    this->pre_impl (x);
  }

  void double_list_pimpl::
  item (double i)
  {
    this->double_list_->push_back (i);
  }

  ::common::double_list* double_list_pimpl::
  post_double_list ()
  {
    ::common::double_list* r = this->double_list_;
    this->double_list_ = 0;
    return r;
  }

  // unsigned_int_list_pimpl
  //

  unsigned_int_list_pimpl::
  unsigned_int_list_pimpl (bool b)
  {
    this->unsigned_int_list_pimpl_base_ = b;
    this->unsigned_int_list_ = 0;
  }

  unsigned_int_list_pimpl::
  ~unsigned_int_list_pimpl ()
  {
    if (!this->unsigned_int_list_pimpl_base_ && this->unsigned_int_list_)
      delete this->unsigned_int_list_;
  }

  void unsigned_int_list_pimpl::
  _reset ()
  {
    unsigned_int_list_pskel::_reset ();

    if (!this->unsigned_int_list_pimpl_base_ && this->unsigned_int_list_)
    {
      delete this->unsigned_int_list_;
      this->unsigned_int_list_ = 0;
    }
  }

  void unsigned_int_list_pimpl::
  pre_impl (::common::unsigned_int_list* x)
  {
    this->unsigned_int_list_ = x;
  }

  void unsigned_int_list_pimpl::
  pre ()
  {
    ::common::unsigned_int_list* x = new ::common::unsigned_int_list;
    this->pre_impl (x);
  }

  void unsigned_int_list_pimpl::
  item (unsigned int i)
  {
    this->unsigned_int_list_->push_back (i);
  }

  ::common::unsigned_int_list* unsigned_int_list_pimpl::
  post_unsigned_int_list ()
  {
    ::common::unsigned_int_list* r = this->unsigned_int_list_;
    this->unsigned_int_list_ = 0;
    return r;
  }

  // two_doubles_pimpl
  //

  two_doubles_pimpl::
  two_doubles_pimpl (bool b)
  : two_doubles_pskel (&base_impl_),
    base_impl_ (true)
  {
    this->two_doubles_pimpl_base_ = b;
    this->two_doubles_pimpl_state_.two_doubles_ = 0;
  }

  two_doubles_pimpl::
  ~two_doubles_pimpl ()
  {
    if (!this->two_doubles_pimpl_base_ && this->two_doubles_pimpl_state_.two_doubles_)
      delete this->two_doubles_pimpl_state_.two_doubles_;
  }

  void two_doubles_pimpl::
  _reset ()
  {
    two_doubles_pskel::_reset ();

    if (!this->two_doubles_pimpl_base_ && this->two_doubles_pimpl_state_.two_doubles_)
    {
      delete this->two_doubles_pimpl_state_.two_doubles_;
      this->two_doubles_pimpl_state_.two_doubles_ = 0;
    }
  }

  void two_doubles_pimpl::
  pre_impl (::common::two_doubles* x)
  {
    this->two_doubles_pimpl_state_.two_doubles_ = x;
    this->base_impl_.pre_impl (x);
  }

  void two_doubles_pimpl::
  pre ()
  {
    ::common::two_doubles* x = new ::common::two_doubles;
    this->pre_impl (x);
  }

  ::common::two_doubles* two_doubles_pimpl::
  post_two_doubles ()
  {
    this->base_impl_.post_double_list ();
    ::common::two_doubles* r = this->two_doubles_pimpl_state_.two_doubles_;
    this->two_doubles_pimpl_state_.two_doubles_ = 0;
    return r;
  }

  // units_double_list_pimpl
  //

  units_double_list_pimpl::
  units_double_list_pimpl (bool b)
  : units_double_list_pskel (&base_impl_),
    base_impl_ (true)
  {
    this->units_double_list_pimpl_base_ = b;
    this->units_double_list_pimpl_state_.units_double_list_ = 0;
  }

  units_double_list_pimpl::
  ~units_double_list_pimpl ()
  {
    if (!this->units_double_list_pimpl_base_ && this->units_double_list_pimpl_state_.units_double_list_)
      delete this->units_double_list_pimpl_state_.units_double_list_;
  }

  void units_double_list_pimpl::
  _reset ()
  {
    units_double_list_pskel::_reset ();

    if (!this->units_double_list_pimpl_base_ && this->units_double_list_pimpl_state_.units_double_list_)
    {
      delete this->units_double_list_pimpl_state_.units_double_list_;
      this->units_double_list_pimpl_state_.units_double_list_ = 0;
    }
  }

  void units_double_list_pimpl::
  pre_impl (::common::units_double_list* x)
  {
    this->units_double_list_pimpl_state_.units_double_list_ = x;
    this->base_impl_.pre_impl (x);
  }

  void units_double_list_pimpl::
  pre ()
  {
    ::common::units_double_list* x = new ::common::units_double_list;
    this->pre_impl (x);
  }

  void units_double_list_pimpl::
  units (const ::std::string& x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->units (x);
  }

  void units_double_list_pimpl::
  measurement_type (const ::std::string& x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->measurement_type (x);
  }

  void units_double_list_pimpl::
  uncertainty (double x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->uncertainty (x);
  }

  void units_double_list_pimpl::
  negative_uncertainty (double x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->negative_uncertainty (x);
  }

  void units_double_list_pimpl::
  positive_uncertainty (double x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->positive_uncertainty (x);
  }

  void units_double_list_pimpl::
  uncertainty_percentage (double x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->uncertainty_percentage (x);
  }

  void units_double_list_pimpl::
  negative_uncertainty_percentage (double x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->negative_uncertainty_percentage (x);
  }

  void units_double_list_pimpl::
  positive_uncertainty_percentage (double x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->positive_uncertainty_percentage (x);
  }

  void units_double_list_pimpl::
  median (double x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->median (x);
  }

  void units_double_list_pimpl::
  standard_deviation (double x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->standard_deviation (x);
  }

  void units_double_list_pimpl::
  interquartile_range (::common::two_doubles* x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->interquartile_range (x);
  }

  void units_double_list_pimpl::
  range (::common::two_doubles* x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->range (x);
  }

  void units_double_list_pimpl::
  min (double x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->min (x);
  }

  void units_double_list_pimpl::
  max (double x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->max (x);
  }

  void units_double_list_pimpl::
  standard_error (double x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->standard_error (x);
  }

  void units_double_list_pimpl::
  standard_error_of_the_mean (double x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->standard_error_of_the_mean (x);
  }

  void units_double_list_pimpl::
  number_obs (int x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->number_obs (x);
  }

  void units_double_list_pimpl::
  skewnesss (double x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->skewnesss (x);
  }

  void units_double_list_pimpl::
  kurtosis (double x)
  {
    this->units_double_list_pimpl_state_.units_double_list_->kurtosis (x);
  }

  ::common::units_double_list* units_double_list_pimpl::
  post_units_double_list ()
  {
    this->base_impl_.post_double_list ();
    ::common::units_double_list* r = this->units_double_list_pimpl_state_.units_double_list_;
    this->units_double_list_pimpl_state_.units_double_list_ = 0;
    return r;
  }

  // delimited_list_pimpl
  //

  delimited_list_pimpl::
  delimited_list_pimpl ()
  : delimited_list_pskel (&base_impl_)
  {
  }

  void delimited_list_pimpl::
  pre ()
  {
    this->base_impl_.pre ();
    this->delimited_list_pimpl_state_.delimited_list_ = ::common::delimited_list ();
  }

  void delimited_list_pimpl::
  delimiter (const ::std::string& x)
  {
    this->delimited_list_pimpl_state_.delimited_list_.delimiter (x);
  }

  ::common::delimited_list delimited_list_pimpl::
  post_delimited_list ()
  {
    static_cast< ::std::string& > (this->delimited_list_pimpl_state_.delimited_list_) = 
    this->base_impl_.post_string ();
    return this->delimited_list_pimpl_state_.delimited_list_;
  }

  // units_delimited_list_pimpl
  //

  units_delimited_list_pimpl::
  units_delimited_list_pimpl (bool b)
  : units_delimited_list_pskel (&base_impl_)
  {
    this->units_delimited_list_pimpl_base_ = b;
    this->units_delimited_list_pimpl_state_.units_delimited_list_ = 0;
  }

  units_delimited_list_pimpl::
  ~units_delimited_list_pimpl ()
  {
    if (!this->units_delimited_list_pimpl_base_ && this->units_delimited_list_pimpl_state_.units_delimited_list_)
      delete this->units_delimited_list_pimpl_state_.units_delimited_list_;
  }

  void units_delimited_list_pimpl::
  _reset ()
  {
    units_delimited_list_pskel::_reset ();

    if (!this->units_delimited_list_pimpl_base_ && this->units_delimited_list_pimpl_state_.units_delimited_list_)
    {
      delete this->units_delimited_list_pimpl_state_.units_delimited_list_;
      this->units_delimited_list_pimpl_state_.units_delimited_list_ = 0;
    }
  }

  void units_delimited_list_pimpl::
  pre_impl (::common::units_delimited_list* x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_ = x;
    this->base_impl_.pre ();
  }

  void units_delimited_list_pimpl::
  pre ()
  {
    ::common::units_delimited_list* x = new ::common::units_delimited_list;
    this->pre_impl (x);
  }

  void units_delimited_list_pimpl::
  units (const ::std::string& x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->units (x);
  }

  void units_delimited_list_pimpl::
  measurement_type (const ::std::string& x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->measurement_type (x);
  }

  void units_delimited_list_pimpl::
  uncertainty (double x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->uncertainty (x);
  }

  void units_delimited_list_pimpl::
  negative_uncertainty (double x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->negative_uncertainty (x);
  }

  void units_delimited_list_pimpl::
  positive_uncertainty (double x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->positive_uncertainty (x);
  }

  void units_delimited_list_pimpl::
  uncertainty_percentage (double x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->uncertainty_percentage (x);
  }

  void units_delimited_list_pimpl::
  negative_uncertainty_percentage (double x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->negative_uncertainty_percentage (x);
  }

  void units_delimited_list_pimpl::
  positive_uncertainty_percentage (double x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->positive_uncertainty_percentage (x);
  }

  void units_delimited_list_pimpl::
  median (double x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->median (x);
  }

  void units_delimited_list_pimpl::
  standard_deviation (double x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->standard_deviation (x);
  }

  void units_delimited_list_pimpl::
  interquartile_range (::common::two_doubles* x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->interquartile_range (x);
  }

  void units_delimited_list_pimpl::
  range (::common::two_doubles* x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->range (x);
  }

  void units_delimited_list_pimpl::
  min (double x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->min (x);
  }

  void units_delimited_list_pimpl::
  max (double x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->max (x);
  }

  void units_delimited_list_pimpl::
  standard_error (double x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->standard_error (x);
  }

  void units_delimited_list_pimpl::
  standard_error_of_the_mean (double x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->standard_error_of_the_mean (x);
  }

  void units_delimited_list_pimpl::
  number_obs (int x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->number_obs (x);
  }

  void units_delimited_list_pimpl::
  skewnesss (double x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->skewnesss (x);
  }

  void units_delimited_list_pimpl::
  kurtosis (double x)
  {
    this->units_delimited_list_pimpl_state_.units_delimited_list_->kurtosis (x);
  }

  ::common::units_delimited_list* units_delimited_list_pimpl::
  post_units_delimited_list ()
  {
    static_cast< ::common::delimited_list& > (*this->units_delimited_list_pimpl_state_.units_delimited_list_) = 
    this->base_impl_.post_delimited_list ();
    ::common::units_delimited_list* r = this->units_delimited_list_pimpl_state_.units_delimited_list_;
    this->units_delimited_list_pimpl_state_.units_delimited_list_ = 0;
    return r;
  }

  // units_decimal_pimpl
  //

  units_decimal_pimpl::
  units_decimal_pimpl (bool b)
  : units_decimal_pskel (&base_impl_)
  {
    this->units_decimal_pimpl_base_ = b;
    this->units_decimal_pimpl_state_.units_decimal_ = 0;
  }

  units_decimal_pimpl::
  ~units_decimal_pimpl ()
  {
    if (!this->units_decimal_pimpl_base_ && this->units_decimal_pimpl_state_.units_decimal_)
      delete this->units_decimal_pimpl_state_.units_decimal_;
  }

  void units_decimal_pimpl::
  _reset ()
  {
    units_decimal_pskel::_reset ();

    if (!this->units_decimal_pimpl_base_ && this->units_decimal_pimpl_state_.units_decimal_)
    {
      delete this->units_decimal_pimpl_state_.units_decimal_;
      this->units_decimal_pimpl_state_.units_decimal_ = 0;
    }
  }

  void units_decimal_pimpl::
  pre_impl (::common::units_decimal* x)
  {
    this->units_decimal_pimpl_state_.units_decimal_ = x;
    this->base_impl_.pre ();
  }

  void units_decimal_pimpl::
  pre ()
  {
    ::common::units_decimal* x = new ::common::units_decimal;
    this->pre_impl (x);
  }

  void units_decimal_pimpl::
  units (const ::std::string& x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->units (x);
  }

  void units_decimal_pimpl::
  measurement_type (const ::std::string& x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->measurement_type (x);
  }

  void units_decimal_pimpl::
  uncertainty (double x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->uncertainty (x);
  }

  void units_decimal_pimpl::
  negative_uncertainty (double x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->negative_uncertainty (x);
  }

  void units_decimal_pimpl::
  positive_uncertainty (double x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->positive_uncertainty (x);
  }

  void units_decimal_pimpl::
  uncertainty_percentage (double x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->uncertainty_percentage (x);
  }

  void units_decimal_pimpl::
  negative_uncertainty_percentage (double x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->negative_uncertainty_percentage (x);
  }

  void units_decimal_pimpl::
  positive_uncertainty_percentage (double x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->positive_uncertainty_percentage (x);
  }

  void units_decimal_pimpl::
  median (double x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->median (x);
  }

  void units_decimal_pimpl::
  standard_deviation (double x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->standard_deviation (x);
  }

  void units_decimal_pimpl::
  interquartile_range (::common::two_doubles* x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->interquartile_range (x);
  }

  void units_decimal_pimpl::
  range (::common::two_doubles* x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->range (x);
  }

  void units_decimal_pimpl::
  min (double x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->min (x);
  }

  void units_decimal_pimpl::
  max (double x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->max (x);
  }

  void units_decimal_pimpl::
  standard_error (double x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->standard_error (x);
  }

  void units_decimal_pimpl::
  standard_error_of_the_mean (double x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->standard_error_of_the_mean (x);
  }

  void units_decimal_pimpl::
  number_obs (int x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->number_obs (x);
  }

  void units_decimal_pimpl::
  skewnesss (double x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->skewnesss (x);
  }

  void units_decimal_pimpl::
  kurtosis (double x)
  {
    this->units_decimal_pimpl_state_.units_decimal_->kurtosis (x);
  }

  ::common::units_decimal* units_decimal_pimpl::
  post_units_decimal ()
  {
    static_cast< ::xml_schema::double_base& > (*this->units_decimal_pimpl_state_.units_decimal_) = 
    this->base_impl_.post_double ();
    ::common::units_decimal* r = this->units_decimal_pimpl_state_.units_decimal_;
    this->units_decimal_pimpl_state_.units_decimal_ = 0;
    return r;
  }

  // units_decimal_nonnegative_pimpl
  //

  units_decimal_nonnegative_pimpl::
  units_decimal_nonnegative_pimpl (bool b)
  : units_decimal_nonnegative_pskel (&base_impl_),
    base_impl_ (true)
  {
    this->units_decimal_nonnegative_pimpl_base_ = b;
    this->units_decimal_nonnegative_pimpl_state_.units_decimal_nonnegative_ = 0;
  }

  units_decimal_nonnegative_pimpl::
  ~units_decimal_nonnegative_pimpl ()
  {
    if (!this->units_decimal_nonnegative_pimpl_base_ && this->units_decimal_nonnegative_pimpl_state_.units_decimal_nonnegative_)
      delete this->units_decimal_nonnegative_pimpl_state_.units_decimal_nonnegative_;
  }

  void units_decimal_nonnegative_pimpl::
  _reset ()
  {
    units_decimal_nonnegative_pskel::_reset ();

    if (!this->units_decimal_nonnegative_pimpl_base_ && this->units_decimal_nonnegative_pimpl_state_.units_decimal_nonnegative_)
    {
      delete this->units_decimal_nonnegative_pimpl_state_.units_decimal_nonnegative_;
      this->units_decimal_nonnegative_pimpl_state_.units_decimal_nonnegative_ = 0;
    }
  }

  void units_decimal_nonnegative_pimpl::
  pre_impl (::common::units_decimal_nonnegative* x)
  {
    this->units_decimal_nonnegative_pimpl_state_.units_decimal_nonnegative_ = x;
    this->base_impl_.pre_impl (x);
  }

  void units_decimal_nonnegative_pimpl::
  pre ()
  {
    ::common::units_decimal_nonnegative* x = new ::common::units_decimal_nonnegative;
    this->pre_impl (x);
  }

  ::common::units_decimal_nonnegative* units_decimal_nonnegative_pimpl::
  post_units_decimal_nonnegative ()
  {
    this->base_impl_.post_units_decimal ();
    ::common::units_decimal_nonnegative* r = this->units_decimal_nonnegative_pimpl_state_.units_decimal_nonnegative_;
    this->units_decimal_nonnegative_pimpl_state_.units_decimal_nonnegative_ = 0;
    return r;
  }

  // units_unsignedShort_pimpl
  //

  units_unsignedShort_pimpl::
  units_unsignedShort_pimpl ()
  : units_unsignedShort_pskel (&base_impl_)
  {
  }

  void units_unsignedShort_pimpl::
  pre ()
  {
    this->base_impl_.pre ();
    this->units_unsignedShort_pimpl_state_.units_unsignedShort_ = ::common::units_unsignedShort ();
  }

  void units_unsignedShort_pimpl::
  measurement_type (const ::std::string& x)
  {
    this->units_unsignedShort_pimpl_state_.units_unsignedShort_.measurement_type (x);
  }

  void units_unsignedShort_pimpl::
  units (const ::std::string& x)
  {
    this->units_unsignedShort_pimpl_state_.units_unsignedShort_.units (x);
  }

  ::common::units_unsignedShort units_unsignedShort_pimpl::
  post_units_unsignedShort ()
  {
    static_cast< ::xml_schema::unsigned_short_base& > (this->units_unsignedShort_pimpl_state_.units_unsignedShort_) = 
    this->base_impl_.post_unsigned_short ();
    return this->units_unsignedShort_pimpl_state_.units_unsignedShort_;
  }

  // units_boolean_pimpl
  //

  units_boolean_pimpl::
  units_boolean_pimpl ()
  : units_boolean_pskel (&base_impl_)
  {
  }

  void units_boolean_pimpl::
  pre ()
  {
    this->base_impl_.pre ();
    this->units_boolean_pimpl_state_.units_boolean_ = ::common::units_boolean ();
  }

  void units_boolean_pimpl::
  units (const ::std::string& x)
  {
    this->units_boolean_pimpl_state_.units_boolean_.units (x);
  }

  ::common::units_boolean units_boolean_pimpl::
  post_units_boolean ()
  {
    static_cast< ::xml_schema::boolean_base& > (this->units_boolean_pimpl_state_.units_boolean_) = 
    this->base_impl_.post_boolean ();
    return this->units_boolean_pimpl_state_.units_boolean_;
  }

  // fraction_pimpl
  //

  fraction_pimpl::
  fraction_pimpl ()
  : fraction_pskel (&base_impl_)
  {
  }

  void fraction_pimpl::
  pre ()
  {
    this->base_impl_.pre ();
    this->fraction_pimpl_state_.fraction_ = ::common::fraction ();
  }

  ::common::fraction fraction_pimpl::
  post_fraction ()
  {
    static_cast< ::xml_schema::double_base& > (this->fraction_pimpl_state_.fraction_) = 
    this->base_impl_.post_double ();
    return this->fraction_pimpl_state_.fraction_;
  }

  // units_fraction_pimpl
  //

  units_fraction_pimpl::
  units_fraction_pimpl (bool b)
  : units_fraction_pskel (&base_impl_),
    base_impl_ (true)
  {
    this->units_fraction_pimpl_base_ = b;
    this->units_fraction_pimpl_state_.units_fraction_ = 0;
  }

  units_fraction_pimpl::
  ~units_fraction_pimpl ()
  {
    if (!this->units_fraction_pimpl_base_ && this->units_fraction_pimpl_state_.units_fraction_)
      delete this->units_fraction_pimpl_state_.units_fraction_;
  }

  void units_fraction_pimpl::
  _reset ()
  {
    units_fraction_pskel::_reset ();

    if (!this->units_fraction_pimpl_base_ && this->units_fraction_pimpl_state_.units_fraction_)
    {
      delete this->units_fraction_pimpl_state_.units_fraction_;
      this->units_fraction_pimpl_state_.units_fraction_ = 0;
    }
  }

  void units_fraction_pimpl::
  pre_impl (::common::units_fraction* x)
  {
    this->units_fraction_pimpl_state_.units_fraction_ = x;
    this->base_impl_.pre_impl (x);
  }

  void units_fraction_pimpl::
  pre ()
  {
    ::common::units_fraction* x = new ::common::units_fraction;
    this->pre_impl (x);
  }

  ::common::units_fraction* units_fraction_pimpl::
  post_units_fraction ()
  {
    this->base_impl_.post_units_decimal ();
    ::common::units_fraction* r = this->units_fraction_pimpl_state_.units_fraction_;
    this->units_fraction_pimpl_state_.units_fraction_ = 0;
    return r;
  }

  // units_string_pimpl
  //

  units_string_pimpl::
  units_string_pimpl (bool b)
  : units_string_pskel (&base_impl_)
  {
    this->units_string_pimpl_base_ = b;
    this->units_string_pimpl_state_.units_string_ = 0;
  }

  units_string_pimpl::
  ~units_string_pimpl ()
  {
    if (!this->units_string_pimpl_base_ && this->units_string_pimpl_state_.units_string_)
      delete this->units_string_pimpl_state_.units_string_;
  }

  void units_string_pimpl::
  _reset ()
  {
    units_string_pskel::_reset ();

    if (!this->units_string_pimpl_base_ && this->units_string_pimpl_state_.units_string_)
    {
      delete this->units_string_pimpl_state_.units_string_;
      this->units_string_pimpl_state_.units_string_ = 0;
    }
  }

  void units_string_pimpl::
  pre_impl (::common::units_string* x)
  {
    this->units_string_pimpl_state_.units_string_ = x;
    this->base_impl_.pre ();
  }

  void units_string_pimpl::
  pre ()
  {
    ::common::units_string* x = new ::common::units_string;
    this->pre_impl (x);
  }

  void units_string_pimpl::
  units (const ::std::string& x)
  {
    this->units_string_pimpl_state_.units_string_->units (x);
  }

  void units_string_pimpl::
  measurement_type (const ::std::string& x)
  {
    this->units_string_pimpl_state_.units_string_->measurement_type (x);
  }

  void units_string_pimpl::
  uncertainty (double x)
  {
    this->units_string_pimpl_state_.units_string_->uncertainty (x);
  }

  void units_string_pimpl::
  negative_uncertainty (double x)
  {
    this->units_string_pimpl_state_.units_string_->negative_uncertainty (x);
  }

  void units_string_pimpl::
  positive_uncertainty (double x)
  {
    this->units_string_pimpl_state_.units_string_->positive_uncertainty (x);
  }

  void units_string_pimpl::
  uncertainty_percentage (double x)
  {
    this->units_string_pimpl_state_.units_string_->uncertainty_percentage (x);
  }

  void units_string_pimpl::
  negative_uncertainty_percentage (double x)
  {
    this->units_string_pimpl_state_.units_string_->negative_uncertainty_percentage (x);
  }

  void units_string_pimpl::
  positive_uncertainty_percentage (double x)
  {
    this->units_string_pimpl_state_.units_string_->positive_uncertainty_percentage (x);
  }

  void units_string_pimpl::
  median (double x)
  {
    this->units_string_pimpl_state_.units_string_->median (x);
  }

  void units_string_pimpl::
  standard_deviation (double x)
  {
    this->units_string_pimpl_state_.units_string_->standard_deviation (x);
  }

  void units_string_pimpl::
  interquartile_range (::common::two_doubles* x)
  {
    this->units_string_pimpl_state_.units_string_->interquartile_range (x);
  }

  void units_string_pimpl::
  range (::common::two_doubles* x)
  {
    this->units_string_pimpl_state_.units_string_->range (x);
  }

  void units_string_pimpl::
  min (double x)
  {
    this->units_string_pimpl_state_.units_string_->min (x);
  }

  void units_string_pimpl::
  max (double x)
  {
    this->units_string_pimpl_state_.units_string_->max (x);
  }

  void units_string_pimpl::
  standard_error (double x)
  {
    this->units_string_pimpl_state_.units_string_->standard_error (x);
  }

  void units_string_pimpl::
  standard_error_of_the_mean (double x)
  {
    this->units_string_pimpl_state_.units_string_->standard_error_of_the_mean (x);
  }

  void units_string_pimpl::
  number_obs (int x)
  {
    this->units_string_pimpl_state_.units_string_->number_obs (x);
  }

  void units_string_pimpl::
  skewnesss (double x)
  {
    this->units_string_pimpl_state_.units_string_->skewnesss (x);
  }

  void units_string_pimpl::
  kurtosis (double x)
  {
    this->units_string_pimpl_state_.units_string_->kurtosis (x);
  }

  ::common::units_string* units_string_pimpl::
  post_units_string ()
  {
    static_cast< ::std::string& > (*this->units_string_pimpl_state_.units_string_) = 
    this->base_impl_.post_string ();
    ::common::units_string* r = this->units_string_pimpl_state_.units_string_;
    this->units_string_pimpl_state_.units_string_ = 0;
    return r;
  }

  // data_storage_formats_pimpl
  //

  data_storage_formats_pimpl::
  data_storage_formats_pimpl ()
  : data_storage_formats_pskel (0)
  {
  }

  void data_storage_formats_pimpl::
  pre ()
  {
    this->data_storage_formats_pimpl_state_.str_.clear ();
  }

  void data_storage_formats_pimpl::
  _characters (const ::xsde::cxx::ro_string& s)
  {
    if (this->_facets ().whitespace_ == 2 &&
        this->data_storage_formats_pimpl_state_.str_.size () == 0)
    {
      ::xsde::cxx::ro_string tmp (s.data (), s.size ());

      if (::xsde::cxx::trim_left (tmp) != 0)
      {
        this->data_storage_formats_pimpl_state_.str_ += tmp;
      }
    }
    else
      this->data_storage_formats_pimpl_state_.str_ += s;
  }

  void data_storage_formats_pimpl::
  _post ()
  {
    ::xsde::cxx::parser::validating::string_common::validate_facets (
      this->data_storage_formats_pimpl_state_.str_,
      this->_facets (),
      this->_context ());
  }

  ::common::data_storage_formats data_storage_formats_pimpl::
  post_data_storage_formats ()
  {
    ::common::data_storage_formats::value_type v =
    static_cast< ::common::data_storage_formats::value_type > (0);
    const char* s = this->data_storage_formats_pimpl_state_.str_.c_str ();

    if (strcmp (s, "xml") == 0)
      v = ::common::data_storage_formats::xml;
    else if (strcmp (s, "XML") == 0)
      v = ::common::data_storage_formats::XML;
    else if (strcmp (s, "matlab") == 0)
      v = ::common::data_storage_formats::matlab;
    else if (strcmp (s, "Matlab") == 0)
      v = ::common::data_storage_formats::Matlab;
    else if (strcmp (s, "MATLAB") == 0)
      v = ::common::data_storage_formats::MATLAB;
    else if (strcmp (s, "hdf5") == 0)
      v = ::common::data_storage_formats::hdf5;
    else if (strcmp (s, "HDF5") == 0)
      v = ::common::data_storage_formats::HDF5;

    ::common::data_storage_formats r (v);
    return r;
  }

  // threshold_type_pimpl
  //

  threshold_type_pimpl::
  threshold_type_pimpl ()
  : threshold_type_pskel (0)
  {
  }

  void threshold_type_pimpl::
  pre ()
  {
    this->threshold_type_pimpl_state_.str_.clear ();
  }

  void threshold_type_pimpl::
  _characters (const ::xsde::cxx::ro_string& s)
  {
    if (this->_facets ().whitespace_ == 2 &&
        this->threshold_type_pimpl_state_.str_.size () == 0)
    {
      ::xsde::cxx::ro_string tmp (s.data (), s.size ());

      if (::xsde::cxx::trim_left (tmp) != 0)
      {
        this->threshold_type_pimpl_state_.str_ += tmp;
      }
    }
    else
      this->threshold_type_pimpl_state_.str_ += s;
  }

  void threshold_type_pimpl::
  _post ()
  {
    ::xsde::cxx::parser::validating::string_common::validate_facets (
      this->threshold_type_pimpl_state_.str_,
      this->_facets (),
      this->_context ());
  }

  ::common::threshold_type threshold_type_pimpl::
  post_threshold_type ()
  {
    ::common::threshold_type::value_type v =
    static_cast< ::common::threshold_type::value_type > (0);
    const char* s = this->threshold_type_pimpl_state_.str_.c_str ();

    if (strcmp (s, "positive") == 0)
      v = ::common::threshold_type::positive;
    else if (strcmp (s, "non_positive") == 0)
      v = ::common::threshold_type::non_positive;
    else if (strcmp (s, "negative") == 0)
      v = ::common::threshold_type::negative;
    else if (strcmp (s, "non_negative") == 0)
      v = ::common::threshold_type::non_negative;
    else if (strcmp (s, "lower_bound") == 0)
      v = ::common::threshold_type::lower_bound;
    else if (strcmp (s, "upper_bound") == 0)
      v = ::common::threshold_type::upper_bound;

    ::common::threshold_type r (v);
    return r;
  }

  // transition_threshold_pimpl
  //

  transition_threshold_pimpl::
  transition_threshold_pimpl (bool b)
  : transition_threshold_pskel (&base_impl_),
    base_impl_ (true)
  {
    this->transition_threshold_pimpl_base_ = b;
    this->transition_threshold_pimpl_state_.transition_threshold_ = 0;
  }

  transition_threshold_pimpl::
  ~transition_threshold_pimpl ()
  {
    if (!this->transition_threshold_pimpl_base_ && this->transition_threshold_pimpl_state_.transition_threshold_)
      delete this->transition_threshold_pimpl_state_.transition_threshold_;
  }

  void transition_threshold_pimpl::
  _reset ()
  {
    transition_threshold_pskel::_reset ();

    if (!this->transition_threshold_pimpl_base_ && this->transition_threshold_pimpl_state_.transition_threshold_)
    {
      delete this->transition_threshold_pimpl_state_.transition_threshold_;
      this->transition_threshold_pimpl_state_.transition_threshold_ = 0;
    }
  }

  void transition_threshold_pimpl::
  pre_impl (::common::transition_threshold* x)
  {
    this->transition_threshold_pimpl_state_.transition_threshold_ = x;
    this->base_impl_.pre_impl (x);
  }

  void transition_threshold_pimpl::
  pre ()
  {
    ::common::transition_threshold* x = new ::common::transition_threshold;
    this->pre_impl (x);
  }

  void transition_threshold_pimpl::
  quantity (const ::std::string& x)
  {
    this->transition_threshold_pimpl_state_.transition_threshold_->quantity (x);
  }

  void transition_threshold_pimpl::
  type (const ::common::threshold_type& x)
  {
    this->transition_threshold_pimpl_state_.transition_threshold_->type (x);
  }

  void transition_threshold_pimpl::
  variable_ID (unsigned long long x)
  {
    this->transition_threshold_pimpl_state_.transition_threshold_->variable_ID (x);
  }

  ::common::transition_threshold* transition_threshold_pimpl::
  post_transition_threshold ()
  {
    this->base_impl_.post_units_decimal ();
    ::common::transition_threshold* r = this->transition_threshold_pimpl_state_.transition_threshold_;
    this->transition_threshold_pimpl_state_.transition_threshold_ = 0;
    return r;
  }
}

// Begin epilogue.
//
//
// End epilogue.

