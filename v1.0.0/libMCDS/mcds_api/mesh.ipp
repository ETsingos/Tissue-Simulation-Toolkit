// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef MESH_IPP
#define MESH_IPP

// Begin prologue.
//
//
// End prologue.

#include "common.ipp"

namespace mesh
{
  // bounding_box
  //

  inline
  bool bounding_box::
  type_present () const
  {
    return this->type_present_;
  }

  inline
  void bounding_box::
  type_present (bool x)
  {
    this->type_present_ = x;
  }

  inline
  const ::std::string& bounding_box::
  type () const
  {
    return this->type_;
  }

  inline
  ::std::string& bounding_box::
  type ()
  {
    return this->type_;
  }

  inline
  void bounding_box::
  type (const ::std::string& x)
  {
    this->type_ = x;
    this->type_present_ = true;
  }

  // mesh
  //

  inline
  bool mesh::
  type_present () const
  {
    return this->type_present_;
  }

  inline
  void mesh::
  type_present (bool x)
  {
    this->type_present_ = x;
  }

  inline
  const ::std::string& mesh::
  type () const
  {
    return this->type_;
  }

  inline
  ::std::string& mesh::
  type ()
  {
    return this->type_;
  }

  inline
  void mesh::
  type (const ::std::string& x)
  {
    this->type_ = x;
    this->type_present_ = true;
  }

  inline
  bool mesh::
  uniform_present () const
  {
    return this->uniform_present_;
  }

  inline
  void mesh::
  uniform_present (bool x)
  {
    this->uniform_present_ = x;
  }

  inline
  bool mesh::
  uniform () const
  {
    return this->uniform_;
  }

  inline
  bool& mesh::
  uniform ()
  {
    return this->uniform_;
  }

  inline
  void mesh::
  uniform (bool x)
  {
    this->uniform_ = x;
    this->uniform_present_ = true;
  }

  inline
  bool mesh::
  regular_present () const
  {
    return this->regular_present_;
  }

  inline
  void mesh::
  regular_present (bool x)
  {
    this->regular_present_ = x;
  }

  inline
  bool mesh::
  regular () const
  {
    return this->regular_;
  }

  inline
  bool& mesh::
  regular ()
  {
    return this->regular_;
  }

  inline
  void mesh::
  regular (bool x)
  {
    this->regular_ = x;
    this->regular_present_ = true;
  }

  inline
  bool mesh::
  units_present () const
  {
    return this->units_present_;
  }

  inline
  void mesh::
  units_present (bool x)
  {
    this->units_present_ = x;
  }

  inline
  const ::std::string& mesh::
  units () const
  {
    return this->units_;
  }

  inline
  ::std::string& mesh::
  units ()
  {
    return this->units_;
  }

  inline
  void mesh::
  units (const ::std::string& x)
  {
    this->units_ = x;
    this->units_present_ = true;
  }

  inline
  bool mesh::
  bounding_box_present () const
  {
    return this->bounding_box_ != 0;
  }

  inline
  const ::mesh::bounding_box& mesh::
  bounding_box () const
  {
    return *this->bounding_box_;
  }

  inline
  ::mesh::bounding_box& mesh::
  bounding_box ()
  {
    return *this->bounding_box_;
  }

  inline
  void mesh::
  bounding_box (::mesh::bounding_box* x)
  {
    delete this->bounding_box_;
    this->bounding_box_ = x;
  }

  inline
  ::mesh::bounding_box* mesh::
  bounding_box_detach ()
  {
    ::mesh::bounding_box* r = this->bounding_box_;
    this->bounding_box_ = 0;
    return r;
  }

  inline
  bool mesh::
  x_coordinates_present () const
  {
    return this->x_coordinates_ != 0;
  }

  inline
  const ::common::units_double_list& mesh::
  x_coordinates () const
  {
    return *this->x_coordinates_;
  }

  inline
  ::common::units_double_list& mesh::
  x_coordinates ()
  {
    return *this->x_coordinates_;
  }

  inline
  void mesh::
  x_coordinates (::common::units_double_list* x)
  {
    delete this->x_coordinates_;
    this->x_coordinates_ = x;
  }

  inline
  ::common::units_double_list* mesh::
  x_coordinates_detach ()
  {
    ::common::units_double_list* r = this->x_coordinates_;
    this->x_coordinates_ = 0;
    return r;
  }

  inline
  bool mesh::
  y_coordinates_present () const
  {
    return this->y_coordinates_ != 0;
  }

  inline
  const ::common::units_double_list& mesh::
  y_coordinates () const
  {
    return *this->y_coordinates_;
  }

  inline
  ::common::units_double_list& mesh::
  y_coordinates ()
  {
    return *this->y_coordinates_;
  }

  inline
  void mesh::
  y_coordinates (::common::units_double_list* x)
  {
    delete this->y_coordinates_;
    this->y_coordinates_ = x;
  }

  inline
  ::common::units_double_list* mesh::
  y_coordinates_detach ()
  {
    ::common::units_double_list* r = this->y_coordinates_;
    this->y_coordinates_ = 0;
    return r;
  }

  inline
  bool mesh::
  z_coordinates_present () const
  {
    return this->z_coordinates_ != 0;
  }

  inline
  const ::common::units_double_list& mesh::
  z_coordinates () const
  {
    return *this->z_coordinates_;
  }

  inline
  ::common::units_double_list& mesh::
  z_coordinates ()
  {
    return *this->z_coordinates_;
  }

  inline
  void mesh::
  z_coordinates (::common::units_double_list* x)
  {
    delete this->z_coordinates_;
    this->z_coordinates_ = x;
  }

  inline
  ::common::units_double_list* mesh::
  z_coordinates_detach ()
  {
    ::common::units_double_list* r = this->z_coordinates_;
    this->z_coordinates_ = 0;
    return r;
  }

  inline
  bool mesh::
  voxels_present () const
  {
    return this->voxels_ != 0;
  }

  inline
  const ::mesh::list_of_voxels& mesh::
  voxels () const
  {
    return *this->voxels_;
  }

  inline
  ::mesh::list_of_voxels& mesh::
  voxels ()
  {
    return *this->voxels_;
  }

  inline
  void mesh::
  voxels (::mesh::list_of_voxels* x)
  {
    delete this->voxels_;
    this->voxels_ = x;
  }

  inline
  ::mesh::list_of_voxels* mesh::
  voxels_detach ()
  {
    ::mesh::list_of_voxels* r = this->voxels_;
    this->voxels_ = 0;
    return r;
  }

  inline
  bool mesh::
  custom_present () const
  {
    return this->custom_ != 0;
  }

  inline
  const ::common::custom& mesh::
  custom () const
  {
    return *this->custom_;
  }

  inline
  ::common::custom& mesh::
  custom ()
  {
    return *this->custom_;
  }

  inline
  void mesh::
  custom (::common::custom* x)
  {
    delete this->custom_;
    this->custom_ = x;
  }

  inline
  ::common::custom* mesh::
  custom_detach ()
  {
    ::common::custom* r = this->custom_;
    this->custom_ = 0;
    return r;
  }

  // list_of_voxels
  //

  inline
  bool list_of_voxels::
  type_present () const
  {
    return this->type_present_;
  }

  inline
  void list_of_voxels::
  type_present (bool x)
  {
    this->type_present_ = x;
  }

  inline
  const ::common::data_storage_formats& list_of_voxels::
  type () const
  {
    return this->type_;
  }

  inline
  ::common::data_storage_formats& list_of_voxels::
  type ()
  {
    return this->type_;
  }

  inline
  void list_of_voxels::
  type (const ::common::data_storage_formats& x)
  {
    this->type_ = x;
    this->type_present_ = true;
  }

  inline
  bool list_of_voxels::
  filename_present () const
  {
    return this->filename_present_;
  }

  inline
  void list_of_voxels::
  filename_present (bool x)
  {
    this->filename_present_ = x;
  }

  inline
  const ::std::string& list_of_voxels::
  filename () const
  {
    return this->filename_;
  }

  inline
  ::std::string& list_of_voxels::
  filename ()
  {
    return this->filename_;
  }

  inline
  void list_of_voxels::
  filename (const ::std::string& x)
  {
    this->filename_ = x;
    this->filename_present_ = true;
  }

  inline
  const list_of_voxels::voxel_sequence& list_of_voxels::
  voxel () const
  {
    return this->voxel_;
  }

  inline
  list_of_voxels::voxel_sequence& list_of_voxels::
  voxel ()
  {
    return this->voxel_;
  }

  inline
  bool list_of_voxels::
  custom_present () const
  {
    return this->custom_ != 0;
  }

  inline
  const ::common::custom& list_of_voxels::
  custom () const
  {
    return *this->custom_;
  }

  inline
  ::common::custom& list_of_voxels::
  custom ()
  {
    return *this->custom_;
  }

  inline
  void list_of_voxels::
  custom (::common::custom* x)
  {
    delete this->custom_;
    this->custom_ = x;
  }

  inline
  ::common::custom* list_of_voxels::
  custom_detach ()
  {
    ::common::custom* r = this->custom_;
    this->custom_ = 0;
    return r;
  }

  // voxel
  //

  inline
  bool voxel::
  ID_present () const
  {
    return this->ID_present_;
  }

  inline
  void voxel::
  ID_present (bool x)
  {
    this->ID_present_ = x;
  }

  inline
  unsigned int voxel::
  ID () const
  {
    return this->ID_;
  }

  inline
  unsigned int& voxel::
  ID ()
  {
    return this->ID_;
  }

  inline
  void voxel::
  ID (unsigned int x)
  {
    this->ID_ = x;
    this->ID_present_ = true;
  }

  inline
  bool voxel::
  type_present () const
  {
    return this->type_present_;
  }

  inline
  void voxel::
  type_present (bool x)
  {
    this->type_present_ = x;
  }

  inline
  const ::std::string& voxel::
  type () const
  {
    return this->type_;
  }

  inline
  ::std::string& voxel::
  type ()
  {
    return this->type_;
  }

  inline
  void voxel::
  type (const ::std::string& x)
  {
    this->type_ = x;
    this->type_present_ = true;
  }

  inline
  const ::common::units_double_list& voxel::
  center () const
  {
    return *this->center_;
  }

  inline
  ::common::units_double_list& voxel::
  center ()
  {
    return *this->center_;
  }

  inline
  void voxel::
  center (::common::units_double_list* x)
  {
    delete this->center_;
    this->center_ = x;
  }

  inline
  ::common::units_double_list* voxel::
  center_detach ()
  {
    ::common::units_double_list* r = this->center_;
    this->center_ = 0;
    return r;
  }

  inline
  const ::common::units_decimal_nonnegative& voxel::
  volume () const
  {
    return *this->volume_;
  }

  inline
  ::common::units_decimal_nonnegative& voxel::
  volume ()
  {
    return *this->volume_;
  }

  inline
  void voxel::
  volume (::common::units_decimal_nonnegative* x)
  {
    delete this->volume_;
    this->volume_ = x;
  }

  inline
  ::common::units_decimal_nonnegative* voxel::
  volume_detach ()
  {
    ::common::units_decimal_nonnegative* r = this->volume_;
    this->volume_ = 0;
    return r;
  }

  inline
  bool voxel::
  custom_present () const
  {
    return this->custom_ != 0;
  }

  inline
  const ::common::custom& voxel::
  custom () const
  {
    return *this->custom_;
  }

  inline
  ::common::custom& voxel::
  custom ()
  {
    return *this->custom_;
  }

  inline
  void voxel::
  custom (::common::custom* x)
  {
    delete this->custom_;
    this->custom_ = x;
  }

  inline
  ::common::custom* voxel::
  custom_detach ()
  {
    ::common::custom* r = this->custom_;
    this->custom_ = 0;
    return r;
  }

  // node
  //

  inline
  bool node::
  ID_present () const
  {
    return this->ID_present_;
  }

  inline
  void node::
  ID_present (bool x)
  {
    this->ID_present_ = x;
  }

  inline
  unsigned int node::
  ID () const
  {
    return this->ID_;
  }

  inline
  unsigned int& node::
  ID ()
  {
    return this->ID_;
  }

  inline
  void node::
  ID (unsigned int x)
  {
    this->ID_ = x;
    this->ID_present_ = true;
  }

  inline
  const ::common::units_double_list& node::
  position () const
  {
    return *this->position_;
  }

  inline
  ::common::units_double_list& node::
  position ()
  {
    return *this->position_;
  }

  inline
  void node::
  position (::common::units_double_list* x)
  {
    delete this->position_;
    this->position_ = x;
  }

  inline
  ::common::units_double_list* node::
  position_detach ()
  {
    ::common::units_double_list* r = this->position_;
    this->position_ = 0;
    return r;
  }

  inline
  bool node::
  custom_present () const
  {
    return this->custom_ != 0;
  }

  inline
  const ::common::custom& node::
  custom () const
  {
    return *this->custom_;
  }

  inline
  ::common::custom& node::
  custom ()
  {
    return *this->custom_;
  }

  inline
  void node::
  custom (::common::custom* x)
  {
    delete this->custom_;
    this->custom_ = x;
  }

  inline
  ::common::custom* node::
  custom_detach ()
  {
    ::common::custom* r = this->custom_;
    this->custom_ = 0;
    return r;
  }

  // edge
  //

  inline
  bool edge::
  ID_present () const
  {
    return this->ID_present_;
  }

  inline
  void edge::
  ID_present (bool x)
  {
    this->ID_present_ = x;
  }

  inline
  unsigned int edge::
  ID () const
  {
    return this->ID_;
  }

  inline
  unsigned int& edge::
  ID ()
  {
    return this->ID_;
  }

  inline
  void edge::
  ID (unsigned int x)
  {
    this->ID_ = x;
    this->ID_present_ = true;
  }

  inline
  const edge::node_ID_sequence& edge::
  node_ID () const
  {
    return this->node_ID_;
  }

  inline
  edge::node_ID_sequence& edge::
  node_ID ()
  {
    return this->node_ID_;
  }

  // face
  //

  inline
  bool face::
  ID_present () const
  {
    return this->ID_present_;
  }

  inline
  void face::
  ID_present (bool x)
  {
    this->ID_present_ = x;
  }

  inline
  unsigned int face::
  ID () const
  {
    return this->ID_;
  }

  inline
  unsigned int& face::
  ID ()
  {
    return this->ID_;
  }

  inline
  void face::
  ID (unsigned int x)
  {
    this->ID_ = x;
    this->ID_present_ = true;
  }

  inline
  const face::edge_ID_sequence& face::
  edge_ID () const
  {
    return this->edge_ID_;
  }

  inline
  face::edge_ID_sequence& face::
  edge_ID ()
  {
    return this->edge_ID_;
  }

  // int_list_xpath
  //

  inline
  bool int_list_xpath::
  xpath_present () const
  {
    return this->xpath_present_;
  }

  inline
  void int_list_xpath::
  xpath_present (bool x)
  {
    this->xpath_present_ = x;
  }

  inline
  const ::std::string& int_list_xpath::
  xpath () const
  {
    return this->xpath_;
  }

  inline
  ::std::string& int_list_xpath::
  xpath ()
  {
    return this->xpath_;
  }

  inline
  void int_list_xpath::
  xpath (const ::std::string& x)
  {
    this->xpath_ = x;
    this->xpath_present_ = true;
  }

  inline
  bool int_list_xpath::
  grouping_number_present () const
  {
    return this->grouping_number_present_;
  }

  inline
  void int_list_xpath::
  grouping_number_present (bool x)
  {
    this->grouping_number_present_ = x;
  }

  inline
  unsigned short int_list_xpath::
  grouping_number () const
  {
    return this->grouping_number_;
  }

  inline
  unsigned short& int_list_xpath::
  grouping_number ()
  {
    return this->grouping_number_;
  }

  inline
  void int_list_xpath::
  grouping_number (unsigned short x)
  {
    this->grouping_number_ = x;
    this->grouping_number_present_ = true;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#endif // MESH_IPP
