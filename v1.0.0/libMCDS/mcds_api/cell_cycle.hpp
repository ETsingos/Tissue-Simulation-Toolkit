// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CELL_CYCLE_HPP
#define CELL_CYCLE_HPP

#include <xsde/cxx/version.hxx>

#if (XSDE_INT_VERSION != 3020000L)
#error XSD/e runtime version mismatch
#endif

#include <xsde/cxx/config.hxx>

#ifndef XSDE_ENCODING_UTF8
#error the generated code uses the UTF-8 encodingwhile the XSD/e runtime does not (reconfigure the runtime or change the --char-encoding value)
#endif

#ifndef XSDE_STL
#error the generated code uses STL while the XSD/e runtime does not (reconfigure the runtime or add --no-stl)
#endif

#ifndef XSDE_EXCEPTIONS
#error the generated code uses exceptions while the XSD/e runtime does not (reconfigure the runtime or add --no-exceptions)
#endif

#ifndef XSDE_LONGLONG
#error the generated code uses long long while the XSD/e runtime does not (reconfigure the runtime or add --no-long-long)
#endif

#ifdef XSDE_CUSTOM_ALLOCATOR
#error the XSD/e runtime uses custom allocator while the generated code does not (reconfigure the runtime or add --custom-allocator)
#endif

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "cell_cycle-fwd.hpp"

#ifndef XSDE_DONT_INCLUDE_INLINE
#define XSDE_DONT_INCLUDE_INLINE

#include "common.hpp"

#include "variables.hpp"

#include "phenotype_base.hpp"

#undef XSDE_DONT_INCLUDE_INLINE
#else

#include "common.hpp"

#include "variables.hpp"

#include "phenotype_base.hpp"

#endif // XSDE_DONT_INCLUDE_INLINE

namespace cell_cycle
{
  // death_type (fixed-length)
  //
  class death_type
  {
    public:
    enum value_type
    {
      apoptosis,
      necrosis,
      autophagy
    };

    death_type ();
    death_type (value_type);

    void
    value (value_type);

    operator value_type () const
    {
      return value_;
    }

    const char*
    string () const;

    private:
    value_type value_;
  };

  // death_rate_type (variable-length)
  //
  class death_rate_type: public ::common::units_decimal_nonnegative
  {
    private:
    death_rate_type (const death_rate_type&);
    death_rate_type& operator= (const death_rate_type&);

    public:
    death_rate_type ();

    death_rate_type*
    _clone () const;

    ~death_rate_type ();

    // type
    //
    const ::cell_cycle::death_type&
    type () const;

    ::cell_cycle::death_type&
    type ();

    void
    type (const ::cell_cycle::death_type&);

    void
    _copy (death_rate_type&) const;

    private:
    ::cell_cycle::death_type type_;
  };

  // cell_cycle_arrest (variable-length)
  //
  class cell_cycle_arrest
  {
    private:
    cell_cycle_arrest (const cell_cycle_arrest&);
    cell_cycle_arrest& operator= (const cell_cycle_arrest&);

    public:
    cell_cycle_arrest ();

    cell_cycle_arrest*
    _clone () const;

    ~cell_cycle_arrest ();

    // condition
    //
    bool
    condition_present () const;

    const ::cell_cycle::arrest_condition&
    condition () const;

    ::cell_cycle::arrest_condition&
    condition ();

    void
    condition (::cell_cycle::arrest_condition*);

    ::cell_cycle::arrest_condition*
    condition_detach ();

    void
    _copy (cell_cycle_arrest&) const;

    private:
    ::cell_cycle::arrest_condition* condition_;
  };

  // transition (variable-length)
  //
  class transition
  {
    private:
    transition (const transition&);
    transition& operator= (const transition&);

    public:
    transition ();

    transition*
    _clone () const;

    ~transition ();

    // checkpoint_failure_probability
    //
    bool
    checkpoint_failure_probability_present () const;

    const ::common::units_decimal&
    checkpoint_failure_probability () const;

    ::common::units_decimal&
    checkpoint_failure_probability ();

    void
    checkpoint_failure_probability (::common::units_decimal*);

    ::common::units_decimal*
    checkpoint_failure_probability_detach ();

    // subsequent_phase
    //
    bool
    subsequent_phase_present () const;

    void
    subsequent_phase_present (bool);

    unsigned long long
    subsequent_phase () const;

    unsigned long long&
    subsequent_phase ();

    void
    subsequent_phase (unsigned long long);

    // threshold
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::variables::transition_threshold > threshold_sequence;
    typedef threshold_sequence::iterator threshold_iterator;
    typedef threshold_sequence::const_iterator threshold_const_iterator;

    const threshold_sequence&
    threshold () const;

    threshold_sequence&
    threshold ();

    // transition_rate
    //
    bool
    transition_rate_present () const;

    const ::common::units_decimal&
    transition_rate () const;

    ::common::units_decimal&
    transition_rate ();

    void
    transition_rate (::common::units_decimal*);

    ::common::units_decimal*
    transition_rate_detach ();

    void
    _copy (transition&) const;

    private:
    ::common::units_decimal* checkpoint_failure_probability_;
    unsigned long long subsequent_phase_;
    unsigned char subsequent_phase_present_;
    threshold_sequence threshold_;
    ::common::units_decimal* transition_rate_;
  };

  // cell_cycle_phase (variable-length)
  //
  class cell_cycle_phase
  {
    private:
    cell_cycle_phase (const cell_cycle_phase&);
    cell_cycle_phase& operator= (const cell_cycle_phase&);

    public:
    cell_cycle_phase ();

    cell_cycle_phase*
    _clone () const;

    ~cell_cycle_phase ();

    // name
    //
    const ::std::string&
    name () const;

    ::std::string&
    name ();

    void
    name (const ::std::string&);

    // ID
    //
    bool
    ID_present () const;

    void
    ID_present (bool);

    unsigned long long
    ID () const;

    unsigned long long&
    ID ();

    void
    ID (unsigned long long);

    // birth_rate
    //
    bool
    birth_rate_present () const;

    const ::common::units_decimal_nonnegative&
    birth_rate () const;

    ::common::units_decimal_nonnegative&
    birth_rate ();

    void
    birth_rate (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    birth_rate_detach ();

    // duration
    //
    bool
    duration_present () const;

    const ::common::units_decimal_nonnegative&
    duration () const;

    ::common::units_decimal_nonnegative&
    duration ();

    void
    duration (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    duration_detach ();

    // death_rate
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::cell_cycle::death_rate_type > death_rate_sequence;
    typedef death_rate_sequence::iterator death_rate_iterator;
    typedef death_rate_sequence::const_iterator death_rate_const_iterator;

    const death_rate_sequence&
    death_rate () const;

    death_rate_sequence&
    death_rate ();

    // net_birth_rate
    //
    bool
    net_birth_rate_present () const;

    const ::common::units_decimal&
    net_birth_rate () const;

    ::common::units_decimal&
    net_birth_rate ();

    void
    net_birth_rate (::common::units_decimal*);

    ::common::units_decimal*
    net_birth_rate_detach ();

    // population_doubling_time
    //
    bool
    population_doubling_time_present () const;

    const ::common::units_decimal_nonnegative&
    population_doubling_time () const;

    ::common::units_decimal_nonnegative&
    population_doubling_time ();

    void
    population_doubling_time (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    population_doubling_time_detach ();

    // cell_cycle_arrest
    //
    bool
    cell_cycle_arrest_present () const;

    const ::cell_cycle::cell_cycle_arrest&
    cell_cycle_arrest () const;

    ::cell_cycle::cell_cycle_arrest&
    cell_cycle_arrest ();

    void
    cell_cycle_arrest (::cell_cycle::cell_cycle_arrest*);

    ::cell_cycle::cell_cycle_arrest*
    cell_cycle_arrest_detach ();

    // transition
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::cell_cycle::transition > transition_sequence;
    typedef transition_sequence::iterator transition_iterator;
    typedef transition_sequence::const_iterator transition_const_iterator;

    const transition_sequence&
    transition () const;

    transition_sequence&
    transition ();

    // cell_part
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::phenotype_base::cell_parts > cell_part_sequence;
    typedef cell_part_sequence::iterator cell_part_iterator;
    typedef cell_part_sequence::const_iterator cell_part_const_iterator;

    const cell_part_sequence&
    cell_part () const;

    cell_part_sequence&
    cell_part ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (cell_cycle_phase&) const;

    private:
    ::std::string name_;
    unsigned long long ID_;
    unsigned char ID_present_;
    ::common::units_decimal_nonnegative* birth_rate_;
    ::common::units_decimal_nonnegative* duration_;
    death_rate_sequence death_rate_;
    ::common::units_decimal* net_birth_rate_;
    ::common::units_decimal_nonnegative* population_doubling_time_;
    ::cell_cycle::cell_cycle_arrest* cell_cycle_arrest_;
    transition_sequence transition_;
    cell_part_sequence cell_part_;
    ::common::custom* custom_;
  };

  // summary_elements (variable-length)
  //
  class summary_elements
  {
    private:
    summary_elements (const summary_elements&);
    summary_elements& operator= (const summary_elements&);

    public:
    summary_elements ();

    summary_elements*
    _clone () const;

    ~summary_elements ();

    // birth_rate
    //
    bool
    birth_rate_present () const;

    const ::common::units_decimal_nonnegative&
    birth_rate () const;

    ::common::units_decimal_nonnegative&
    birth_rate ();

    void
    birth_rate (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    birth_rate_detach ();

    // duration
    //
    bool
    duration_present () const;

    const ::common::units_decimal_nonnegative&
    duration () const;

    ::common::units_decimal_nonnegative&
    duration ();

    void
    duration (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    duration_detach ();

    // death_rate
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::cell_cycle::death_rate_type > death_rate_sequence;
    typedef death_rate_sequence::iterator death_rate_iterator;
    typedef death_rate_sequence::const_iterator death_rate_const_iterator;

    const death_rate_sequence&
    death_rate () const;

    death_rate_sequence&
    death_rate ();

    // net_birth_rate
    //
    bool
    net_birth_rate_present () const;

    const ::common::units_decimal&
    net_birth_rate () const;

    ::common::units_decimal&
    net_birth_rate ();

    void
    net_birth_rate (::common::units_decimal*);

    ::common::units_decimal*
    net_birth_rate_detach ();

    // population_doubling_time
    //
    bool
    population_doubling_time_present () const;

    const ::common::units_decimal_nonnegative&
    population_doubling_time () const;

    ::common::units_decimal_nonnegative&
    population_doubling_time ();

    void
    population_doubling_time (::common::units_decimal_nonnegative*);

    ::common::units_decimal_nonnegative*
    population_doubling_time_detach ();

    void
    _copy (summary_elements&) const;

    private:
    ::common::units_decimal_nonnegative* birth_rate_;
    ::common::units_decimal_nonnegative* duration_;
    death_rate_sequence death_rate_;
    ::common::units_decimal* net_birth_rate_;
    ::common::units_decimal_nonnegative* population_doubling_time_;
  };

  // cell_cycle (variable-length)
  //
  class cell_cycle
  {
    private:
    cell_cycle (const cell_cycle&);
    cell_cycle& operator= (const cell_cycle&);

    public:
    cell_cycle ();

    cell_cycle*
    _clone () const;

    ~cell_cycle ();

    // model
    //
    const ::std::string&
    model () const;

    ::std::string&
    model ();

    void
    model (const ::std::string&);

    // ID
    //
    bool
    ID_present () const;

    void
    ID_present (bool);

    unsigned long long
    ID () const;

    unsigned long long&
    ID ();

    void
    ID (unsigned long long);

    // cell_cycle_phase
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::cell_cycle::cell_cycle_phase > cell_cycle_phase_sequence;
    typedef cell_cycle_phase_sequence::iterator cell_cycle_phase_iterator;
    typedef cell_cycle_phase_sequence::const_iterator cell_cycle_phase_const_iterator;

    const cell_cycle_phase_sequence&
    cell_cycle_phase () const;

    cell_cycle_phase_sequence&
    cell_cycle_phase ();

    // cell_death
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::cell_cycle::cell_death > cell_death_sequence;
    typedef cell_death_sequence::iterator cell_death_iterator;
    typedef cell_death_sequence::const_iterator cell_death_const_iterator;

    const cell_death_sequence&
    cell_death () const;

    cell_death_sequence&
    cell_death ();

    // summary_elements
    //
    bool
    summary_elements_present () const;

    const ::cell_cycle::summary_elements&
    summary_elements () const;

    ::cell_cycle::summary_elements&
    summary_elements ();

    void
    summary_elements (::cell_cycle::summary_elements*);

    ::cell_cycle::summary_elements*
    summary_elements_detach ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (cell_cycle&) const;

    private:
    ::std::string model_;
    unsigned long long ID_;
    unsigned char ID_present_;
    cell_cycle_phase_sequence cell_cycle_phase_;
    cell_death_sequence cell_death_;
    ::cell_cycle::summary_elements* summary_elements_;
    ::common::custom* custom_;
  };

  // cell_death (variable-length)
  //
  class cell_death
  {
    private:
    cell_death (const cell_death&);
    cell_death& operator= (const cell_death&);

    public:
    cell_death ();

    cell_death*
    _clone () const;

    ~cell_death ();

    // type
    //
    const ::cell_cycle::death_type&
    type () const;

    ::cell_cycle::death_type&
    type ();

    void
    type (const ::cell_cycle::death_type&);

    // ID
    //
    bool
    ID_present () const;

    void
    ID_present (bool);

    unsigned long long
    ID () const;

    unsigned long long&
    ID ();

    void
    ID (unsigned long long);

    // duration
    //
    const ::common::units_decimal&
    duration () const;

    ::common::units_decimal&
    duration ();

    void
    duration (::common::units_decimal*);

    ::common::units_decimal*
    duration_detach ();

    // cell_part
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::phenotype_base::cell_parts > cell_part_sequence;
    typedef cell_part_sequence::iterator cell_part_iterator;
    typedef cell_part_sequence::const_iterator cell_part_const_iterator;

    const cell_part_sequence&
    cell_part () const;

    cell_part_sequence&
    cell_part ();

    // custom
    //
    bool
    custom_present () const;

    const ::common::custom&
    custom () const;

    ::common::custom&
    custom ();

    void
    custom (::common::custom*);

    ::common::custom*
    custom_detach ();

    void
    _copy (cell_death&) const;

    private:
    ::cell_cycle::death_type type_;
    unsigned long long ID_;
    unsigned char ID_present_;
    ::common::units_decimal* duration_;
    cell_part_sequence cell_part_;
    ::common::custom* custom_;
  };

  // arrest_type (fixed-length)
  //
  class arrest_type
  {
    public:
    enum value_type
    {
      maximum_cell_density,
      maximum_cell_surface_density,
      maximum_cell_volume_density,
      maximum_cell_number,
      maximum_volume_fraction,
      maximum_area_fraction
    };

    arrest_type ();
    arrest_type (value_type);

    void
    value (value_type);

    operator value_type () const
    {
      return value_;
    }

    const char*
    string () const;

    private:
    value_type value_;
  };

  // arrest_condition (variable-length)
  //
  class arrest_condition: public ::common::units_decimal
  {
    private:
    arrest_condition (const arrest_condition&);
    arrest_condition& operator= (const arrest_condition&);

    public:
    arrest_condition ();

    arrest_condition*
    _clone () const;

    ~arrest_condition ();

    // type
    //
    bool
    type_present () const;

    void
    type_present (bool);

    const ::cell_cycle::arrest_type&
    type () const;

    ::cell_cycle::arrest_type&
    type ();

    void
    type (const ::cell_cycle::arrest_type&);

    void
    _copy (arrest_condition&) const;

    private:
    ::cell_cycle::arrest_type type_;
    unsigned char type_present_;
  };

  // cycles_and_deaths (variable-length)
  //
  class cycles_and_deaths
  {
    private:
    cycles_and_deaths (const cycles_and_deaths&);
    cycles_and_deaths& operator= (const cycles_and_deaths&);

    public:
    cycles_and_deaths ();

    cycles_and_deaths*
    _clone () const;

    ~cycles_and_deaths ();

    // cell_cycle
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::cell_cycle::cell_cycle > cell_cycle_sequence;
    typedef cell_cycle_sequence::iterator cell_cycle_iterator;
    typedef cell_cycle_sequence::const_iterator cell_cycle_const_iterator;

    const cell_cycle_sequence&
    cell_cycle () const;

    cell_cycle_sequence&
    cell_cycle ();

    // cell_death
    //
    typedef ::xsde::cxx::hybrid::var_sequence< ::cell_cycle::cell_death > cell_death_sequence;
    typedef cell_death_sequence::iterator cell_death_iterator;
    typedef cell_death_sequence::const_iterator cell_death_const_iterator;

    const cell_death_sequence&
    cell_death () const;

    cell_death_sequence&
    cell_death ();

    void
    _copy (cycles_and_deaths&) const;

    private:
    cell_cycle_sequence cell_cycle_;
    cell_death_sequence cell_death_;
  };
}

#ifndef XSDE_DONT_INCLUDE_INLINE

#include "common.ipp"

#include "variables.ipp"

#include "phenotype_base.ipp"

#endif // XSDE_DONT_INCLUDE_INLINE

#ifndef XSDE_DONT_INCLUDE_INLINE
#include "cell_cycle.ipp"
#endif // XSDE_DONT_INCLUDE_INLINE

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

#endif // CELL_CYCLE_HPP
