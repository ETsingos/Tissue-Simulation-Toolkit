// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "MultiCellDS-sskel.hpp"

#include <assert.h>

#include <string.h>
#include <xsde/cxx/serializer/substitution-map.hxx>

static
const ::xsde::cxx::serializer::substitution_map_init
_xsde_substitution_map_init_;

// MCDS_type_sskel
//

const char* MCDS_type_sskel::
_static_type ()
{
  return "MCDS_type";
}

const char* MCDS_type_sskel::
_dynamic_type () const
{
  return _static_type ();
}

void MCDS_type_sskel::
pre (const ::std::string& x)
{
  assert (this->string_impl_);
  this->string_impl_->pre (x);
}

// MultiCellDS_sskel
//

bool MultiCellDS_sskel::
version_present ()
{
  return this->MultiCellDS_impl_ ? this->MultiCellDS_impl_->version_present () : false;
}

bool MultiCellDS_sskel::
type_present ()
{
  return this->MultiCellDS_impl_ ? this->MultiCellDS_impl_->type_present () : false;
}

bool MultiCellDS_sskel::
cell_line_next ()
{
  return this->MultiCellDS_impl_ ? this->MultiCellDS_impl_->cell_line_next () : false;
}

bool MultiCellDS_sskel::
metadata_present ()
{
  return this->MultiCellDS_impl_ ? this->MultiCellDS_impl_->metadata_present () : false;
}

bool MultiCellDS_sskel::
microenvironment_present ()
{
  return this->MultiCellDS_impl_ ? this->MultiCellDS_impl_->microenvironment_present () : false;
}

bool MultiCellDS_sskel::
cellular_information_present ()
{
  return this->MultiCellDS_impl_ ? this->MultiCellDS_impl_->cellular_information_present () : false;
}

void MultiCellDS_sskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::serializer::non_validating::complex_content base;
  base::_reset ();

  if (this->version_serializer_)
    this->version_serializer_->_reset ();

  if (this->type_serializer_)
    this->type_serializer_->_reset ();

  this->resetting_ = true;

  if (this->cell_line_serializer_)
    this->cell_line_serializer_->_reset ();

  if (this->cell_line_serializer_map_)
    this->cell_line_serializer_map_->reset ();

  if (this->metadata_serializer_)
    this->metadata_serializer_->_reset ();

  if (this->metadata_serializer_map_)
    this->metadata_serializer_map_->reset ();

  if (this->microenvironment_serializer_)
    this->microenvironment_serializer_->_reset ();

  if (this->microenvironment_serializer_map_)
    this->microenvironment_serializer_map_->reset ();

  if (this->cellular_information_serializer_)
    this->cellular_information_serializer_->_reset ();

  if (this->cellular_information_serializer_map_)
    this->cellular_information_serializer_map_->reset ();

  this->resetting_ = false;
}

const char* MultiCellDS_sskel::
_static_type ()
{
  return "MultiCellDS";
}

const char* MultiCellDS_sskel::
_dynamic_type () const
{
  return _static_type ();
}

void MultiCellDS_sskel::
_serialize_attributes ()
{
  ::xsde::cxx::serializer::context& ctx = this->_context ();

  // version
  //
  if (this->version_present ())
  {
    const ::std::string& r = this->version ();

    if (this->version_serializer_)
    {
      this->version_serializer_->pre (r);
      this->_start_attribute ("version");
      this->version_serializer_->_pre_impl (ctx);
      this->version_serializer_->_serialize_content ();
      this->version_serializer_->_post_impl ();
      this->_end_attribute ();
      this->version_serializer_->post ();
    }
  }

  // type
  //
  if (this->type_present ())
  {
    const ::MCDS_type& r = this->type ();

    if (this->type_serializer_)
    {
      this->type_serializer_->pre (r);
      this->_start_attribute ("type");
      this->type_serializer_->_pre_impl (ctx);
      this->type_serializer_->_serialize_content ();
      this->type_serializer_->_post_impl ();
      this->_end_attribute ();
      this->type_serializer_->post ();
    }
  }
}

void MultiCellDS_sskel::
_serialize_content ()
{
  ::xsde::cxx::serializer::context& ctx = this->_context ();

  // cell_line
  //
  while (this->cell_line_next ())
  {
    ctx.type_id (0);
    const ::cell_line::cell_line& r = this->cell_line ();

    const void* t = ctx.type_id ();
    ::cell_line::cell_line_sskel* s = 0;

    if (t == 0 && this->cell_line_serializer_ != 0)
      s = this->cell_line_serializer_;
    else if (this->cell_line_serializer_map_ != 0)
      s = static_cast< ::cell_line::cell_line_sskel* > (
        this->cell_line_serializer_map_->find (t));

    if (s)
    {
      s->pre (r);

      const char* dt = 0;
      if (t != 0)
      {
        dt = s->_dynamic_type ();
        if (strcmp (dt, ::cell_line::cell_line_sskel::_static_type ()) == 0)
          dt = 0;
      }

      this->_start_element ("cell_line");

      if (dt != 0)
        this->_set_type (dt);

      s->_pre_impl (ctx);
      s->_serialize_attributes ();
      s->_serialize_content ();
      s->_post_impl ();
      this->_end_element ();
      s->post ();
    }
  }

  // metadata
  //
  if (this->metadata_present ())
  {
    ctx.type_id (0);
    const ::metadata::metadata& r = this->metadata ();

    const void* t = ctx.type_id ();
    ::metadata::metadata_sskel* s = 0;

    if (t == 0 && this->metadata_serializer_ != 0)
      s = this->metadata_serializer_;
    else if (this->metadata_serializer_map_ != 0)
      s = static_cast< ::metadata::metadata_sskel* > (
        this->metadata_serializer_map_->find (t));

    if (s)
    {
      s->pre (r);

      const char* dt = 0;
      if (t != 0)
      {
        dt = s->_dynamic_type ();
        if (strcmp (dt, ::metadata::metadata_sskel::_static_type ()) == 0)
          dt = 0;
      }

      this->_start_element ("metadata");

      if (dt != 0)
        this->_set_type (dt);

      s->_pre_impl (ctx);
      s->_serialize_attributes ();
      s->_serialize_content ();
      s->_post_impl ();
      this->_end_element ();
      s->post ();
    }
  }

  // microenvironment
  //
  if (this->microenvironment_present ())
  {
    ctx.type_id (0);
    const ::microenvironment::microenvironment& r = this->microenvironment ();

    const void* t = ctx.type_id ();
    ::microenvironment::microenvironment_sskel* s = 0;

    if (t == 0 && this->microenvironment_serializer_ != 0)
      s = this->microenvironment_serializer_;
    else if (this->microenvironment_serializer_map_ != 0)
      s = static_cast< ::microenvironment::microenvironment_sskel* > (
        this->microenvironment_serializer_map_->find (t));

    if (s)
    {
      s->pre (r);

      const char* dt = 0;
      if (t != 0)
      {
        dt = s->_dynamic_type ();
        if (strcmp (dt, ::microenvironment::microenvironment_sskel::_static_type ()) == 0)
          dt = 0;
      }

      this->_start_element ("microenvironment");

      if (dt != 0)
        this->_set_type (dt);

      s->_pre_impl (ctx);
      s->_serialize_attributes ();
      s->_serialize_content ();
      s->_post_impl ();
      this->_end_element ();
      s->post ();
    }
  }

  // cellular_information
  //
  if (this->cellular_information_present ())
  {
    ctx.type_id (0);
    const ::cell::cellular_information& r = this->cellular_information ();

    const void* t = ctx.type_id ();
    ::cell::cellular_information_sskel* s = 0;

    if (t == 0 && this->cellular_information_serializer_ != 0)
      s = this->cellular_information_serializer_;
    else if (this->cellular_information_serializer_map_ != 0)
      s = static_cast< ::cell::cellular_information_sskel* > (
        this->cellular_information_serializer_map_->find (t));

    if (s)
    {
      s->pre (r);

      const char* dt = 0;
      if (t != 0)
      {
        dt = s->_dynamic_type ();
        if (strcmp (dt, ::cell::cellular_information_sskel::_static_type ()) == 0)
          dt = 0;
      }

      this->_start_element ("cellular_information");

      if (dt != 0)
        this->_set_type (dt);

      s->_pre_impl (ctx);
      s->_serialize_attributes ();
      s->_serialize_content ();
      s->_post_impl ();
      this->_end_element ();
      s->post ();
    }
  }
}

// Begin epilogue.
//
//
// End epilogue.

