// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "phenotype_base.hpp"

#include <stdlib.h>
#include <new>

#include <xsde/cxx/guard.hxx>

namespace phenotype_base
{
  // phenotype_type
  //

  static const char* _xsde_phenotype_type_enumerators_[] = 
  {
    "expected",
    "current",
    "target"
  };

  const char* phenotype_type::
  string () const
  {
    return _xsde_phenotype_type_enumerators_[value_];
  }

  // phenotype_base
  //

  phenotype_base::
  phenotype_base ()
  {
    this->type_present_ = false;
    this->adhesion_ = 0;
    this->geometrical_properties_ = 0;
    this->mass_ = 0;
    this->mechanics_ = 0;
    this->motility_ = 0;
    this->PKPD_ = 0;
    this->timescale_ = 0;
    this->transport_processes_ = 0;
    this->custom_ = 0;
  }

  phenotype_base::
  ~phenotype_base ()
  {
    delete this->adhesion_;
    delete this->geometrical_properties_;
    delete this->mass_;
    delete this->mechanics_;
    delete this->motility_;
    delete this->PKPD_;
    delete this->timescale_;
    delete this->transport_processes_;
    delete this->custom_;
  }

  void phenotype_base::
  _copy (phenotype_base& c) const
  {
    XSDE_UNUSED (c);

    if (this->type_present ())
      c.type (this->type ());

    if (this->adhesion_present ())
    {
      ::phenotype_common::adhesion* m = this->adhesion ()._clone ();
      c.adhesion (m);
    }

    if (this->geometrical_properties_present ())
    {
      ::phenotype_common::geometrical_properties* m = this->geometrical_properties ()._clone ();
      c.geometrical_properties (m);
    }

    if (this->mass_present ())
    {
      ::phenotype_common::mass* m = this->mass ()._clone ();
      c.mass (m);
    }

    if (this->mechanics_present ())
    {
      ::phenotype_common::mechanics* m = this->mechanics ()._clone ();
      c.mechanics (m);
    }

    if (this->motility_present ())
    {
      ::phenotype_common::motility* m = this->motility ()._clone ();
      c.motility (m);
    }

    if (this->PKPD_present ())
    {
      ::pkpd::PKPD* m = this->PKPD ()._clone ();
      c.PKPD (m);
    }

    if (this->timescale_present ())
    {
      ::phenotype_base::expected_timescale* m = this->timescale ()._clone ();
      c.timescale (m);
    }

    if (this->transport_processes_present ())
    {
      ::phenotype_common::transport_processes* m = this->transport_processes ()._clone ();
      c.transport_processes (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  phenotype_base* phenotype_base::
  _clone () const
  {
    phenotype_base* c = new phenotype_base;
    ::xsde::cxx::guard< phenotype_base > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // expected_timescale
  //

  expected_timescale::
  expected_timescale ()
  {
    this->cell_cycle_ID_present_ = false;
    this->cell_cycle_phase_ID_present_ = false;
    this->cell_death_ID_present_ = false;
  }

  expected_timescale::
  ~expected_timescale ()
  {
  }

  void expected_timescale::
  _copy (expected_timescale& c) const
  {
    XSDE_UNUSED (c);

    const ::common::units_decimal_nonnegative& b = *this;
    b._copy (c);
    if (this->cell_cycle_ID_present ())
      c.cell_cycle_ID (this->cell_cycle_ID ());

    if (this->cell_cycle_phase_ID_present ())
      c.cell_cycle_phase_ID (this->cell_cycle_phase_ID ());

    if (this->cell_death_ID_present ())
      c.cell_death_ID (this->cell_death_ID ());
  }

  expected_timescale* expected_timescale::
  _clone () const
  {
    expected_timescale* c = new expected_timescale;
    ::xsde::cxx::guard< expected_timescale > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // cell_parts
  //

  cell_parts::
  cell_parts ()
  {
    this->ID_present_ = false;
    this->custom_ = 0;
  }

  cell_parts::
  ~cell_parts ()
  {
    delete this->custom_;
  }

  void cell_parts::
  _copy (cell_parts& c) const
  {
    XSDE_UNUSED (c);

    c.name (this->name ());

    if (this->ID_present ())
      c.ID (this->ID ());

    this->phenotype ().copy (c.phenotype ());

    this->cell_part ().copy (c.cell_part ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  cell_parts* cell_parts::
  _clone () const
  {
    cell_parts* c = new cell_parts;
    ::xsde::cxx::guard< cell_parts > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

