// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "MultiCellDS-sskel.hpp"

#include <assert.h>

#include <string.h>
#include <xsde/cxx/serializer/substitution-map.hxx>
#include <xsde/cxx/serializer/validating/inheritance-map.hxx>

static
const ::xsde::cxx::serializer::substitution_map_init
_xsde_substitution_map_init_;

static
const ::xsde::cxx::serializer::validating::inheritance_map_init
_xsde_inheritance_map_init_;

// MCDS_type_sskel
//

const char* MCDS_type_sskel::
_static_type ()
{
  return "MCDS_type";
}

const char* MCDS_type_sskel::
_dynamic_type () const
{
  return _static_type ();
}

static
const ::xsde::cxx::serializer::validating::inheritance_map_entry
_xsde_MCDS_type_sskel_inheritance_map_entry_ (
  MCDS_type_sskel::_static_type (),
  ::xml_schema::string_sskel::_static_type ());

void MCDS_type_sskel::
pre (const ::std::string& x)
{
  assert (this->string_impl_);
  this->string_impl_->pre (x);
}

const char* const MCDS_type_sskel::_xsde_MCDS_type_sskel_enums_[4UL] = 
{
  "cell_line",
  "snapshot/clinical",
  "snapshot/experiment",
  "snapshot/simulation"
};

// MultiCellDS_sskel
//

bool MultiCellDS_sskel::
version_present ()
{
  return this->MultiCellDS_impl_ ? this->MultiCellDS_impl_->version_present () : false;
}

bool MultiCellDS_sskel::
type_present ()
{
  return this->MultiCellDS_impl_ ? this->MultiCellDS_impl_->type_present () : false;
}

bool MultiCellDS_sskel::
cell_line_next ()
{
  return this->MultiCellDS_impl_ ? this->MultiCellDS_impl_->cell_line_next () : false;
}

bool MultiCellDS_sskel::
metadata_present ()
{
  return this->MultiCellDS_impl_ ? this->MultiCellDS_impl_->metadata_present () : false;
}

bool MultiCellDS_sskel::
microenvironment_present ()
{
  return this->MultiCellDS_impl_ ? this->MultiCellDS_impl_->microenvironment_present () : false;
}

bool MultiCellDS_sskel::
cellular_information_present ()
{
  return this->MultiCellDS_impl_ ? this->MultiCellDS_impl_->cellular_information_present () : false;
}

void MultiCellDS_sskel::
_reset ()
{
  if (this->resetting_)
    return;

  typedef ::xsde::cxx::serializer::validating::complex_content base;
  base::_reset ();

  if (this->version_serializer_)
    this->version_serializer_->_reset ();

  if (this->type_serializer_)
    this->type_serializer_->_reset ();

  this->resetting_ = true;

  if (this->cell_line_serializer_)
    this->cell_line_serializer_->_reset ();

  if (this->cell_line_serializer_map_)
    this->cell_line_serializer_map_->reset ();

  if (this->metadata_serializer_)
    this->metadata_serializer_->_reset ();

  if (this->metadata_serializer_map_)
    this->metadata_serializer_map_->reset ();

  if (this->microenvironment_serializer_)
    this->microenvironment_serializer_->_reset ();

  if (this->microenvironment_serializer_map_)
    this->microenvironment_serializer_map_->reset ();

  if (this->cellular_information_serializer_)
    this->cellular_information_serializer_->_reset ();

  if (this->cellular_information_serializer_map_)
    this->cellular_information_serializer_map_->reset ();

  this->resetting_ = false;
}

const char* MultiCellDS_sskel::
_static_type ()
{
  return "MultiCellDS";
}

const char* MultiCellDS_sskel::
_dynamic_type () const
{
  return _static_type ();
}

// Element validation and serialization for MultiCellDS_sskel.
//
void MultiCellDS_sskel::
_serialize_content ()
{
  ::xsde::cxx::serializer::context& ctx = this->_context ();

  // cell_line
  //
  while (this->cell_line_next ())
  {
    ctx.type_id (0);
    const ::cell_line::cell_line& r = this->cell_line ();

    const void* t = ctx.type_id ();
    const char* dt = 0;
    ::cell_line::cell_line_sskel* s = 0;

    if (t == 0 && this->cell_line_serializer_ != 0)
      s = this->cell_line_serializer_;
    else if (this->cell_line_serializer_map_ != 0)
    {
      ::xml_schema::serializer_base* b = this->cell_line_serializer_map_->find (t);

      if (b != 0)
      {
        dt = b->_dynamic_type ();
        const char* st = ::cell_line::cell_line_sskel::_static_type ();

        if (strcmp (dt, st) == 0)
          dt = 0;

        if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
        {
          ctx.schema_error (::xsde::cxx::schema_error::not_derived);
          return;
        }

        s = static_cast< ::cell_line::cell_line_sskel* > (b);
      }
    }

    if (s)
    {
      s->pre (r);
      this->_start_element ("cell_line");
      if (dt != 0)
        this->_set_type (dt);

      s->_pre_impl (ctx);

      if (ctx.error_type ())
        return;

      s->_serialize_attributes ();

      if (ctx.error_type ())
        return;

      s->_serialize_content ();

      if (ctx.error_type ())
        return;

      s->_post_impl ();

      if (ctx.error_type ())
        return;

      this->_end_element ();
      s->post ();
    }
  }

  // metadata
  //
  if (this->metadata_present ())
  {
    ctx.type_id (0);
    const ::metadata::metadata& r = this->metadata ();

    const void* t = ctx.type_id ();
    const char* dt = 0;
    ::metadata::metadata_sskel* s = 0;

    if (t == 0 && this->metadata_serializer_ != 0)
      s = this->metadata_serializer_;
    else if (this->metadata_serializer_map_ != 0)
    {
      ::xml_schema::serializer_base* b = this->metadata_serializer_map_->find (t);

      if (b != 0)
      {
        dt = b->_dynamic_type ();
        const char* st = ::metadata::metadata_sskel::_static_type ();

        if (strcmp (dt, st) == 0)
          dt = 0;

        if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
        {
          ctx.schema_error (::xsde::cxx::schema_error::not_derived);
          return;
        }

        s = static_cast< ::metadata::metadata_sskel* > (b);
      }
    }

    if (s)
    {
      s->pre (r);
      this->_start_element ("metadata");
      if (dt != 0)
        this->_set_type (dt);

      s->_pre_impl (ctx);

      if (ctx.error_type ())
        return;

      s->_serialize_attributes ();

      if (ctx.error_type ())
        return;

      s->_serialize_content ();

      if (ctx.error_type ())
        return;

      s->_post_impl ();

      if (ctx.error_type ())
        return;

      this->_end_element ();
      s->post ();
    }
  }

  // microenvironment
  //
  if (this->microenvironment_present ())
  {
    ctx.type_id (0);
    const ::microenvironment::microenvironment& r = this->microenvironment ();

    const void* t = ctx.type_id ();
    const char* dt = 0;
    ::microenvironment::microenvironment_sskel* s = 0;

    if (t == 0 && this->microenvironment_serializer_ != 0)
      s = this->microenvironment_serializer_;
    else if (this->microenvironment_serializer_map_ != 0)
    {
      ::xml_schema::serializer_base* b = this->microenvironment_serializer_map_->find (t);

      if (b != 0)
      {
        dt = b->_dynamic_type ();
        const char* st = ::microenvironment::microenvironment_sskel::_static_type ();

        if (strcmp (dt, st) == 0)
          dt = 0;

        if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
        {
          ctx.schema_error (::xsde::cxx::schema_error::not_derived);
          return;
        }

        s = static_cast< ::microenvironment::microenvironment_sskel* > (b);
      }
    }

    if (s)
    {
      s->pre (r);
      this->_start_element ("microenvironment");
      if (dt != 0)
        this->_set_type (dt);

      s->_pre_impl (ctx);

      if (ctx.error_type ())
        return;

      s->_serialize_attributes ();

      if (ctx.error_type ())
        return;

      s->_serialize_content ();

      if (ctx.error_type ())
        return;

      s->_post_impl ();

      if (ctx.error_type ())
        return;

      this->_end_element ();
      s->post ();
    }
  }

  // cellular_information
  //
  if (this->cellular_information_present ())
  {
    ctx.type_id (0);
    const ::cell::cellular_information& r = this->cellular_information ();

    const void* t = ctx.type_id ();
    const char* dt = 0;
    ::cell::cellular_information_sskel* s = 0;

    if (t == 0 && this->cellular_information_serializer_ != 0)
      s = this->cellular_information_serializer_;
    else if (this->cellular_information_serializer_map_ != 0)
    {
      ::xml_schema::serializer_base* b = this->cellular_information_serializer_map_->find (t);

      if (b != 0)
      {
        dt = b->_dynamic_type ();
        const char* st = ::cell::cellular_information_sskel::_static_type ();

        if (strcmp (dt, st) == 0)
          dt = 0;

        if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
        {
          ctx.schema_error (::xsde::cxx::schema_error::not_derived);
          return;
        }

        s = static_cast< ::cell::cellular_information_sskel* > (b);
      }
    }

    if (s)
    {
      s->pre (r);
      this->_start_element ("cellular_information");
      if (dt != 0)
        this->_set_type (dt);

      s->_pre_impl (ctx);

      if (ctx.error_type ())
        return;

      s->_serialize_attributes ();

      if (ctx.error_type ())
        return;

      s->_serialize_content ();

      if (ctx.error_type ())
        return;

      s->_post_impl ();

      if (ctx.error_type ())
        return;

      this->_end_element ();
      s->post ();
    }
  }
}

// Attribute validation and serialization for MultiCellDS_sskel.
//
void MultiCellDS_sskel::
_serialize_attributes ()
{
  ::xsde::cxx::serializer::context& ctx = this->_context ();

  // version
  //
  if (this->version_present ())
  {
    const ::std::string& r = this->version ();

    if (this->version_serializer_)
    {
      this->version_serializer_->pre (r);
      this->_start_attribute ("version");
      this->version_serializer_->_pre_impl (ctx);

      if (ctx.error_type ())
        return;

      this->version_serializer_->_serialize_content ();

      if (ctx.error_type ())
        return;

      this->version_serializer_->_post_impl ();

      if (ctx.error_type ())
        return;

      this->_end_attribute ();
      this->version_serializer_->post ();
    }
  }

  // type
  //
  if (this->type_present ())
  {
    const ::MCDS_type& r = this->type ();

    if (this->type_serializer_)
    {
      this->type_serializer_->pre (r);
      this->_start_attribute ("type");
      this->type_serializer_->_pre_impl (ctx);

      if (ctx.error_type ())
        return;

      this->type_serializer_->_serialize_content ();

      if (ctx.error_type ())
        return;

      this->type_serializer_->_post_impl ();

      if (ctx.error_type ())
        return;

      this->_end_attribute ();
      this->type_serializer_->post ();
    }
  }
}

// Begin epilogue.
//
//
// End epilogue.

