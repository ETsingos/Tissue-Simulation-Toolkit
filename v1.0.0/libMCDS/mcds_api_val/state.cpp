// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "state.hpp"

#include <stdlib.h>
#include <new>

#include <xsde/cxx/guard.hxx>

namespace state
{
  // phase_name
  //

  phase_name::
  phase_name ()
  {
    this->GO_ID_present_ = false;
  }

  phase_name::
  ~phase_name ()
  {
  }

  phase_name::
  phase_name (const phase_name& x)
  : ::std::string (x)
  {
    XSDE_UNUSED (x);
    this->GO_ID_present_ = x.GO_ID_present_;
    if (this->GO_ID_present_)
      this->GO_ID_ = x.GO_ID_;
  }

  phase_name& phase_name::
  operator= (const phase_name& x)
  {
    XSDE_UNUSED (x);
    static_cast< ::std::string& > (*this) = x;
    this->GO_ID_present_ = x.GO_ID_present_;
    if (this->GO_ID_present_)
      this->GO_ID_ = x.GO_ID_;
    return *this;
  }

  // phase
  //

  phase::
  phase ()
  {
    this->model_name_present_ = false;
    this->phase_name_present_ = false;
    this->cell_cycle_model_index_present_ = false;
    this->cell_cycle_phase_index_present_ = false;
    this->elapsed_time_ = 0;
    this->custom_ = 0;
  }

  phase::
  ~phase ()
  {
    delete this->elapsed_time_;
    delete this->custom_;
  }

  void phase::
  _copy (phase& c) const
  {
    XSDE_UNUSED (c);

    if (this->model_name_present ())
      c.model_name (this->model_name ());

    if (this->phase_name_present ())
      c.phase_name (this->phase_name ());

    if (this->cell_cycle_model_index_present ())
      c.cell_cycle_model_index (this->cell_cycle_model_index ());

    if (this->cell_cycle_phase_index_present ())
      c.cell_cycle_phase_index (this->cell_cycle_phase_index ());

    if (this->elapsed_time_present ())
    {
      ::common::units_decimal* m = this->elapsed_time ()._clone ();
      c.elapsed_time (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  phase* phase::
  _clone () const
  {
    phase* c = new phase;
    ::xsde::cxx::guard< phase > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // orientation_formalism
  //

  static const char* _xsde_orientation_formalism_enumerators_[] = 
  {
    "axis-angle",
    "quaternion",
    "Euler Angles",
    "Tait-Bryan",
    "polar",
    "Polar",
    "Unit Vector"
  };

  const char* orientation_formalism::
  string () const
  {
    return _xsde_orientation_formalism_enumerators_[value_];
  }

  // orientation
  //

  orientation::
  orientation ()
  {
    this->formalism_present_ = false;
  }

  orientation::
  ~orientation ()
  {
  }

  void orientation::
  _copy (orientation& c) const
  {
    XSDE_UNUSED (c);

    const ::common::units_double_list& b = *this;
    b._copy (c);
    if (this->formalism_present ())
      c.formalism (this->formalism ());
  }

  orientation* orientation::
  _clone () const
  {
    orientation* c = new orientation;
    ::xsde::cxx::guard< orientation > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // cell_parts
  //

  cell_parts::
  cell_parts ()
  {
    this->ID_present_ = false;
    this->orientation_ = 0;
    this->position_ = 0;
    this->velocity_ = 0;
    this->voxels_ = 0;
    this->custom_ = 0;
  }

  cell_parts::
  ~cell_parts ()
  {
    delete this->orientation_;
    delete this->position_;
    delete this->velocity_;
    delete this->voxels_;
    delete this->custom_;
  }

  void cell_parts::
  _copy (cell_parts& c) const
  {
    XSDE_UNUSED (c);

    c.name (this->name ());

    if (this->ID_present ())
      c.ID (this->ID ());

    if (this->orientation_present ())
    {
      ::state::orientation* m = this->orientation ()._clone ();
      c.orientation (m);
    }

    if (this->position_present ())
    {
      ::common::units_double_list* m = this->position ()._clone ();
      c.position (m);
    }

    if (this->velocity_present ())
    {
      ::common::units_double_list* m = this->velocity ()._clone ();
      c.velocity (m);
    }

    if (this->voxels_present ())
    {
      ::mesh::int_list_xpath* m = this->voxels ()._clone ();
      c.voxels (m);
    }

    this->cell_part ().copy (c.cell_part ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  cell_parts* cell_parts::
  _clone () const
  {
    cell_parts* c = new cell_parts;
    ::xsde::cxx::guard< cell_parts > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // state
  //

  state::
  state ()
  {
    this->orientation_ = 0;
    this->position_ = 0;
    this->velocity_ = 0;
    this->voxels_ = 0;
    this->phase_ = 0;
    this->adhered_cells_ = 0;
    this->custom_ = 0;
  }

  state::
  ~state ()
  {
    delete this->orientation_;
    delete this->position_;
    delete this->velocity_;
    delete this->voxels_;
    delete this->phase_;
    delete this->adhered_cells_;
    delete this->custom_;
  }

  void state::
  _copy (state& c) const
  {
    XSDE_UNUSED (c);

    if (this->orientation_present ())
    {
      ::state::orientation* m = this->orientation ()._clone ();
      c.orientation (m);
    }

    if (this->position_present ())
    {
      ::common::units_double_list* m = this->position ()._clone ();
      c.position (m);
    }

    if (this->velocity_present ())
    {
      ::common::units_double_list* m = this->velocity ()._clone ();
      c.velocity (m);
    }

    if (this->voxels_present ())
    {
      ::mesh::int_list_xpath* m = this->voxels ()._clone ();
      c.voxels (m);
    }

    this->cell_part ().copy (c.cell_part ());

    if (this->phase_present ())
    {
      ::state::phase* m = this->phase ()._clone ();
      c.phase (m);
    }

    if (this->adhered_cells_present ())
    {
      ::state::list_of_adhered_cells* m = this->adhered_cells ()._clone ();
      c.adhered_cells (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  state* state::
  _clone () const
  {
    state* c = new state;
    ::xsde::cxx::guard< state > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // adhered_cell
  //

  adhered_cell::
  adhered_cell ()
  {
    this->contact_area_ = 0;
    this->contact_ = 0;
    this->custom_ = 0;
  }

  adhered_cell::
  ~adhered_cell ()
  {
    delete this->contact_area_;
    delete this->contact_;
    delete this->custom_;
  }

  void adhered_cell::
  _copy (adhered_cell& c) const
  {
    XSDE_UNUSED (c);

    c.ID (this->ID ());

    {
      ::common::units_decimal_nonnegative* m = this->contact_area ()._clone ();
      c.contact_area (m);
    }

    {
      ::phenotype_common::cross_section* m = this->contact ()._clone ();
      c.contact (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  adhered_cell* adhered_cell::
  _clone () const
  {
    adhered_cell* c = new adhered_cell;
    ::xsde::cxx::guard< adhered_cell > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // list_of_adhered_cells
  //

  list_of_adhered_cells::
  list_of_adhered_cells ()
  {
    this->custom_ = 0;
  }

  list_of_adhered_cells::
  ~list_of_adhered_cells ()
  {
    delete this->custom_;
  }

  void list_of_adhered_cells::
  _copy (list_of_adhered_cells& c) const
  {
    XSDE_UNUSED (c);

    this->adhered_cell ().copy (c.adhered_cell ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  list_of_adhered_cells* list_of_adhered_cells::
  _clone () const
  {
    list_of_adhered_cells* c = new list_of_adhered_cells;
    ::xsde::cxx::guard< list_of_adhered_cells > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

