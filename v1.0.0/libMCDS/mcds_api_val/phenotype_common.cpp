// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "phenotype_common.hpp"

#include <stdlib.h>
#include <new>

#include <xsde/cxx/guard.hxx>

namespace phenotype_common
{
  // adhesion
  //

  adhesion::
  adhesion ()
  {
    this->adhesion_bond_breaking_rate_ = 0;
    this->adhesion_bond_formation_rate_ = 0;
    this->adhesion_spring_constant_ = 0;
    this->adhesion_receptor_density_ = 0;
    this->surface_binding_energy_ = 0;
    this->number_of_adhered_cells_ = 0;
    this->maximum_number_of_adhered_cells_present_ = false;
    this->adhered_surface_area_ = 0;
    this->maximum_adhered_surface_area_ = 0;
    this->adhesion_force_per_surface_area_ = 0;
    this->adhesion_probability_ = 0;
    this->detachment_proability_ = 0;
    this->custom_ = 0;
  }

  adhesion::
  ~adhesion ()
  {
    delete this->adhesion_bond_breaking_rate_;
    delete this->adhesion_bond_formation_rate_;
    delete this->adhesion_spring_constant_;
    delete this->adhesion_receptor_density_;
    delete this->surface_binding_energy_;
    delete this->number_of_adhered_cells_;
    delete this->adhered_surface_area_;
    delete this->maximum_adhered_surface_area_;
    delete this->adhesion_force_per_surface_area_;
    delete this->adhesion_probability_;
    delete this->detachment_proability_;
    delete this->custom_;
  }

  void adhesion::
  _copy (adhesion& c) const
  {
    XSDE_UNUSED (c);

    if (this->adhesion_bond_breaking_rate_present ())
    {
      ::common::units_decimal* m = this->adhesion_bond_breaking_rate ()._clone ();
      c.adhesion_bond_breaking_rate (m);
    }

    if (this->adhesion_bond_formation_rate_present ())
    {
      ::common::units_decimal* m = this->adhesion_bond_formation_rate ()._clone ();
      c.adhesion_bond_formation_rate (m);
    }

    if (this->adhesion_spring_constant_present ())
    {
      ::common::units_decimal_nonnegative* m = this->adhesion_spring_constant ()._clone ();
      c.adhesion_spring_constant (m);
    }

    if (this->adhesion_receptor_density_present ())
    {
      ::common::units_decimal_nonnegative* m = this->adhesion_receptor_density ()._clone ();
      c.adhesion_receptor_density (m);
    }

    if (this->surface_binding_energy_present ())
    {
      ::common::units_decimal* m = this->surface_binding_energy ()._clone ();
      c.surface_binding_energy (m);
    }

    if (this->number_of_adhered_cells_present ())
    {
      ::common::units_decimal_nonnegative* m = this->number_of_adhered_cells ()._clone ();
      c.number_of_adhered_cells (m);
    }

    if (this->maximum_number_of_adhered_cells_present ())
      c.maximum_number_of_adhered_cells (this->maximum_number_of_adhered_cells ());

    if (this->adhered_surface_area_present ())
    {
      ::common::units_decimal_nonnegative* m = this->adhered_surface_area ()._clone ();
      c.adhered_surface_area (m);
    }

    if (this->maximum_adhered_surface_area_present ())
    {
      ::common::units_decimal_nonnegative* m = this->maximum_adhered_surface_area ()._clone ();
      c.maximum_adhered_surface_area (m);
    }

    if (this->adhesion_force_per_surface_area_present ())
    {
      ::common::units_decimal* m = this->adhesion_force_per_surface_area ()._clone ();
      c.adhesion_force_per_surface_area (m);
    }

    if (this->adhesion_probability_present ())
    {
      ::common::units_fraction* m = this->adhesion_probability ()._clone ();
      c.adhesion_probability (m);
    }

    if (this->detachment_proability_present ())
    {
      ::common::units_fraction* m = this->detachment_proability ()._clone ();
      c.detachment_proability (m);
    }

    this->rolling_observation ().copy (c.rolling_observation ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  adhesion* adhesion::
  _clone () const
  {
    adhesion* c = new adhesion;
    ::xsde::cxx::guard< adhesion > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // rolling_observation
  //

  rolling_observation::
  rolling_observation ()
  {
    this->rolling_velocity_ = 0;
    this->shear_stress_ = 0;
  }

  rolling_observation::
  ~rolling_observation ()
  {
    delete this->rolling_velocity_;
    delete this->shear_stress_;
  }

  void rolling_observation::
  _copy (rolling_observation& c) const
  {
    XSDE_UNUSED (c);

    {
      ::common::units_decimal* m = this->rolling_velocity ()._clone ();
      c.rolling_velocity (m);
    }

    {
      ::common::units_decimal* m = this->shear_stress ()._clone ();
      c.shear_stress (m);
    }
  }

  rolling_observation* rolling_observation::
  _clone () const
  {
    rolling_observation* c = new rolling_observation;
    ::xsde::cxx::guard< rolling_observation > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // friction
  //

  friction::
  friction ()
  {
    this->compression_ = 0;
    this->ECM_ = 0;
    this->shear_ = 0;
  }

  friction::
  ~friction ()
  {
    delete this->compression_;
    delete this->ECM_;
    delete this->shear_;
  }

  void friction::
  _copy (friction& c) const
  {
    XSDE_UNUSED (c);

    if (this->compression_present ())
    {
      ::common::units_decimal_nonnegative* m = this->compression ()._clone ();
      c.compression (m);
    }

    if (this->ECM_present ())
    {
      ::common::units_decimal_nonnegative* m = this->ECM ()._clone ();
      c.ECM (m);
    }

    if (this->shear_present ())
    {
      ::common::units_decimal_nonnegative* m = this->shear ()._clone ();
      c.shear (m);
    }
  }

  friction* friction::
  _clone () const
  {
    friction* c = new friction;
    ::xsde::cxx::guard< friction > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // mechanics
  //

  mechanics::
  mechanics ()
  {
    this->friction_ = 0;
    this->maximum_cell_deformation_ = 0;
    this->mechanical_pressure_ = 0;
    this->poisson_ratio_ = 0;
    this->youngs_modulus_ = 0;
    this->custom_ = 0;
  }

  mechanics::
  ~mechanics ()
  {
    delete this->friction_;
    delete this->maximum_cell_deformation_;
    delete this->mechanical_pressure_;
    delete this->poisson_ratio_;
    delete this->youngs_modulus_;
    delete this->custom_;
  }

  void mechanics::
  _copy (mechanics& c) const
  {
    XSDE_UNUSED (c);

    if (this->friction_present ())
    {
      ::phenotype_common::friction* m = this->friction ()._clone ();
      c.friction (m);
    }

    if (this->maximum_cell_deformation_present ())
    {
      ::common::units_decimal* m = this->maximum_cell_deformation ()._clone ();
      c.maximum_cell_deformation (m);
    }

    if (this->mechanical_pressure_present ())
    {
      ::common::units_decimal* m = this->mechanical_pressure ()._clone ();
      c.mechanical_pressure (m);
    }

    this->indentation_observation ().copy (c.indentation_observation ());

    if (this->poisson_ratio_present ())
    {
      ::common::units_decimal* m = this->poisson_ratio ()._clone ();
      c.poisson_ratio (m);
    }

    if (this->youngs_modulus_present ())
    {
      ::common::units_decimal* m = this->youngs_modulus ()._clone ();
      c.youngs_modulus (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  mechanics* mechanics::
  _clone () const
  {
    mechanics* c = new mechanics;
    ::xsde::cxx::guard< mechanics > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // indentation_observation
  //

  indentation_observation::
  indentation_observation ()
  {
    this->depth_ = 0;
    this->poisson_ratio_ = 0;
    this->youngs_modulus_ = 0;
  }

  indentation_observation::
  ~indentation_observation ()
  {
    delete this->depth_;
    delete this->poisson_ratio_;
    delete this->youngs_modulus_;
  }

  void indentation_observation::
  _copy (indentation_observation& c) const
  {
    XSDE_UNUSED (c);

    {
      ::common::units_decimal* m = this->depth ()._clone ();
      c.depth (m);
    }

    if (this->poisson_ratio_present ())
    {
      ::common::units_decimal* m = this->poisson_ratio ()._clone ();
      c.poisson_ratio (m);
    }

    if (this->youngs_modulus_present ())
    {
      ::common::units_decimal* m = this->youngs_modulus ()._clone ();
      c.youngs_modulus (m);
    }
  }

  indentation_observation* indentation_observation::
  _clone () const
  {
    indentation_observation* c = new indentation_observation;
    ::xsde::cxx::guard< indentation_observation > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // motility
  //

  motility::
  motility ()
  {
  }

  motility::
  ~motility ()
  {
  }

  void motility::
  _copy (motility& c) const
  {
    XSDE_UNUSED (c);

    this->unrestricted ().copy (c.unrestricted ());

    this->restricted ().copy (c.restricted ());
  }

  motility* motility::
  _clone () const
  {
    motility* c = new motility;
    ::xsde::cxx::guard< motility > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // motility_types
  //

  motility_types::
  motility_types ()
  {
    this->ID_present_ = false;
    this->timescale_ = 0;
    this->restriction_ = 0;
    this->net_displacement_ = 0;
    this->total_displacement_ = 0;
    this->mean_square_displacement_ = 0;
    this->mean_speed_ = 0;
    this->net_speed_ = 0;
    this->persistence_ = 0;
    this->mean_path_length_ = 0;
    this->diffusion_coefficient_ = 0;
    this->custom_ = 0;
  }

  motility_types::
  ~motility_types ()
  {
    delete this->timescale_;
    delete this->restriction_;
    delete this->net_displacement_;
    delete this->total_displacement_;
    delete this->mean_square_displacement_;
    delete this->mean_speed_;
    delete this->net_speed_;
    delete this->persistence_;
    delete this->mean_path_length_;
    delete this->diffusion_coefficient_;
    delete this->custom_;
  }

  void motility_types::
  _copy (motility_types& c) const
  {
    XSDE_UNUSED (c);

    if (this->ID_present ())
      c.ID (this->ID ());

    if (this->timescale_present ())
    {
      ::phenotype_common::timescale* m = this->timescale ()._clone ();
      c.timescale (m);
    }

    if (this->restriction_present ())
    {
      ::variables::experimental_conditions* m = this->restriction ()._clone ();
      c.restriction (m);
    }

    if (this->net_displacement_present ())
    {
      ::common::units_decimal* m = this->net_displacement ()._clone ();
      c.net_displacement (m);
    }

    if (this->total_displacement_present ())
    {
      ::common::units_decimal_nonnegative* m = this->total_displacement ()._clone ();
      c.total_displacement (m);
    }

    if (this->mean_square_displacement_present ())
    {
      ::common::units_decimal_nonnegative* m = this->mean_square_displacement ()._clone ();
      c.mean_square_displacement (m);
    }

    if (this->mean_speed_present ())
    {
      ::common::units_decimal* m = this->mean_speed ()._clone ();
      c.mean_speed (m);
    }

    if (this->net_speed_present ())
    {
      ::common::units_decimal* m = this->net_speed ()._clone ();
      c.net_speed (m);
    }

    if (this->persistence_present ())
    {
      ::common::units_decimal* m = this->persistence ()._clone ();
      c.persistence (m);
    }

    if (this->mean_path_length_present ())
    {
      ::common::units_decimal* m = this->mean_path_length ()._clone ();
      c.mean_path_length (m);
    }

    if (this->diffusion_coefficient_present ())
    {
      ::common::units_decimal* m = this->diffusion_coefficient ()._clone ();
      c.diffusion_coefficient (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  motility_types* motility_types::
  _clone () const
  {
    motility_types* c = new motility_types;
    ::xsde::cxx::guard< motility_types > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // timescale
  //

  timescale::
  timescale ()
  {
    this->mitotic_present_ = false;
  }

  timescale::
  ~timescale ()
  {
  }

  void timescale::
  _copy (timescale& c) const
  {
    XSDE_UNUSED (c);

    const ::common::units_decimal& b = *this;
    b._copy (c);
    if (this->mitotic_present ())
      c.mitotic (this->mitotic ());
  }

  timescale* timescale::
  _clone () const
  {
    timescale* c = new timescale;
    ::xsde::cxx::guard< timescale > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // transport_processes
  //

  transport_processes::
  transport_processes ()
  {
  }

  transport_processes::
  ~transport_processes ()
  {
  }

  void transport_processes::
  _copy (transport_processes& c) const
  {
    XSDE_UNUSED (c);

    this->variable ().copy (c.variable ());
  }

  transport_processes* transport_processes::
  _clone () const
  {
    transport_processes* c = new transport_processes;
    ::xsde::cxx::guard< transport_processes > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // transport_variable
  //

  transport_variable::
  transport_variable ()
  {
    this->units_present_ = false;
    this->ID_present_ = false;
    this->type_present_ = false;
    this->ChEBI_ID_present_ = false;
    this->MeSH_ID_present_ = false;
    this->DrugBank_ID_present_ = false;
    this->GMO_ID_present_ = false;
    this->GO_ID_present_ = false;
    this->UniProt_ID_present_ = false;
    this->PR_ID_present_ = false;
    this->all_ = 0;
  }

  transport_variable::
  ~transport_variable ()
  {
    delete this->all_;
  }

  void transport_variable::
  _copy (transport_variable& c) const
  {
    XSDE_UNUSED (c);

    c.name (this->name ());

    if (this->units_present ())
      c.units (this->units ());

    if (this->ID_present ())
      c.ID (this->ID ());

    if (this->type_present ())
      c.type (this->type ());

    if (this->ChEBI_ID_present ())
      c.ChEBI_ID (this->ChEBI_ID ());

    if (this->MeSH_ID_present ())
      c.MeSH_ID (this->MeSH_ID ());

    if (this->DrugBank_ID_present ())
      c.DrugBank_ID (this->DrugBank_ID ());

    if (this->GMO_ID_present ())
      c.GMO_ID (this->GMO_ID ());

    if (this->GO_ID_present ())
      c.GO_ID (this->GO_ID ());

    if (this->UniProt_ID_present ())
      c.UniProt_ID (this->UniProt_ID ());

    if (this->PR_ID_present ())
      c.PR_ID (this->PR_ID ());

    if (this->all_present ())
    {
      all_type* m = this->all ()._clone ();
      c.all (m);
    }
  }

  transport_variable* transport_variable::
  _clone () const
  {
    transport_variable* c = new transport_variable;
    ::xsde::cxx::guard< transport_variable > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  transport_variable::all_type::
  all_type ()
  {
    this->export_rate_ = 0;
    this->export_rate_per_unit_surface_area_ = 0;
    this->import_rate_ = 0;
    this->import_rate_per_unit_surface_area_ = 0;
    this->saturation_density_ = 0;
    this->custom_ = 0;
  }

  transport_variable::all_type::
  ~all_type ()
  {
    delete this->export_rate_;
    delete this->export_rate_per_unit_surface_area_;
    delete this->import_rate_;
    delete this->import_rate_per_unit_surface_area_;
    delete this->saturation_density_;
    delete this->custom_;
  }

  void transport_variable::all_type::
  _copy (all_type& c) const
  {
    if (this->export_rate_present ())
    {
      ::common::units_decimal* m = this->export_rate ()._clone ();
      c.export_rate (m);
    }

    if (this->export_rate_per_unit_surface_area_present ())
    {
      ::common::units_decimal* m = this->export_rate_per_unit_surface_area ()._clone ();
      c.export_rate_per_unit_surface_area (m);
    }

    if (this->import_rate_present ())
    {
      ::common::units_decimal* m = this->import_rate ()._clone ();
      c.import_rate (m);
    }

    if (this->import_rate_per_unit_surface_area_present ())
    {
      ::common::units_decimal* m = this->import_rate_per_unit_surface_area ()._clone ();
      c.import_rate_per_unit_surface_area (m);
    }

    if (this->saturation_density_present ())
    {
      ::common::units_decimal* m = this->saturation_density ()._clone ();
      c.saturation_density (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  transport_variable::all_type* transport_variable::all_type::
  _clone () const
  {
    all_type* c = new all_type;
    ::xsde::cxx::guard< all_type > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // geometrical_parameters
  //

  geometrical_parameters::
  geometrical_parameters ()
  {
    this->units_present_ = false;
    this->aspect_ratio_ = 0;
    this->circularity_ = 0;
    this->eccentricity_ = 0;
    this->sphericity_ = 0;
    this->custom_ = 0;
  }

  geometrical_parameters::
  ~geometrical_parameters ()
  {
    delete this->aspect_ratio_;
    delete this->circularity_;
    delete this->eccentricity_;
    delete this->sphericity_;
    delete this->custom_;
  }

  void geometrical_parameters::
  _copy (geometrical_parameters& c) const
  {
    XSDE_UNUSED (c);

    if (this->units_present ())
      c.units (this->units ());

    if (this->aspect_ratio_present ())
    {
      ::common::units_decimal_nonnegative* m = this->aspect_ratio ()._clone ();
      c.aspect_ratio (m);
    }

    if (this->circularity_present ())
    {
      ::common::units_decimal_nonnegative* m = this->circularity ()._clone ();
      c.circularity (m);
    }

    if (this->eccentricity_present ())
    {
      ::common::units_decimal_nonnegative* m = this->eccentricity ()._clone ();
      c.eccentricity (m);
    }

    if (this->sphericity_present ())
    {
      ::common::units_decimal_nonnegative* m = this->sphericity ()._clone ();
      c.sphericity (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  geometrical_parameters* geometrical_parameters::
  _clone () const
  {
    geometrical_parameters* c = new geometrical_parameters;
    ::xsde::cxx::guard< geometrical_parameters > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // lengths
  //

  lengths::
  lengths ()
  {
    this->units_present_ = false;
    this->diameter_ = 0;
    this->major_axis_ = 0;
    this->minor_axis_ = 0;
    this->perimeter_ = 0;
    this->radius_ = 0;
    this->custom_ = 0;
  }

  lengths::
  ~lengths ()
  {
    delete this->diameter_;
    delete this->major_axis_;
    delete this->minor_axis_;
    delete this->perimeter_;
    delete this->radius_;
    delete this->custom_;
  }

  void lengths::
  _copy (lengths& c) const
  {
    XSDE_UNUSED (c);

    if (this->units_present ())
      c.units (this->units ());

    if (this->diameter_present ())
    {
      ::common::units_decimal_nonnegative* m = this->diameter ()._clone ();
      c.diameter (m);
    }

    if (this->major_axis_present ())
    {
      ::common::units_decimal_nonnegative* m = this->major_axis ()._clone ();
      c.major_axis (m);
    }

    if (this->minor_axis_present ())
    {
      ::common::units_decimal_nonnegative* m = this->minor_axis ()._clone ();
      c.minor_axis (m);
    }

    if (this->perimeter_present ())
    {
      ::common::units_decimal_nonnegative* m = this->perimeter ()._clone ();
      c.perimeter (m);
    }

    if (this->radius_present ())
    {
      ::common::units_decimal_nonnegative* m = this->radius ()._clone ();
      c.radius (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  lengths* lengths::
  _clone () const
  {
    lengths* c = new lengths;
    ::xsde::cxx::guard< lengths > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // areas_3D
  //

  areas_3D::
  areas_3D ()
  {
    this->units_present_ = false;
    this->free_surface_area_ = 0;
    this->total_surface_area_ = 0;
    this->custom_ = 0;
  }

  areas_3D::
  ~areas_3D ()
  {
    delete this->free_surface_area_;
    delete this->total_surface_area_;
    delete this->custom_;
  }

  void areas_3D::
  _copy (areas_3D& c) const
  {
    XSDE_UNUSED (c);

    if (this->units_present ())
      c.units (this->units ());

    if (this->free_surface_area_present ())
    {
      ::common::units_decimal_nonnegative* m = this->free_surface_area ()._clone ();
      c.free_surface_area (m);
    }

    if (this->total_surface_area_present ())
    {
      ::common::units_decimal_nonnegative* m = this->total_surface_area ()._clone ();
      c.total_surface_area (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  areas_3D* areas_3D::
  _clone () const
  {
    areas_3D* c = new areas_3D;
    ::xsde::cxx::guard< areas_3D > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // areas_2D
  //

  areas_2D::
  areas_2D ()
  {
    this->units_present_ = false;
    this->total_area_ = 0;
    this->custom_ = 0;
  }

  areas_2D::
  ~areas_2D ()
  {
    delete this->total_area_;
    delete this->custom_;
  }

  void areas_2D::
  _copy (areas_2D& c) const
  {
    XSDE_UNUSED (c);

    if (this->units_present ())
      c.units (this->units ());

    if (this->total_area_present ())
    {
      ::common::units_decimal_nonnegative* m = this->total_area ()._clone ();
      c.total_area (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  areas_2D* areas_2D::
  _clone () const
  {
    areas_2D* c = new areas_2D;
    ::xsde::cxx::guard< areas_2D > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // volumes
  //

  volumes::
  volumes ()
  {
    this->units_present_ = false;
    this->fluid_volume_ = 0;
    this->fluid_volume_fraction_ = 0;
    this->solid_calcified_volume_ = 0;
    this->solid_volume_ = 0;
    this->solid_volume_fraction_ = 0;
    this->total_volume_ = 0;
    this->custom_ = 0;
  }

  volumes::
  ~volumes ()
  {
    delete this->fluid_volume_;
    delete this->fluid_volume_fraction_;
    delete this->solid_calcified_volume_;
    delete this->solid_volume_;
    delete this->solid_volume_fraction_;
    delete this->total_volume_;
    delete this->custom_;
  }

  void volumes::
  _copy (volumes& c) const
  {
    XSDE_UNUSED (c);

    if (this->units_present ())
      c.units (this->units ());

    if (this->fluid_volume_present ())
    {
      ::common::units_decimal_nonnegative* m = this->fluid_volume ()._clone ();
      c.fluid_volume (m);
    }

    if (this->fluid_volume_fraction_present ())
    {
      ::common::units_fraction* m = this->fluid_volume_fraction ()._clone ();
      c.fluid_volume_fraction (m);
    }

    if (this->solid_calcified_volume_present ())
    {
      ::common::units_decimal_nonnegative* m = this->solid_calcified_volume ()._clone ();
      c.solid_calcified_volume (m);
    }

    if (this->solid_volume_present ())
    {
      ::common::units_decimal_nonnegative* m = this->solid_volume ()._clone ();
      c.solid_volume (m);
    }

    if (this->solid_volume_fraction_present ())
    {
      ::common::units_fraction* m = this->solid_volume_fraction ()._clone ();
      c.solid_volume_fraction (m);
    }

    if (this->total_volume_present ())
    {
      ::common::units_decimal_nonnegative* m = this->total_volume ()._clone ();
      c.total_volume (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  volumes* volumes::
  _clone () const
  {
    volumes* c = new volumes;
    ::xsde::cxx::guard< volumes > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // geometrical_properties
  //

  geometrical_properties::
  geometrical_properties ()
  {
    this->parameters_ = 0;
    this->lengths_ = 0;
    this->areas_ = 0;
    this->volumes_ = 0;
    this->custom_ = 0;
  }

  geometrical_properties::
  ~geometrical_properties ()
  {
    delete this->parameters_;
    delete this->lengths_;
    delete this->areas_;
    delete this->volumes_;
    delete this->custom_;
  }

  void geometrical_properties::
  _copy (geometrical_properties& c) const
  {
    XSDE_UNUSED (c);

    if (this->parameters_present ())
    {
      ::phenotype_common::geometrical_parameters* m = this->parameters ()._clone ();
      c.parameters (m);
    }

    if (this->lengths_present ())
    {
      ::phenotype_common::lengths* m = this->lengths ()._clone ();
      c.lengths (m);
    }

    if (this->areas_present ())
    {
      ::phenotype_common::areas_3D* m = this->areas ()._clone ();
      c.areas (m);
    }

    if (this->volumes_present ())
    {
      ::phenotype_common::volumes* m = this->volumes ()._clone ();
      c.volumes (m);
    }

    this->cross_section ().copy (c.cross_section ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  geometrical_properties* geometrical_properties::
  _clone () const
  {
    geometrical_properties* c = new geometrical_properties;
    ::xsde::cxx::guard< geometrical_properties > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // cross_section
  //

  cross_section::
  cross_section ()
  {
    this->parameters_ = 0;
    this->lengths_ = 0;
    this->areas_ = 0;
    this->custom_ = 0;
  }

  cross_section::
  ~cross_section ()
  {
    delete this->parameters_;
    delete this->lengths_;
    delete this->areas_;
    delete this->custom_;
  }

  void cross_section::
  _copy (cross_section& c) const
  {
    XSDE_UNUSED (c);

    if (this->parameters_present ())
    {
      ::phenotype_common::geometrical_parameters* m = this->parameters ()._clone ();
      c.parameters (m);
    }

    if (this->lengths_present ())
    {
      ::phenotype_common::lengths* m = this->lengths ()._clone ();
      c.lengths (m);
    }

    if (this->areas_present ())
    {
      ::phenotype_common::areas_2D* m = this->areas ()._clone ();
      c.areas (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  cross_section* cross_section::
  _clone () const
  {
    cross_section* c = new cross_section;
    ::xsde::cxx::guard< cross_section > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // mass
  //

  mass::
  mass ()
  {
    this->biomass_ = 0;
    this->fluid_mass_ = 0;
    this->total_mass_ = 0;
  }

  mass::
  ~mass ()
  {
    delete this->biomass_;
    delete this->fluid_mass_;
    delete this->total_mass_;
  }

  void mass::
  _copy (mass& c) const
  {
    XSDE_UNUSED (c);

    if (this->biomass_present ())
    {
      ::common::units_decimal_nonnegative* m = this->biomass ()._clone ();
      c.biomass (m);
    }

    if (this->fluid_mass_present ())
    {
      ::common::units_decimal_nonnegative* m = this->fluid_mass ()._clone ();
      c.fluid_mass (m);
    }

    if (this->total_mass_present ())
    {
      ::common::units_decimal_nonnegative* m = this->total_mass ()._clone ();
      c.total_mass (m);
    }
  }

  mass* mass::
  _clone () const
  {
    mass* c = new mass;
    ::xsde::cxx::guard< mass > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

