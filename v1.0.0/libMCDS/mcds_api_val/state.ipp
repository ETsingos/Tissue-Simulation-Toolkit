// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef STATE_IPP
#define STATE_IPP

// Begin prologue.
//
//
// End prologue.

#include "common.ipp"

#include "phenotype_common.ipp"

#include "mesh.ipp"

namespace state
{
  // phase_name
  //

  inline
  bool phase_name::
  GO_ID_present () const
  {
    return this->GO_ID_present_;
  }

  inline
  void phase_name::
  GO_ID_present (bool x)
  {
    this->GO_ID_present_ = x;
  }

  inline
  const ::std::string& phase_name::
  GO_ID () const
  {
    return this->GO_ID_;
  }

  inline
  ::std::string& phase_name::
  GO_ID ()
  {
    return this->GO_ID_;
  }

  inline
  void phase_name::
  GO_ID (const ::std::string& x)
  {
    this->GO_ID_ = x;
    this->GO_ID_present_ = true;
  }

  // phase
  //

  inline
  bool phase::
  model_name_present () const
  {
    return this->model_name_present_;
  }

  inline
  void phase::
  model_name_present (bool x)
  {
    this->model_name_present_ = x;
  }

  inline
  const ::std::string& phase::
  model_name () const
  {
    return this->model_name_;
  }

  inline
  ::std::string& phase::
  model_name ()
  {
    return this->model_name_;
  }

  inline
  void phase::
  model_name (const ::std::string& x)
  {
    this->model_name_ = x;
    this->model_name_present_ = true;
  }

  inline
  bool phase::
  phase_name_present () const
  {
    return this->phase_name_present_;
  }

  inline
  void phase::
  phase_name_present (bool x)
  {
    this->phase_name_present_ = x;
  }

  inline
  const ::state::phase_name& phase::
  phase_name () const
  {
    return this->phase_name_;
  }

  inline
  ::state::phase_name& phase::
  phase_name ()
  {
    return this->phase_name_;
  }

  inline
  void phase::
  phase_name (const ::state::phase_name& x)
  {
    this->phase_name_ = x;
    this->phase_name_present_ = true;
  }

  inline
  bool phase::
  cell_cycle_model_index_present () const
  {
    return this->cell_cycle_model_index_present_;
  }

  inline
  void phase::
  cell_cycle_model_index_present (bool x)
  {
    this->cell_cycle_model_index_present_ = x;
  }

  inline
  unsigned short phase::
  cell_cycle_model_index () const
  {
    return this->cell_cycle_model_index_;
  }

  inline
  unsigned short& phase::
  cell_cycle_model_index ()
  {
    return this->cell_cycle_model_index_;
  }

  inline
  void phase::
  cell_cycle_model_index (unsigned short x)
  {
    this->cell_cycle_model_index_ = x;
    this->cell_cycle_model_index_present_ = true;
  }

  inline
  bool phase::
  cell_cycle_phase_index_present () const
  {
    return this->cell_cycle_phase_index_present_;
  }

  inline
  void phase::
  cell_cycle_phase_index_present (bool x)
  {
    this->cell_cycle_phase_index_present_ = x;
  }

  inline
  unsigned short phase::
  cell_cycle_phase_index () const
  {
    return this->cell_cycle_phase_index_;
  }

  inline
  unsigned short& phase::
  cell_cycle_phase_index ()
  {
    return this->cell_cycle_phase_index_;
  }

  inline
  void phase::
  cell_cycle_phase_index (unsigned short x)
  {
    this->cell_cycle_phase_index_ = x;
    this->cell_cycle_phase_index_present_ = true;
  }

  inline
  bool phase::
  elapsed_time_present () const
  {
    return this->elapsed_time_ != 0;
  }

  inline
  const ::common::units_decimal& phase::
  elapsed_time () const
  {
    return *this->elapsed_time_;
  }

  inline
  ::common::units_decimal& phase::
  elapsed_time ()
  {
    return *this->elapsed_time_;
  }

  inline
  void phase::
  elapsed_time (::common::units_decimal* x)
  {
    delete this->elapsed_time_;
    this->elapsed_time_ = x;
  }

  inline
  ::common::units_decimal* phase::
  elapsed_time_detach ()
  {
    ::common::units_decimal* r = this->elapsed_time_;
    this->elapsed_time_ = 0;
    return r;
  }

  inline
  bool phase::
  custom_present () const
  {
    return this->custom_ != 0;
  }

  inline
  const ::common::custom& phase::
  custom () const
  {
    return *this->custom_;
  }

  inline
  ::common::custom& phase::
  custom ()
  {
    return *this->custom_;
  }

  inline
  void phase::
  custom (::common::custom* x)
  {
    delete this->custom_;
    this->custom_ = x;
  }

  inline
  ::common::custom* phase::
  custom_detach ()
  {
    ::common::custom* r = this->custom_;
    this->custom_ = 0;
    return r;
  }

  // orientation_formalism
  //

  inline
  orientation_formalism::
  orientation_formalism ()
  {
  }

  inline
  orientation_formalism::
  orientation_formalism (value_type v)
  {
    value_ = v;
  }

  inline
  void orientation_formalism::
  value (value_type v)
  {
    value_ = v;
  }

  // orientation
  //

  inline
  bool orientation::
  formalism_present () const
  {
    return this->formalism_present_;
  }

  inline
  void orientation::
  formalism_present (bool x)
  {
    this->formalism_present_ = x;
  }

  inline
  const ::state::orientation_formalism& orientation::
  formalism () const
  {
    return this->formalism_;
  }

  inline
  ::state::orientation_formalism& orientation::
  formalism ()
  {
    return this->formalism_;
  }

  inline
  void orientation::
  formalism (const ::state::orientation_formalism& x)
  {
    this->formalism_ = x;
    this->formalism_present_ = true;
  }

  // cell_parts
  //

  inline
  const ::std::string& cell_parts::
  name () const
  {
    return this->name_;
  }

  inline
  ::std::string& cell_parts::
  name ()
  {
    return this->name_;
  }

  inline
  void cell_parts::
  name (const ::std::string& x)
  {
    this->name_ = x;
  }

  inline
  bool cell_parts::
  ID_present () const
  {
    return this->ID_present_;
  }

  inline
  void cell_parts::
  ID_present (bool x)
  {
    this->ID_present_ = x;
  }

  inline
  unsigned int cell_parts::
  ID () const
  {
    return this->ID_;
  }

  inline
  unsigned int& cell_parts::
  ID ()
  {
    return this->ID_;
  }

  inline
  void cell_parts::
  ID (unsigned int x)
  {
    this->ID_ = x;
    this->ID_present_ = true;
  }

  inline
  bool cell_parts::
  orientation_present () const
  {
    return this->orientation_ != 0;
  }

  inline
  const ::state::orientation& cell_parts::
  orientation () const
  {
    return *this->orientation_;
  }

  inline
  ::state::orientation& cell_parts::
  orientation ()
  {
    return *this->orientation_;
  }

  inline
  void cell_parts::
  orientation (::state::orientation* x)
  {
    delete this->orientation_;
    this->orientation_ = x;
  }

  inline
  ::state::orientation* cell_parts::
  orientation_detach ()
  {
    ::state::orientation* r = this->orientation_;
    this->orientation_ = 0;
    return r;
  }

  inline
  bool cell_parts::
  position_present () const
  {
    return this->position_ != 0;
  }

  inline
  const ::common::units_double_list& cell_parts::
  position () const
  {
    return *this->position_;
  }

  inline
  ::common::units_double_list& cell_parts::
  position ()
  {
    return *this->position_;
  }

  inline
  void cell_parts::
  position (::common::units_double_list* x)
  {
    delete this->position_;
    this->position_ = x;
  }

  inline
  ::common::units_double_list* cell_parts::
  position_detach ()
  {
    ::common::units_double_list* r = this->position_;
    this->position_ = 0;
    return r;
  }

  inline
  bool cell_parts::
  velocity_present () const
  {
    return this->velocity_ != 0;
  }

  inline
  const ::common::units_double_list& cell_parts::
  velocity () const
  {
    return *this->velocity_;
  }

  inline
  ::common::units_double_list& cell_parts::
  velocity ()
  {
    return *this->velocity_;
  }

  inline
  void cell_parts::
  velocity (::common::units_double_list* x)
  {
    delete this->velocity_;
    this->velocity_ = x;
  }

  inline
  ::common::units_double_list* cell_parts::
  velocity_detach ()
  {
    ::common::units_double_list* r = this->velocity_;
    this->velocity_ = 0;
    return r;
  }

  inline
  bool cell_parts::
  voxels_present () const
  {
    return this->voxels_ != 0;
  }

  inline
  const ::mesh::int_list_xpath& cell_parts::
  voxels () const
  {
    return *this->voxels_;
  }

  inline
  ::mesh::int_list_xpath& cell_parts::
  voxels ()
  {
    return *this->voxels_;
  }

  inline
  void cell_parts::
  voxels (::mesh::int_list_xpath* x)
  {
    delete this->voxels_;
    this->voxels_ = x;
  }

  inline
  ::mesh::int_list_xpath* cell_parts::
  voxels_detach ()
  {
    ::mesh::int_list_xpath* r = this->voxels_;
    this->voxels_ = 0;
    return r;
  }

  inline
  const cell_parts::cell_part_sequence& cell_parts::
  cell_part () const
  {
    return this->cell_part_;
  }

  inline
  cell_parts::cell_part_sequence& cell_parts::
  cell_part ()
  {
    return this->cell_part_;
  }

  inline
  bool cell_parts::
  custom_present () const
  {
    return this->custom_ != 0;
  }

  inline
  const ::common::custom& cell_parts::
  custom () const
  {
    return *this->custom_;
  }

  inline
  ::common::custom& cell_parts::
  custom ()
  {
    return *this->custom_;
  }

  inline
  void cell_parts::
  custom (::common::custom* x)
  {
    delete this->custom_;
    this->custom_ = x;
  }

  inline
  ::common::custom* cell_parts::
  custom_detach ()
  {
    ::common::custom* r = this->custom_;
    this->custom_ = 0;
    return r;
  }

  // state
  //

  inline
  bool state::
  orientation_present () const
  {
    return this->orientation_ != 0;
  }

  inline
  const ::state::orientation& state::
  orientation () const
  {
    return *this->orientation_;
  }

  inline
  ::state::orientation& state::
  orientation ()
  {
    return *this->orientation_;
  }

  inline
  void state::
  orientation (::state::orientation* x)
  {
    delete this->orientation_;
    this->orientation_ = x;
  }

  inline
  ::state::orientation* state::
  orientation_detach ()
  {
    ::state::orientation* r = this->orientation_;
    this->orientation_ = 0;
    return r;
  }

  inline
  bool state::
  position_present () const
  {
    return this->position_ != 0;
  }

  inline
  const ::common::units_double_list& state::
  position () const
  {
    return *this->position_;
  }

  inline
  ::common::units_double_list& state::
  position ()
  {
    return *this->position_;
  }

  inline
  void state::
  position (::common::units_double_list* x)
  {
    delete this->position_;
    this->position_ = x;
  }

  inline
  ::common::units_double_list* state::
  position_detach ()
  {
    ::common::units_double_list* r = this->position_;
    this->position_ = 0;
    return r;
  }

  inline
  bool state::
  velocity_present () const
  {
    return this->velocity_ != 0;
  }

  inline
  const ::common::units_double_list& state::
  velocity () const
  {
    return *this->velocity_;
  }

  inline
  ::common::units_double_list& state::
  velocity ()
  {
    return *this->velocity_;
  }

  inline
  void state::
  velocity (::common::units_double_list* x)
  {
    delete this->velocity_;
    this->velocity_ = x;
  }

  inline
  ::common::units_double_list* state::
  velocity_detach ()
  {
    ::common::units_double_list* r = this->velocity_;
    this->velocity_ = 0;
    return r;
  }

  inline
  bool state::
  voxels_present () const
  {
    return this->voxels_ != 0;
  }

  inline
  const ::mesh::int_list_xpath& state::
  voxels () const
  {
    return *this->voxels_;
  }

  inline
  ::mesh::int_list_xpath& state::
  voxels ()
  {
    return *this->voxels_;
  }

  inline
  void state::
  voxels (::mesh::int_list_xpath* x)
  {
    delete this->voxels_;
    this->voxels_ = x;
  }

  inline
  ::mesh::int_list_xpath* state::
  voxels_detach ()
  {
    ::mesh::int_list_xpath* r = this->voxels_;
    this->voxels_ = 0;
    return r;
  }

  inline
  const state::cell_part_sequence& state::
  cell_part () const
  {
    return this->cell_part_;
  }

  inline
  state::cell_part_sequence& state::
  cell_part ()
  {
    return this->cell_part_;
  }

  inline
  bool state::
  phase_present () const
  {
    return this->phase_ != 0;
  }

  inline
  const ::state::phase& state::
  phase () const
  {
    return *this->phase_;
  }

  inline
  ::state::phase& state::
  phase ()
  {
    return *this->phase_;
  }

  inline
  void state::
  phase (::state::phase* x)
  {
    delete this->phase_;
    this->phase_ = x;
  }

  inline
  ::state::phase* state::
  phase_detach ()
  {
    ::state::phase* r = this->phase_;
    this->phase_ = 0;
    return r;
  }

  inline
  bool state::
  adhered_cells_present () const
  {
    return this->adhered_cells_ != 0;
  }

  inline
  const ::state::list_of_adhered_cells& state::
  adhered_cells () const
  {
    return *this->adhered_cells_;
  }

  inline
  ::state::list_of_adhered_cells& state::
  adhered_cells ()
  {
    return *this->adhered_cells_;
  }

  inline
  void state::
  adhered_cells (::state::list_of_adhered_cells* x)
  {
    delete this->adhered_cells_;
    this->adhered_cells_ = x;
  }

  inline
  ::state::list_of_adhered_cells* state::
  adhered_cells_detach ()
  {
    ::state::list_of_adhered_cells* r = this->adhered_cells_;
    this->adhered_cells_ = 0;
    return r;
  }

  inline
  bool state::
  custom_present () const
  {
    return this->custom_ != 0;
  }

  inline
  const ::common::custom& state::
  custom () const
  {
    return *this->custom_;
  }

  inline
  ::common::custom& state::
  custom ()
  {
    return *this->custom_;
  }

  inline
  void state::
  custom (::common::custom* x)
  {
    delete this->custom_;
    this->custom_ = x;
  }

  inline
  ::common::custom* state::
  custom_detach ()
  {
    ::common::custom* r = this->custom_;
    this->custom_ = 0;
    return r;
  }

  // adhered_cell
  //

  inline
  unsigned int adhered_cell::
  ID () const
  {
    return this->ID_;
  }

  inline
  unsigned int& adhered_cell::
  ID ()
  {
    return this->ID_;
  }

  inline
  void adhered_cell::
  ID (unsigned int x)
  {
    this->ID_ = x;
  }

  inline
  const ::common::units_decimal_nonnegative& adhered_cell::
  contact_area () const
  {
    return *this->contact_area_;
  }

  inline
  ::common::units_decimal_nonnegative& adhered_cell::
  contact_area ()
  {
    return *this->contact_area_;
  }

  inline
  void adhered_cell::
  contact_area (::common::units_decimal_nonnegative* x)
  {
    delete this->contact_area_;
    this->contact_area_ = x;
  }

  inline
  ::common::units_decimal_nonnegative* adhered_cell::
  contact_area_detach ()
  {
    ::common::units_decimal_nonnegative* r = this->contact_area_;
    this->contact_area_ = 0;
    return r;
  }

  inline
  const ::phenotype_common::cross_section& adhered_cell::
  contact () const
  {
    return *this->contact_;
  }

  inline
  ::phenotype_common::cross_section& adhered_cell::
  contact ()
  {
    return *this->contact_;
  }

  inline
  void adhered_cell::
  contact (::phenotype_common::cross_section* x)
  {
    delete this->contact_;
    this->contact_ = x;
  }

  inline
  ::phenotype_common::cross_section* adhered_cell::
  contact_detach ()
  {
    ::phenotype_common::cross_section* r = this->contact_;
    this->contact_ = 0;
    return r;
  }

  inline
  bool adhered_cell::
  custom_present () const
  {
    return this->custom_ != 0;
  }

  inline
  const ::common::custom& adhered_cell::
  custom () const
  {
    return *this->custom_;
  }

  inline
  ::common::custom& adhered_cell::
  custom ()
  {
    return *this->custom_;
  }

  inline
  void adhered_cell::
  custom (::common::custom* x)
  {
    delete this->custom_;
    this->custom_ = x;
  }

  inline
  ::common::custom* adhered_cell::
  custom_detach ()
  {
    ::common::custom* r = this->custom_;
    this->custom_ = 0;
    return r;
  }

  // list_of_adhered_cells
  //

  inline
  const list_of_adhered_cells::adhered_cell_sequence& list_of_adhered_cells::
  adhered_cell () const
  {
    return this->adhered_cell_;
  }

  inline
  list_of_adhered_cells::adhered_cell_sequence& list_of_adhered_cells::
  adhered_cell ()
  {
    return this->adhered_cell_;
  }

  inline
  bool list_of_adhered_cells::
  custom_present () const
  {
    return this->custom_ != 0;
  }

  inline
  const ::common::custom& list_of_adhered_cells::
  custom () const
  {
    return *this->custom_;
  }

  inline
  ::common::custom& list_of_adhered_cells::
  custom ()
  {
    return *this->custom_;
  }

  inline
  void list_of_adhered_cells::
  custom (::common::custom* x)
  {
    delete this->custom_;
    this->custom_ = x;
  }

  inline
  ::common::custom* list_of_adhered_cells::
  custom_detach ()
  {
    ::common::custom* r = this->custom_;
    this->custom_ = 0;
    return r;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#endif // STATE_IPP
