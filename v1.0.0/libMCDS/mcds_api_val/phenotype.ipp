// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef PHENOTYPE_IPP
#define PHENOTYPE_IPP

// Begin prologue.
//
//
// End prologue.

#include "common.ipp"

#include "cell_cycle.ipp"

#include "phenotype_base.ipp"

namespace phenotype
{
  // phenotype_elements
  //

  inline
  bool phenotype_elements::
  adhesion_present () const
  {
    return this->adhesion_ != 0;
  }

  inline
  const ::phenotype_common::adhesion& phenotype_elements::
  adhesion () const
  {
    return *this->adhesion_;
  }

  inline
  ::phenotype_common::adhesion& phenotype_elements::
  adhesion ()
  {
    return *this->adhesion_;
  }

  inline
  void phenotype_elements::
  adhesion (::phenotype_common::adhesion* x)
  {
    delete this->adhesion_;
    this->adhesion_ = x;
  }

  inline
  ::phenotype_common::adhesion* phenotype_elements::
  adhesion_detach ()
  {
    ::phenotype_common::adhesion* r = this->adhesion_;
    this->adhesion_ = 0;
    return r;
  }

  inline
  bool phenotype_elements::
  geometrical_properties_present () const
  {
    return this->geometrical_properties_ != 0;
  }

  inline
  const ::phenotype_common::geometrical_properties& phenotype_elements::
  geometrical_properties () const
  {
    return *this->geometrical_properties_;
  }

  inline
  ::phenotype_common::geometrical_properties& phenotype_elements::
  geometrical_properties ()
  {
    return *this->geometrical_properties_;
  }

  inline
  void phenotype_elements::
  geometrical_properties (::phenotype_common::geometrical_properties* x)
  {
    delete this->geometrical_properties_;
    this->geometrical_properties_ = x;
  }

  inline
  ::phenotype_common::geometrical_properties* phenotype_elements::
  geometrical_properties_detach ()
  {
    ::phenotype_common::geometrical_properties* r = this->geometrical_properties_;
    this->geometrical_properties_ = 0;
    return r;
  }

  inline
  bool phenotype_elements::
  mass_present () const
  {
    return this->mass_ != 0;
  }

  inline
  const ::phenotype_common::mass& phenotype_elements::
  mass () const
  {
    return *this->mass_;
  }

  inline
  ::phenotype_common::mass& phenotype_elements::
  mass ()
  {
    return *this->mass_;
  }

  inline
  void phenotype_elements::
  mass (::phenotype_common::mass* x)
  {
    delete this->mass_;
    this->mass_ = x;
  }

  inline
  ::phenotype_common::mass* phenotype_elements::
  mass_detach ()
  {
    ::phenotype_common::mass* r = this->mass_;
    this->mass_ = 0;
    return r;
  }

  inline
  bool phenotype_elements::
  mechanics_present () const
  {
    return this->mechanics_ != 0;
  }

  inline
  const ::phenotype_common::mechanics& phenotype_elements::
  mechanics () const
  {
    return *this->mechanics_;
  }

  inline
  ::phenotype_common::mechanics& phenotype_elements::
  mechanics ()
  {
    return *this->mechanics_;
  }

  inline
  void phenotype_elements::
  mechanics (::phenotype_common::mechanics* x)
  {
    delete this->mechanics_;
    this->mechanics_ = x;
  }

  inline
  ::phenotype_common::mechanics* phenotype_elements::
  mechanics_detach ()
  {
    ::phenotype_common::mechanics* r = this->mechanics_;
    this->mechanics_ = 0;
    return r;
  }

  inline
  bool phenotype_elements::
  motility_present () const
  {
    return this->motility_ != 0;
  }

  inline
  const ::phenotype_common::motility& phenotype_elements::
  motility () const
  {
    return *this->motility_;
  }

  inline
  ::phenotype_common::motility& phenotype_elements::
  motility ()
  {
    return *this->motility_;
  }

  inline
  void phenotype_elements::
  motility (::phenotype_common::motility* x)
  {
    delete this->motility_;
    this->motility_ = x;
  }

  inline
  ::phenotype_common::motility* phenotype_elements::
  motility_detach ()
  {
    ::phenotype_common::motility* r = this->motility_;
    this->motility_ = 0;
    return r;
  }

  inline
  bool phenotype_elements::
  PKPD_present () const
  {
    return this->PKPD_ != 0;
  }

  inline
  const ::pkpd::PKPD& phenotype_elements::
  PKPD () const
  {
    return *this->PKPD_;
  }

  inline
  ::pkpd::PKPD& phenotype_elements::
  PKPD ()
  {
    return *this->PKPD_;
  }

  inline
  void phenotype_elements::
  PKPD (::pkpd::PKPD* x)
  {
    delete this->PKPD_;
    this->PKPD_ = x;
  }

  inline
  ::pkpd::PKPD* phenotype_elements::
  PKPD_detach ()
  {
    ::pkpd::PKPD* r = this->PKPD_;
    this->PKPD_ = 0;
    return r;
  }

  inline
  bool phenotype_elements::
  timescale_present () const
  {
    return this->timescale_ != 0;
  }

  inline
  const ::phenotype_base::expected_timescale& phenotype_elements::
  timescale () const
  {
    return *this->timescale_;
  }

  inline
  ::phenotype_base::expected_timescale& phenotype_elements::
  timescale ()
  {
    return *this->timescale_;
  }

  inline
  void phenotype_elements::
  timescale (::phenotype_base::expected_timescale* x)
  {
    delete this->timescale_;
    this->timescale_ = x;
  }

  inline
  ::phenotype_base::expected_timescale* phenotype_elements::
  timescale_detach ()
  {
    ::phenotype_base::expected_timescale* r = this->timescale_;
    this->timescale_ = 0;
    return r;
  }

  inline
  bool phenotype_elements::
  transport_processes_present () const
  {
    return this->transport_processes_ != 0;
  }

  inline
  const ::phenotype_common::transport_processes& phenotype_elements::
  transport_processes () const
  {
    return *this->transport_processes_;
  }

  inline
  ::phenotype_common::transport_processes& phenotype_elements::
  transport_processes ()
  {
    return *this->transport_processes_;
  }

  inline
  void phenotype_elements::
  transport_processes (::phenotype_common::transport_processes* x)
  {
    delete this->transport_processes_;
    this->transport_processes_ = x;
  }

  inline
  ::phenotype_common::transport_processes* phenotype_elements::
  transport_processes_detach ()
  {
    ::phenotype_common::transport_processes* r = this->transport_processes_;
    this->transport_processes_ = 0;
    return r;
  }

  inline
  bool phenotype_elements::
  custom_present () const
  {
    return this->custom_ != 0;
  }

  inline
  const ::common::custom& phenotype_elements::
  custom () const
  {
    return *this->custom_;
  }

  inline
  ::common::custom& phenotype_elements::
  custom ()
  {
    return *this->custom_;
  }

  inline
  void phenotype_elements::
  custom (::common::custom* x)
  {
    delete this->custom_;
    this->custom_ = x;
  }

  inline
  ::common::custom* phenotype_elements::
  custom_detach ()
  {
    ::common::custom* r = this->custom_;
    this->custom_ = 0;
    return r;
  }

  // phenotype
  //

  inline
  bool phenotype::
  type_present () const
  {
    return this->type_present_;
  }

  inline
  void phenotype::
  type_present (bool x)
  {
    this->type_present_ = x;
  }

  inline
  const ::phenotype_base::phenotype_type& phenotype::
  type () const
  {
    return this->type_;
  }

  inline
  ::phenotype_base::phenotype_type& phenotype::
  type ()
  {
    return this->type_;
  }

  inline
  void phenotype::
  type (const ::phenotype_base::phenotype_type& x)
  {
    this->type_ = x;
    this->type_present_ = true;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#endif // PHENOTYPE_IPP
