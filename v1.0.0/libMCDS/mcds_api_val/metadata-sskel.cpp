// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "metadata-sskel.hpp"

#include <assert.h>

#include <string.h>
#include <xsde/cxx/serializer/substitution-map.hxx>
#include <xsde/cxx/serializer/validating/inheritance-map.hxx>

static
const ::xsde::cxx::serializer::substitution_map_init
_xsde_substitution_map_init_;

static
const ::xsde::cxx::serializer::validating::inheritance_map_init
_xsde_inheritance_map_init_;

namespace metadata
{
  // URL_sskel
  //

  const char* URL_sskel::
  _static_type ()
  {
    return "URL metadata";
  }

  const char* URL_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  static
  const ::xsde::cxx::serializer::validating::inheritance_map_entry
  _xsde_URL_sskel_inheritance_map_entry_ (
    URL_sskel::_static_type (),
    ::xml_schema::string_sskel::_static_type ());

  void URL_sskel::
  pre (const ::std::string& x)
  {
    assert (this->string_impl_);
    this->string_impl_->pre (x);
  }

  // orcid_identifier_sskel
  //

  bool orcid_identifier_sskel::
  path_present ()
  {
    return this->orcid_identifier_impl_ ? this->orcid_identifier_impl_->path_present () : false;
  }

  bool orcid_identifier_sskel::
  given_names_present ()
  {
    return this->orcid_identifier_impl_ ? this->orcid_identifier_impl_->given_names_present () : false;
  }

  bool orcid_identifier_sskel::
  family_name_present ()
  {
    return this->orcid_identifier_impl_ ? this->orcid_identifier_impl_->family_name_present () : false;
  }

  bool orcid_identifier_sskel::
  email_present ()
  {
    return this->orcid_identifier_impl_ ? this->orcid_identifier_impl_->email_present () : false;
  }

  bool orcid_identifier_sskel::
  url_present ()
  {
    return this->orcid_identifier_impl_ ? this->orcid_identifier_impl_->url_present () : false;
  }

  bool orcid_identifier_sskel::
  organization_name_present ()
  {
    return this->orcid_identifier_impl_ ? this->orcid_identifier_impl_->organization_name_present () : false;
  }

  bool orcid_identifier_sskel::
  department_name_present ()
  {
    return this->orcid_identifier_impl_ ? this->orcid_identifier_impl_->department_name_present () : false;
  }

  void orcid_identifier_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->path_serializer_)
      this->path_serializer_->_reset ();

    if (this->path_serializer_map_)
      this->path_serializer_map_->reset ();

    if (this->given_names_serializer_)
      this->given_names_serializer_->_reset ();

    if (this->given_names_serializer_map_)
      this->given_names_serializer_map_->reset ();

    if (this->family_name_serializer_)
      this->family_name_serializer_->_reset ();

    if (this->family_name_serializer_map_)
      this->family_name_serializer_map_->reset ();

    if (this->email_serializer_)
      this->email_serializer_->_reset ();

    if (this->email_serializer_map_)
      this->email_serializer_map_->reset ();

    if (this->url_serializer_)
      this->url_serializer_->_reset ();

    if (this->url_serializer_map_)
      this->url_serializer_map_->reset ();

    if (this->organization_name_serializer_)
      this->organization_name_serializer_->_reset ();

    if (this->organization_name_serializer_map_)
      this->organization_name_serializer_map_->reset ();

    if (this->department_name_serializer_)
      this->department_name_serializer_->_reset ();

    if (this->department_name_serializer_map_)
      this->department_name_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* orcid_identifier_sskel::
  _static_type ()
  {
    return "orcid-identifier metadata";
  }

  const char* orcid_identifier_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // orcid_person_sskel
  //

  void orcid_person_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->orcid_identifier_serializer_)
      this->orcid_identifier_serializer_->_reset ();

    if (this->orcid_identifier_serializer_map_)
      this->orcid_identifier_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* orcid_person_sskel::
  _static_type ()
  {
    return "orcid-person metadata";
  }

  const char* orcid_person_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // classification_sskel
  //

  void classification_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->classification_number_serializer_)
      this->classification_number_serializer_->_reset ();

    if (this->classification_number_serializer_map_)
      this->classification_number_serializer_map_->reset ();

    if (this->line_serializer_)
      this->line_serializer_->_reset ();

    if (this->line_serializer_map_)
      this->line_serializer_map_->reset ();

    if (this->variant_serializer_)
      this->variant_serializer_->_reset ();

    if (this->variant_serializer_map_)
      this->variant_serializer_map_->reset ();

    if (this->branch_serializer_)
      this->branch_serializer_->_reset ();

    if (this->branch_serializer_map_)
      this->branch_serializer_map_->reset ();

    if (this->version_serializer_)
      this->version_serializer_->_reset ();

    if (this->version_serializer_map_)
      this->version_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* classification_sskel::
  _static_type ()
  {
    return "classification metadata";
  }

  const char* classification_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // curation_sskel
  //

  bool curation_sskel::
  curated_present ()
  {
    return this->curation_impl_ ? this->curation_impl_->curated_present () : false;
  }

  bool curation_sskel::
  any_attribute_next ()
  {
    return this->curation_impl_ ? this->curation_impl_->any_attribute_next () : false;
  }

  void curation_sskel::
  any_attribute (::std::string& ns, ::std::string& n)
  {
    if (this->curation_impl_)
      this->curation_impl_->any_attribute (ns, n);
  }

  void curation_sskel::
  serialize_any_attribute ()
  {
    if (this->curation_impl_)
      this->curation_impl_->serialize_any_attribute ();
  }

  bool curation_sskel::
  curator_present ()
  {
    return this->curation_impl_ ? this->curation_impl_->curator_present () : false;
  }

  bool curation_sskel::
  any_next ()
  {
    return this->curation_impl_ ? this->curation_impl_->any_next () : false;
  }

  void curation_sskel::
  any (::std::string& ns, ::std::string& n)
  {
    if (this->curation_impl_)
      this->curation_impl_->any (ns, n);
  }

  void curation_sskel::
  serialize_any ()
  {
    if (this->curation_impl_)
      this->curation_impl_->serialize_any ();
  }

  void curation_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    if (this->curated_serializer_)
      this->curated_serializer_->_reset ();

    this->resetting_ = true;

    if (this->created_serializer_)
      this->created_serializer_->_reset ();

    if (this->created_serializer_map_)
      this->created_serializer_map_->reset ();

    if (this->last_modified_serializer_)
      this->last_modified_serializer_->_reset ();

    if (this->last_modified_serializer_map_)
      this->last_modified_serializer_map_->reset ();

    if (this->classification_serializer_)
      this->classification_serializer_->_reset ();

    if (this->classification_serializer_map_)
      this->classification_serializer_map_->reset ();

    if (this->version_serializer_)
      this->version_serializer_->_reset ();

    if (this->version_serializer_map_)
      this->version_serializer_map_->reset ();

    if (this->creator_serializer_)
      this->creator_serializer_->_reset ();

    if (this->creator_serializer_map_)
      this->creator_serializer_map_->reset ();

    if (this->current_contact_serializer_)
      this->current_contact_serializer_->_reset ();

    if (this->current_contact_serializer_map_)
      this->current_contact_serializer_map_->reset ();

    if (this->curator_serializer_)
      this->curator_serializer_->_reset ();

    if (this->curator_serializer_map_)
      this->curator_serializer_map_->reset ();

    if (this->last_modified_by_serializer_)
      this->last_modified_by_serializer_->_reset ();

    if (this->last_modified_by_serializer_map_)
      this->last_modified_by_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* curation_sskel::
  _static_type ()
  {
    return "curation metadata";
  }

  const char* curation_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // citation_sskel
  //

  bool citation_sskel::
  text_present ()
  {
    return this->citation_impl_ ? this->citation_impl_->text_present () : false;
  }

  bool citation_sskel::
  DOI_present ()
  {
    return this->citation_impl_ ? this->citation_impl_->DOI_present () : false;
  }

  bool citation_sskel::
  URL_next ()
  {
    return this->citation_impl_ ? this->citation_impl_->URL_next () : false;
  }

  bool citation_sskel::
  PMID_present ()
  {
    return this->citation_impl_ ? this->citation_impl_->PMID_present () : false;
  }

  bool citation_sskel::
  PMCID_present ()
  {
    return this->citation_impl_ ? this->citation_impl_->PMCID_present () : false;
  }

  bool citation_sskel::
  arXiv_present ()
  {
    return this->citation_impl_ ? this->citation_impl_->arXiv_present () : false;
  }

  bool citation_sskel::
  notes_present ()
  {
    return this->citation_impl_ ? this->citation_impl_->notes_present () : false;
  }

  bool citation_sskel::
  custom_present ()
  {
    return this->citation_impl_ ? this->citation_impl_->custom_present () : false;
  }

  void citation_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->text_serializer_)
      this->text_serializer_->_reset ();

    if (this->text_serializer_map_)
      this->text_serializer_map_->reset ();

    if (this->DOI_serializer_)
      this->DOI_serializer_->_reset ();

    if (this->DOI_serializer_map_)
      this->DOI_serializer_map_->reset ();

    if (this->URL_serializer_)
      this->URL_serializer_->_reset ();

    if (this->URL_serializer_map_)
      this->URL_serializer_map_->reset ();

    if (this->PMID_serializer_)
      this->PMID_serializer_->_reset ();

    if (this->PMID_serializer_map_)
      this->PMID_serializer_map_->reset ();

    if (this->PMCID_serializer_)
      this->PMCID_serializer_->_reset ();

    if (this->PMCID_serializer_map_)
      this->PMCID_serializer_map_->reset ();

    if (this->arXiv_serializer_)
      this->arXiv_serializer_->_reset ();

    if (this->arXiv_serializer_map_)
      this->arXiv_serializer_map_->reset ();

    if (this->notes_serializer_)
      this->notes_serializer_->_reset ();

    if (this->notes_serializer_map_)
      this->notes_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* citation_sskel::
  _static_type ()
  {
    return "citation metadata";
  }

  const char* citation_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // data_origin_sskel
  //

  bool data_origin_sskel::
  ID_present ()
  {
    return this->data_origin_impl_ ? this->data_origin_impl_->ID_present () : false;
  }

  bool data_origin_sskel::
  instrumentation_information_present ()
  {
    return this->data_origin_impl_ ? this->data_origin_impl_->instrumentation_information_present () : false;
  }

  bool data_origin_sskel::
  experimental_protocol_present ()
  {
    return this->data_origin_impl_ ? this->data_origin_impl_->experimental_protocol_present () : false;
  }

  bool data_origin_sskel::
  citation_next ()
  {
    return this->data_origin_impl_ ? this->data_origin_impl_->citation_next () : false;
  }

  bool data_origin_sskel::
  xpath_present ()
  {
    return this->data_origin_impl_ ? this->data_origin_impl_->xpath_present () : false;
  }

  bool data_origin_sskel::
  notes_present ()
  {
    return this->data_origin_impl_ ? this->data_origin_impl_->notes_present () : false;
  }

  bool data_origin_sskel::
  custom_present ()
  {
    return this->data_origin_impl_ ? this->data_origin_impl_->custom_present () : false;
  }

  void data_origin_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    if (this->ID_serializer_)
      this->ID_serializer_->_reset ();

    this->resetting_ = true;

    if (this->instrumentation_information_serializer_)
      this->instrumentation_information_serializer_->_reset ();

    if (this->instrumentation_information_serializer_map_)
      this->instrumentation_information_serializer_map_->reset ();

    if (this->experimental_protocol_serializer_)
      this->experimental_protocol_serializer_->_reset ();

    if (this->experimental_protocol_serializer_map_)
      this->experimental_protocol_serializer_map_->reset ();

    if (this->citation_serializer_)
      this->citation_serializer_->_reset ();

    if (this->citation_serializer_map_)
      this->citation_serializer_map_->reset ();

    if (this->xpath_serializer_)
      this->xpath_serializer_->_reset ();

    if (this->xpath_serializer_map_)
      this->xpath_serializer_map_->reset ();

    if (this->notes_serializer_)
      this->notes_serializer_->_reset ();

    if (this->notes_serializer_map_)
      this->notes_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* data_origin_sskel::
  _static_type ()
  {
    return "data_origin metadata";
  }

  const char* data_origin_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // data_origins_sskel
  //

  bool data_origins_sskel::
  custom_present ()
  {
    return this->data_origins_impl_ ? this->data_origins_impl_->custom_present () : false;
  }

  void data_origins_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->data_origin_serializer_)
      this->data_origin_serializer_->_reset ();

    if (this->data_origin_serializer_map_)
      this->data_origin_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* data_origins_sskel::
  _static_type ()
  {
    return "data_origins metadata";
  }

  const char* data_origins_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // data_analysis_sskel
  //

  bool data_analysis_sskel::
  URL_present ()
  {
    return this->data_analysis_impl_ ? this->data_analysis_impl_->URL_present () : false;
  }

  bool data_analysis_sskel::
  citation_present ()
  {
    return this->data_analysis_impl_ ? this->data_analysis_impl_->citation_present () : false;
  }

  bool data_analysis_sskel::
  software_present ()
  {
    return this->data_analysis_impl_ ? this->data_analysis_impl_->software_present () : false;
  }

  bool data_analysis_sskel::
  xpath_present ()
  {
    return this->data_analysis_impl_ ? this->data_analysis_impl_->xpath_present () : false;
  }

  bool data_analysis_sskel::
  notes_present ()
  {
    return this->data_analysis_impl_ ? this->data_analysis_impl_->notes_present () : false;
  }

  bool data_analysis_sskel::
  custom_present ()
  {
    return this->data_analysis_impl_ ? this->data_analysis_impl_->custom_present () : false;
  }

  void data_analysis_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->URL_serializer_)
      this->URL_serializer_->_reset ();

    if (this->URL_serializer_map_)
      this->URL_serializer_map_->reset ();

    if (this->citation_serializer_)
      this->citation_serializer_->_reset ();

    if (this->citation_serializer_map_)
      this->citation_serializer_map_->reset ();

    if (this->software_serializer_)
      this->software_serializer_->_reset ();

    if (this->software_serializer_map_)
      this->software_serializer_map_->reset ();

    if (this->xpath_serializer_)
      this->xpath_serializer_->_reset ();

    if (this->xpath_serializer_map_)
      this->xpath_serializer_map_->reset ();

    if (this->notes_serializer_)
      this->notes_serializer_->_reset ();

    if (this->notes_serializer_map_)
      this->notes_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* data_analysis_sskel::
  _static_type ()
  {
    return "data_analysis metadata";
  }

  const char* data_analysis_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // software_sskel
  //

  bool software_sskel::
  software_name_present ()
  {
    return this->software_impl_ ? this->software_impl_->software_name_present () : false;
  }

  bool software_sskel::
  software_version_present ()
  {
    return this->software_impl_ ? this->software_impl_->software_version_present () : false;
  }

  bool software_sskel::
  software_input_configuration_present ()
  {
    return this->software_impl_ ? this->software_impl_->software_input_configuration_present () : false;
  }

  bool software_sskel::
  name_present ()
  {
    return this->software_impl_ ? this->software_impl_->name_present () : false;
  }

  bool software_sskel::
  version_present ()
  {
    return this->software_impl_ ? this->software_impl_->version_present () : false;
  }

  bool software_sskel::
  input_configuration_present ()
  {
    return this->software_impl_ ? this->software_impl_->input_configuration_present () : false;
  }

  bool software_sskel::
  URL_present ()
  {
    return this->software_impl_ ? this->software_impl_->URL_present () : false;
  }

  bool software_sskel::
  creator_present ()
  {
    return this->software_impl_ ? this->software_impl_->creator_present () : false;
  }

  bool software_sskel::
  citation_present ()
  {
    return this->software_impl_ ? this->software_impl_->citation_present () : false;
  }

  bool software_sskel::
  user_present ()
  {
    return this->software_impl_ ? this->software_impl_->user_present () : false;
  }

  bool software_sskel::
  custom_present ()
  {
    return this->software_impl_ ? this->software_impl_->custom_present () : false;
  }

  void software_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->software_name_serializer_)
      this->software_name_serializer_->_reset ();

    if (this->software_name_serializer_map_)
      this->software_name_serializer_map_->reset ();

    if (this->software_version_serializer_)
      this->software_version_serializer_->_reset ();

    if (this->software_version_serializer_map_)
      this->software_version_serializer_map_->reset ();

    if (this->software_input_configuration_serializer_)
      this->software_input_configuration_serializer_->_reset ();

    if (this->software_input_configuration_serializer_map_)
      this->software_input_configuration_serializer_map_->reset ();

    if (this->name_serializer_)
      this->name_serializer_->_reset ();

    if (this->name_serializer_map_)
      this->name_serializer_map_->reset ();

    if (this->version_serializer_)
      this->version_serializer_->_reset ();

    if (this->version_serializer_map_)
      this->version_serializer_map_->reset ();

    if (this->input_configuration_serializer_)
      this->input_configuration_serializer_->_reset ();

    if (this->input_configuration_serializer_map_)
      this->input_configuration_serializer_map_->reset ();

    if (this->URL_serializer_)
      this->URL_serializer_->_reset ();

    if (this->URL_serializer_map_)
      this->URL_serializer_map_->reset ();

    if (this->creator_serializer_)
      this->creator_serializer_->_reset ();

    if (this->creator_serializer_map_)
      this->creator_serializer_map_->reset ();

    if (this->citation_serializer_)
      this->citation_serializer_->_reset ();

    if (this->citation_serializer_map_)
      this->citation_serializer_map_->reset ();

    if (this->user_serializer_)
      this->user_serializer_->_reset ();

    if (this->user_serializer_map_)
      this->user_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* software_sskel::
  _static_type ()
  {
    return "software metadata";
  }

  const char* software_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // species_sskel
  //

  bool species_sskel::
  MeSH_ID_present ()
  {
    return this->species_impl_ ? this->species_impl_->MeSH_ID_present () : false;
  }

  void species_sskel::
  _reset ()
  {
    typedef ::xml_schema::string_sskel base;
    base::_reset ();

    if (this->MeSH_ID_serializer_)
      this->MeSH_ID_serializer_->_reset ();
  }

  const char* species_sskel::
  _static_type ()
  {
    return "species metadata";
  }

  const char* species_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  static
  const ::xsde::cxx::serializer::validating::inheritance_map_entry
  _xsde_species_sskel_inheritance_map_entry_ (
    species_sskel::_static_type (),
    ::xml_schema::string_sskel::_static_type ());

  void species_sskel::
  pre (const ::std::string& x)
  {
    assert (this->string_impl_);
    this->string_impl_->pre (x);
  }

  // disease_sskel
  //

  bool disease_sskel::
  EFO_ID_present ()
  {
    return this->disease_impl_ ? this->disease_impl_->EFO_ID_present () : false;
  }

  bool disease_sskel::
  DOID_ID_present ()
  {
    return this->disease_impl_ ? this->disease_impl_->DOID_ID_present () : false;
  }

  void disease_sskel::
  _reset ()
  {
    typedef ::xml_schema::string_sskel base;
    base::_reset ();

    if (this->EFO_ID_serializer_)
      this->EFO_ID_serializer_->_reset ();

    if (this->DOID_ID_serializer_)
      this->DOID_ID_serializer_->_reset ();
  }

  const char* disease_sskel::
  _static_type ()
  {
    return "disease metadata";
  }

  const char* disease_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  static
  const ::xsde::cxx::serializer::validating::inheritance_map_entry
  _xsde_disease_sskel_inheritance_map_entry_ (
    disease_sskel::_static_type (),
    ::xml_schema::string_sskel::_static_type ());

  void disease_sskel::
  pre (const ::std::string& x)
  {
    assert (this->string_impl_);
    this->string_impl_->pre (x);
  }

  // patient_derived_sskel
  //

  bool patient_derived_sskel::
  patient_ID_present ()
  {
    return this->patient_derived_impl_ ? this->patient_derived_impl_->patient_ID_present () : false;
  }

  void patient_derived_sskel::
  _reset ()
  {
    typedef ::xml_schema::boolean_sskel base;
    base::_reset ();

    if (this->patient_ID_serializer_)
      this->patient_ID_serializer_->_reset ();
  }

  const char* patient_derived_sskel::
  _static_type ()
  {
    return "patient_derived metadata";
  }

  const char* patient_derived_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  static
  const ::xsde::cxx::serializer::validating::inheritance_map_entry
  _xsde_patient_derived_sskel_inheritance_map_entry_ (
    patient_derived_sskel::_static_type (),
    ::xml_schema::boolean_sskel::_static_type ());

  void patient_derived_sskel::
  pre (bool x)
  {
    assert (this->boolean_impl_);
    this->boolean_impl_->pre (x);
  }

  // cell_origin_sskel
  //

  bool cell_origin_sskel::
  BTO_ID_present ()
  {
    return this->cell_origin_impl_ ? this->cell_origin_impl_->BTO_ID_present () : false;
  }

  bool cell_origin_sskel::
  CLO_ID_present ()
  {
    return this->cell_origin_impl_ ? this->cell_origin_impl_->CLO_ID_present () : false;
  }

  bool cell_origin_sskel::
  species_present ()
  {
    return this->cell_origin_impl_ ? this->cell_origin_impl_->species_present () : false;
  }

  bool cell_origin_sskel::
  strain_present ()
  {
    return this->cell_origin_impl_ ? this->cell_origin_impl_->strain_present () : false;
  }

  bool cell_origin_sskel::
  organ_present ()
  {
    return this->cell_origin_impl_ ? this->cell_origin_impl_->organ_present () : false;
  }

  bool cell_origin_sskel::
  disease_present ()
  {
    return this->cell_origin_impl_ ? this->cell_origin_impl_->disease_present () : false;
  }

  bool cell_origin_sskel::
  morphology_present ()
  {
    return this->cell_origin_impl_ ? this->cell_origin_impl_->morphology_present () : false;
  }

  bool cell_origin_sskel::
  patient_derived_present ()
  {
    return this->cell_origin_impl_ ? this->cell_origin_impl_->patient_derived_present () : false;
  }

  bool cell_origin_sskel::
  custom_present ()
  {
    return this->cell_origin_impl_ ? this->cell_origin_impl_->custom_present () : false;
  }

  void cell_origin_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->BTO_ID_serializer_)
      this->BTO_ID_serializer_->_reset ();

    if (this->BTO_ID_serializer_map_)
      this->BTO_ID_serializer_map_->reset ();

    if (this->CLO_ID_serializer_)
      this->CLO_ID_serializer_->_reset ();

    if (this->CLO_ID_serializer_map_)
      this->CLO_ID_serializer_map_->reset ();

    if (this->species_serializer_)
      this->species_serializer_->_reset ();

    if (this->species_serializer_map_)
      this->species_serializer_map_->reset ();

    if (this->strain_serializer_)
      this->strain_serializer_->_reset ();

    if (this->strain_serializer_map_)
      this->strain_serializer_map_->reset ();

    if (this->organ_serializer_)
      this->organ_serializer_->_reset ();

    if (this->organ_serializer_map_)
      this->organ_serializer_map_->reset ();

    if (this->disease_serializer_)
      this->disease_serializer_->_reset ();

    if (this->disease_serializer_map_)
      this->disease_serializer_map_->reset ();

    if (this->morphology_serializer_)
      this->morphology_serializer_->_reset ();

    if (this->morphology_serializer_map_)
      this->morphology_serializer_map_->reset ();

    if (this->patient_derived_serializer_)
      this->patient_derived_serializer_->_reset ();

    if (this->patient_derived_serializer_map_)
      this->patient_derived_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* cell_origin_sskel::
  _static_type ()
  {
    return "cell_origin metadata";
  }

  const char* cell_origin_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // MultiCellDB_sskel
  //

  bool MultiCellDB_sskel::
  ID_present ()
  {
    return this->MultiCellDB_impl_ ? this->MultiCellDB_impl_->ID_present () : false;
  }

  bool MultiCellDB_sskel::
  name_present ()
  {
    return this->MultiCellDB_impl_ ? this->MultiCellDB_impl_->name_present () : false;
  }

  void MultiCellDB_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->ID_serializer_)
      this->ID_serializer_->_reset ();

    if (this->ID_serializer_map_)
      this->ID_serializer_map_->reset ();

    if (this->name_serializer_)
      this->name_serializer_->_reset ();

    if (this->name_serializer_map_)
      this->name_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* MultiCellDB_sskel::
  _static_type ()
  {
    return "MultiCellDB metadata";
  }

  const char* MultiCellDB_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // rights_sskel
  //

  bool rights_sskel::
  custom_present ()
  {
    return this->rights_impl_ ? this->rights_impl_->custom_present () : false;
  }

  void rights_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->license_serializer_)
      this->license_serializer_->_reset ();

    if (this->license_serializer_map_)
      this->license_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* rights_sskel::
  _static_type ()
  {
    return "rights metadata";
  }

  const char* rights_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // license_sskel
  //

  bool license_sskel::
  notes_present ()
  {
    return this->license_impl_ ? this->license_impl_->notes_present () : false;
  }

  bool license_sskel::
  custom_present ()
  {
    return this->license_impl_ ? this->license_impl_->custom_present () : false;
  }

  void license_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->LicenseDocument_serializer_)
      this->LicenseDocument_serializer_->_reset ();

    if (this->LicenseDocument_serializer_map_)
      this->LicenseDocument_serializer_map_->reset ();

    if (this->notes_serializer_)
      this->notes_serializer_->_reset ();

    if (this->notes_serializer_map_)
      this->notes_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* license_sskel::
  _static_type ()
  {
    return "license metadata";
  }

  const char* license_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // LicenseDocument_sskel
  //

  bool LicenseDocument_sskel::
  URL_present ()
  {
    return this->LicenseDocument_impl_ ? this->LicenseDocument_impl_->URL_present () : false;
  }

  bool LicenseDocument_sskel::
  custom_present ()
  {
    return this->LicenseDocument_impl_ ? this->LicenseDocument_impl_->custom_present () : false;
  }

  void LicenseDocument_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->name_serializer_)
      this->name_serializer_->_reset ();

    if (this->name_serializer_map_)
      this->name_serializer_map_->reset ();

    if (this->URL_serializer_)
      this->URL_serializer_->_reset ();

    if (this->URL_serializer_map_)
      this->URL_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* LicenseDocument_sskel::
  _static_type ()
  {
    return "LicenseDocument metadata";
  }

  const char* LicenseDocument_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // metadata_sskel
  //

  bool metadata_sskel::
  MultiCellDB_present ()
  {
    return this->metadata_impl_ ? this->metadata_impl_->MultiCellDB_present () : false;
  }

  bool metadata_sskel::
  description_present ()
  {
    return this->metadata_impl_ ? this->metadata_impl_->description_present () : false;
  }

  bool metadata_sskel::
  software_present ()
  {
    return this->metadata_impl_ ? this->metadata_impl_->software_present () : false;
  }

  bool metadata_sskel::
  citation_present ()
  {
    return this->metadata_impl_ ? this->metadata_impl_->citation_present () : false;
  }

  bool metadata_sskel::
  curation_present ()
  {
    return this->metadata_impl_ ? this->metadata_impl_->curation_present () : false;
  }

  bool metadata_sskel::
  data_origins_present ()
  {
    return this->metadata_impl_ ? this->metadata_impl_->data_origins_present () : false;
  }

  bool metadata_sskel::
  data_analysis_next ()
  {
    return this->metadata_impl_ ? this->metadata_impl_->data_analysis_next () : false;
  }

  bool metadata_sskel::
  cell_origin_present ()
  {
    return this->metadata_impl_ ? this->metadata_impl_->cell_origin_present () : false;
  }

  bool metadata_sskel::
  current_time_present ()
  {
    return this->metadata_impl_ ? this->metadata_impl_->current_time_present () : false;
  }

  bool metadata_sskel::
  current_runtime_present ()
  {
    return this->metadata_impl_ ? this->metadata_impl_->current_runtime_present () : false;
  }

  bool metadata_sskel::
  created_present ()
  {
    return this->metadata_impl_ ? this->metadata_impl_->created_present () : false;
  }

  bool metadata_sskel::
  last_modified_present ()
  {
    return this->metadata_impl_ ? this->metadata_impl_->last_modified_present () : false;
  }

  bool metadata_sskel::
  notes_present ()
  {
    return this->metadata_impl_ ? this->metadata_impl_->notes_present () : false;
  }

  bool metadata_sskel::
  custom_present ()
  {
    return this->metadata_impl_ ? this->metadata_impl_->custom_present () : false;
  }

  void metadata_sskel::
  _reset ()
  {
    if (this->resetting_)
      return;

    typedef ::xsde::cxx::serializer::validating::complex_content base;
    base::_reset ();

    this->resetting_ = true;

    if (this->MultiCellDB_serializer_)
      this->MultiCellDB_serializer_->_reset ();

    if (this->MultiCellDB_serializer_map_)
      this->MultiCellDB_serializer_map_->reset ();

    if (this->description_serializer_)
      this->description_serializer_->_reset ();

    if (this->description_serializer_map_)
      this->description_serializer_map_->reset ();

    if (this->software_serializer_)
      this->software_serializer_->_reset ();

    if (this->software_serializer_map_)
      this->software_serializer_map_->reset ();

    if (this->citation_serializer_)
      this->citation_serializer_->_reset ();

    if (this->citation_serializer_map_)
      this->citation_serializer_map_->reset ();

    if (this->curation_serializer_)
      this->curation_serializer_->_reset ();

    if (this->curation_serializer_map_)
      this->curation_serializer_map_->reset ();

    if (this->data_origins_serializer_)
      this->data_origins_serializer_->_reset ();

    if (this->data_origins_serializer_map_)
      this->data_origins_serializer_map_->reset ();

    if (this->data_analysis_serializer_)
      this->data_analysis_serializer_->_reset ();

    if (this->data_analysis_serializer_map_)
      this->data_analysis_serializer_map_->reset ();

    if (this->rights_serializer_)
      this->rights_serializer_->_reset ();

    if (this->rights_serializer_map_)
      this->rights_serializer_map_->reset ();

    if (this->cell_origin_serializer_)
      this->cell_origin_serializer_->_reset ();

    if (this->cell_origin_serializer_map_)
      this->cell_origin_serializer_map_->reset ();

    if (this->current_time_serializer_)
      this->current_time_serializer_->_reset ();

    if (this->current_time_serializer_map_)
      this->current_time_serializer_map_->reset ();

    if (this->current_runtime_serializer_)
      this->current_runtime_serializer_->_reset ();

    if (this->current_runtime_serializer_map_)
      this->current_runtime_serializer_map_->reset ();

    if (this->created_serializer_)
      this->created_serializer_->_reset ();

    if (this->created_serializer_map_)
      this->created_serializer_map_->reset ();

    if (this->last_modified_serializer_)
      this->last_modified_serializer_->_reset ();

    if (this->last_modified_serializer_map_)
      this->last_modified_serializer_map_->reset ();

    if (this->notes_serializer_)
      this->notes_serializer_->_reset ();

    if (this->notes_serializer_map_)
      this->notes_serializer_map_->reset ();

    if (this->custom_serializer_)
      this->custom_serializer_->_reset ();

    if (this->custom_serializer_map_)
      this->custom_serializer_map_->reset ();

    this->resetting_ = false;
  }

  const char* metadata_sskel::
  _static_type ()
  {
    return "metadata metadata";
  }

  const char* metadata_sskel::
  _dynamic_type () const
  {
    return _static_type ();
  }
}

namespace metadata
{
  // Element validation and serialization for orcid_identifier_sskel.
  //
  void orcid_identifier_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // path
    //
    if (this->path_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->path ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->path_serializer_ != 0)
        s = this->path_serializer_;
      else if (this->path_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->path_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("path");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // given_names
    //
    if (this->given_names_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->given_names ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->given_names_serializer_ != 0)
        s = this->given_names_serializer_;
      else if (this->given_names_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->given_names_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("given-names");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // family_name
    //
    if (this->family_name_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->family_name ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->family_name_serializer_ != 0)
        s = this->family_name_serializer_;
      else if (this->family_name_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->family_name_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("family-name");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // email
    //
    if (this->email_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->email ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->email_serializer_ != 0)
        s = this->email_serializer_;
      else if (this->email_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->email_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("email");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // url
    //
    if (this->url_present ())
    {
      ctx.type_id (0);
      const ::metadata::URL& r = this->url ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::URL_sskel* s = 0;

      if (t == 0 && this->url_serializer_ != 0)
        s = this->url_serializer_;
      else if (this->url_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->url_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::URL_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::URL_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("url");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // organization_name
    //
    if (this->organization_name_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->organization_name ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->organization_name_serializer_ != 0)
        s = this->organization_name_serializer_;
      else if (this->organization_name_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->organization_name_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("organization-name");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // department_name
    //
    if (this->department_name_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->department_name ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->department_name_serializer_ != 0)
        s = this->department_name_serializer_;
      else if (this->department_name_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->department_name_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("department-name");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for orcid_person_sskel.
  //
  void orcid_person_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // orcid_identifier
    //
    {
      size_t i = 0;
      for (; this->orcid_identifier_next (); ++i)
      {
        ctx.type_id (0);
        const ::metadata::orcid_identifier& r = this->orcid_identifier ();

        const void* t = ctx.type_id ();
        const char* dt = 0;
        ::metadata::orcid_identifier_sskel* s = 0;

        if (t == 0 && this->orcid_identifier_serializer_ != 0)
          s = this->orcid_identifier_serializer_;
        else if (this->orcid_identifier_serializer_map_ != 0)
        {
          ::xml_schema::serializer_base* b = this->orcid_identifier_serializer_map_->find (t);

          if (b != 0)
          {
            dt = b->_dynamic_type ();
            const char* st = ::metadata::orcid_identifier_sskel::_static_type ();

            if (strcmp (dt, st) == 0)
              dt = 0;

            if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
            {
              ctx.schema_error (::xsde::cxx::schema_error::not_derived);
              return;
            }

            s = static_cast< ::metadata::orcid_identifier_sskel* > (b);
          }
        }

        if (s)
        {
          s->pre (r);
          this->_start_element ("orcid-identifier");
          if (dt != 0)
            this->_set_type (dt);

          s->_pre_impl (ctx);

          if (ctx.error_type ())
            return;

          s->_serialize_attributes ();

          if (ctx.error_type ())
            return;

          s->_serialize_content ();

          if (ctx.error_type ())
            return;

          s->_post_impl ();

          if (ctx.error_type ())
            return;

          this->_end_element ();
          s->post ();
        }
        else
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return;
        }
      }

      if (i < 1UL)
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }
  }

  // Element validation and serialization for classification_sskel.
  //
  void classification_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // classification_number
    //
    {
      ctx.type_id (0);
      const ::std::string& r = this->classification_number ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->classification_number_serializer_ != 0)
        s = this->classification_number_serializer_;
      else if (this->classification_number_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->classification_number_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("classification_number");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    // line
    //
    {
      ctx.type_id (0);
      unsigned int r = this->line ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::unsigned_int_sskel* s = 0;

      if (t == 0 && this->line_serializer_ != 0)
        s = this->line_serializer_;
      else if (this->line_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->line_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::unsigned_int_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::unsigned_int_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("line");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    // variant
    //
    {
      ctx.type_id (0);
      unsigned int r = this->variant ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::unsigned_int_sskel* s = 0;

      if (t == 0 && this->variant_serializer_ != 0)
        s = this->variant_serializer_;
      else if (this->variant_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->variant_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::unsigned_int_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::unsigned_int_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("variant");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    // branch
    //
    {
      ctx.type_id (0);
      unsigned int r = this->branch ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::unsigned_int_sskel* s = 0;

      if (t == 0 && this->branch_serializer_ != 0)
        s = this->branch_serializer_;
      else if (this->branch_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->branch_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::unsigned_int_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::unsigned_int_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("branch");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    // version
    //
    {
      ctx.type_id (0);
      unsigned int r = this->version ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::unsigned_int_sskel* s = 0;

      if (t == 0 && this->version_serializer_ != 0)
        s = this->version_serializer_;
      else if (this->version_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->version_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::unsigned_int_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::unsigned_int_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("version");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }
  }

  // Element validation and serialization for curation_sskel.
  //
  void curation_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // created
    //
    {
      ctx.type_id (0);
      const ::xml_schema::date_time& r = this->created ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::date_time_sskel* s = 0;

      if (t == 0 && this->created_serializer_ != 0)
        s = this->created_serializer_;
      else if (this->created_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->created_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::date_time_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::date_time_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("created");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    // last_modified
    //
    {
      ctx.type_id (0);
      const ::xml_schema::date_time& r = this->last_modified ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::date_time_sskel* s = 0;

      if (t == 0 && this->last_modified_serializer_ != 0)
        s = this->last_modified_serializer_;
      else if (this->last_modified_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->last_modified_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::date_time_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::date_time_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("last_modified");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    switch (this->choice_arm ())
    {
      case classification_tag:
      {
        // classification
        //
        {
          ctx.type_id (0);
          const ::metadata::classification& r = this->classification ();

          const void* t = ctx.type_id ();
          const char* dt = 0;
          ::metadata::classification_sskel* s = 0;

          if (t == 0 && this->classification_serializer_ != 0)
            s = this->classification_serializer_;
          else if (this->classification_serializer_map_ != 0)
          {
            ::xml_schema::serializer_base* b = this->classification_serializer_map_->find (t);

            if (b != 0)
            {
              dt = b->_dynamic_type ();
              const char* st = ::metadata::classification_sskel::_static_type ();

              if (strcmp (dt, st) == 0)
                dt = 0;

              if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
              {
                ctx.schema_error (::xsde::cxx::schema_error::not_derived);
                return;
              }

              s = static_cast< ::metadata::classification_sskel* > (b);
            }
          }

          if (s)
          {
            s->pre (r);
            this->_start_element ("classification");
            if (dt != 0)
              this->_set_type (dt);

            s->_pre_impl (ctx);

            if (ctx.error_type ())
              return;

            s->_serialize_attributes ();

            if (ctx.error_type ())
              return;

            s->_serialize_content ();

            if (ctx.error_type ())
              return;

            s->_post_impl ();

            if (ctx.error_type ())
              return;

            this->_end_element ();
            s->post ();
          }
          else
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return;
          }
        }

        break;
      }
      case version_tag:
      {
        // version
        //
        {
          ctx.type_id (0);
          const ::std::string& r = this->version ();

          const void* t = ctx.type_id ();
          const char* dt = 0;
          ::xml_schema::string_sskel* s = 0;

          if (t == 0 && this->version_serializer_ != 0)
            s = this->version_serializer_;
          else if (this->version_serializer_map_ != 0)
          {
            ::xml_schema::serializer_base* b = this->version_serializer_map_->find (t);

            if (b != 0)
            {
              dt = b->_dynamic_type ();
              const char* st = ::xml_schema::string_sskel::_static_type ();

              if (strcmp (dt, st) == 0)
                dt = 0;

              if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
              {
                ctx.schema_error (::xsde::cxx::schema_error::not_derived);
                return;
              }

              s = static_cast< ::xml_schema::string_sskel* > (b);
            }
          }

          if (s)
          {
            s->pre (r);
            this->_start_element ("version");
            if (dt != 0)
              this->_set_type (dt);

            s->_pre_impl (ctx);

            if (ctx.error_type ())
              return;

            s->_serialize_attributes ();

            if (ctx.error_type ())
              return;

            s->_serialize_content ();

            if (ctx.error_type ())
              return;

            s->_post_impl ();

            if (ctx.error_type ())
              return;

            this->_end_element ();
            s->post ();
          }
          else
          {
            this->_schema_error (::xsde::cxx::schema_error::expected_element);
            return;
          }
        }

        break;
      }
      default:
      {
        this->_schema_error (::xsde::cxx::schema_error::unexpected_element);
        return;
      }
    }

    // creator
    //
    {
      ctx.type_id (0);
      const ::metadata::orcid_person& r = this->creator ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::orcid_person_sskel* s = 0;

      if (t == 0 && this->creator_serializer_ != 0)
        s = this->creator_serializer_;
      else if (this->creator_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->creator_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::orcid_person_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::orcid_person_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("creator");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    // current_contact
    //
    {
      ctx.type_id (0);
      const ::metadata::orcid_person& r = this->current_contact ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::orcid_person_sskel* s = 0;

      if (t == 0 && this->current_contact_serializer_ != 0)
        s = this->current_contact_serializer_;
      else if (this->current_contact_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->current_contact_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::orcid_person_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::orcid_person_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("current_contact");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    // curator
    //
    if (this->curator_present ())
    {
      ctx.type_id (0);
      const ::metadata::orcid_person& r = this->curator ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::orcid_person_sskel* s = 0;

      if (t == 0 && this->curator_serializer_ != 0)
        s = this->curator_serializer_;
      else if (this->curator_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->curator_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::orcid_person_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::orcid_person_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("curator");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // last_modified_by
    //
    {
      ctx.type_id (0);
      const ::metadata::orcid_person& r = this->last_modified_by ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::orcid_person_sskel* s = 0;

      if (t == 0 && this->last_modified_by_serializer_ != 0)
        s = this->last_modified_by_serializer_;
      else if (this->last_modified_by_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->last_modified_by_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::orcid_person_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::orcid_person_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("last_modified_by");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    while (this->any_next ())
    {
      ::std::string ns, name;
      this->any (ns, name);

      if (!name.empty ())
      {
        if (ns.empty ())
        {
          this->_start_element (name.c_str ());
        }
        else
        {
          this->_start_element (ns.c_str (), name.c_str ());
        }

        this->serialize_any ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::unexpected_element);
        return;
      }
    }
  }

  // Element validation and serialization for citation_sskel.
  //
  void citation_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // text
    //
    if (this->text_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->text ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->text_serializer_ != 0)
        s = this->text_serializer_;
      else if (this->text_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->text_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("text");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // DOI
    //
    if (this->DOI_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->DOI ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->DOI_serializer_ != 0)
        s = this->DOI_serializer_;
      else if (this->DOI_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->DOI_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("DOI");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // URL
    //
    while (this->URL_next ())
    {
      ctx.type_id (0);
      const ::metadata::URL& r = this->URL ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::URL_sskel* s = 0;

      if (t == 0 && this->URL_serializer_ != 0)
        s = this->URL_serializer_;
      else if (this->URL_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->URL_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::URL_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::URL_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("URL");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // PMID
    //
    if (this->PMID_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->PMID ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->PMID_serializer_ != 0)
        s = this->PMID_serializer_;
      else if (this->PMID_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->PMID_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("PMID");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // PMCID
    //
    if (this->PMCID_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->PMCID ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->PMCID_serializer_ != 0)
        s = this->PMCID_serializer_;
      else if (this->PMCID_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->PMCID_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("PMCID");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // arXiv
    //
    if (this->arXiv_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->arXiv ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->arXiv_serializer_ != 0)
        s = this->arXiv_serializer_;
      else if (this->arXiv_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->arXiv_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("arXiv");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // notes
    //
    if (this->notes_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->notes ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->notes_serializer_ != 0)
        s = this->notes_serializer_;
      else if (this->notes_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->notes_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("notes");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for data_origin_sskel.
  //
  void data_origin_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // instrumentation_information
    //
    if (this->instrumentation_information_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->instrumentation_information ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->instrumentation_information_serializer_ != 0)
        s = this->instrumentation_information_serializer_;
      else if (this->instrumentation_information_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->instrumentation_information_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("instrumentation_information");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // experimental_protocol
    //
    if (this->experimental_protocol_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->experimental_protocol ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->experimental_protocol_serializer_ != 0)
        s = this->experimental_protocol_serializer_;
      else if (this->experimental_protocol_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->experimental_protocol_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("experimental_protocol");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // citation
    //
    while (this->citation_next ())
    {
      ctx.type_id (0);
      const ::metadata::citation& r = this->citation ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::citation_sskel* s = 0;

      if (t == 0 && this->citation_serializer_ != 0)
        s = this->citation_serializer_;
      else if (this->citation_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->citation_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::citation_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::citation_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("citation");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // xpath
    //
    if (this->xpath_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->xpath ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->xpath_serializer_ != 0)
        s = this->xpath_serializer_;
      else if (this->xpath_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->xpath_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("xpath");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // notes
    //
    if (this->notes_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->notes ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->notes_serializer_ != 0)
        s = this->notes_serializer_;
      else if (this->notes_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->notes_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("notes");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for data_origins_sskel.
  //
  void data_origins_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // data_origin
    //
    {
      size_t i = 0;
      for (; this->data_origin_next (); ++i)
      {
        ctx.type_id (0);
        const ::metadata::data_origin& r = this->data_origin ();

        const void* t = ctx.type_id ();
        const char* dt = 0;
        ::metadata::data_origin_sskel* s = 0;

        if (t == 0 && this->data_origin_serializer_ != 0)
          s = this->data_origin_serializer_;
        else if (this->data_origin_serializer_map_ != 0)
        {
          ::xml_schema::serializer_base* b = this->data_origin_serializer_map_->find (t);

          if (b != 0)
          {
            dt = b->_dynamic_type ();
            const char* st = ::metadata::data_origin_sskel::_static_type ();

            if (strcmp (dt, st) == 0)
              dt = 0;

            if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
            {
              ctx.schema_error (::xsde::cxx::schema_error::not_derived);
              return;
            }

            s = static_cast< ::metadata::data_origin_sskel* > (b);
          }
        }

        if (s)
        {
          s->pre (r);
          this->_start_element ("data_origin");
          if (dt != 0)
            this->_set_type (dt);

          s->_pre_impl (ctx);

          if (ctx.error_type ())
            return;

          s->_serialize_attributes ();

          if (ctx.error_type ())
            return;

          s->_serialize_content ();

          if (ctx.error_type ())
            return;

          s->_post_impl ();

          if (ctx.error_type ())
            return;

          this->_end_element ();
          s->post ();
        }
        else
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return;
        }
      }

      if (i < 1UL)
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for data_analysis_sskel.
  //
  void data_analysis_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // URL
    //
    if (this->URL_present ())
    {
      ctx.type_id (0);
      const ::metadata::URL& r = this->URL ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::URL_sskel* s = 0;

      if (t == 0 && this->URL_serializer_ != 0)
        s = this->URL_serializer_;
      else if (this->URL_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->URL_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::URL_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::URL_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("URL");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // citation
    //
    if (this->citation_present ())
    {
      ctx.type_id (0);
      const ::metadata::citation& r = this->citation ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::citation_sskel* s = 0;

      if (t == 0 && this->citation_serializer_ != 0)
        s = this->citation_serializer_;
      else if (this->citation_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->citation_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::citation_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::citation_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("citation");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // software
    //
    if (this->software_present ())
    {
      ctx.type_id (0);
      const ::metadata::software& r = this->software ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::software_sskel* s = 0;

      if (t == 0 && this->software_serializer_ != 0)
        s = this->software_serializer_;
      else if (this->software_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->software_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::software_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::software_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("software");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // xpath
    //
    if (this->xpath_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->xpath ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->xpath_serializer_ != 0)
        s = this->xpath_serializer_;
      else if (this->xpath_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->xpath_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("xpath");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // notes
    //
    if (this->notes_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->notes ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->notes_serializer_ != 0)
        s = this->notes_serializer_;
      else if (this->notes_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->notes_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("notes");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for software_sskel.
  //
  void software_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // software_name
    //
    if (this->software_name_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->software_name ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->software_name_serializer_ != 0)
        s = this->software_name_serializer_;
      else if (this->software_name_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->software_name_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("software_name");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // software_version
    //
    if (this->software_version_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->software_version ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->software_version_serializer_ != 0)
        s = this->software_version_serializer_;
      else if (this->software_version_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->software_version_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("software_version");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // software_input_configuration
    //
    if (this->software_input_configuration_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->software_input_configuration ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->software_input_configuration_serializer_ != 0)
        s = this->software_input_configuration_serializer_;
      else if (this->software_input_configuration_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->software_input_configuration_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("software_input_configuration");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // name
    //
    if (this->name_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->name ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->name_serializer_ != 0)
        s = this->name_serializer_;
      else if (this->name_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->name_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("name");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // version
    //
    if (this->version_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->version ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->version_serializer_ != 0)
        s = this->version_serializer_;
      else if (this->version_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->version_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("version");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // input_configuration
    //
    if (this->input_configuration_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->input_configuration ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->input_configuration_serializer_ != 0)
        s = this->input_configuration_serializer_;
      else if (this->input_configuration_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->input_configuration_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("input_configuration");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // URL
    //
    if (this->URL_present ())
    {
      ctx.type_id (0);
      const ::metadata::URL& r = this->URL ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::URL_sskel* s = 0;

      if (t == 0 && this->URL_serializer_ != 0)
        s = this->URL_serializer_;
      else if (this->URL_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->URL_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::URL_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::URL_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("URL");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // creator
    //
    if (this->creator_present ())
    {
      ctx.type_id (0);
      const ::metadata::orcid_person& r = this->creator ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::orcid_person_sskel* s = 0;

      if (t == 0 && this->creator_serializer_ != 0)
        s = this->creator_serializer_;
      else if (this->creator_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->creator_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::orcid_person_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::orcid_person_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("creator");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // citation
    //
    if (this->citation_present ())
    {
      ctx.type_id (0);
      const ::metadata::citation& r = this->citation ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::citation_sskel* s = 0;

      if (t == 0 && this->citation_serializer_ != 0)
        s = this->citation_serializer_;
      else if (this->citation_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->citation_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::citation_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::citation_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("citation");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // user
    //
    if (this->user_present ())
    {
      ctx.type_id (0);
      const ::metadata::orcid_person& r = this->user ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::orcid_person_sskel* s = 0;

      if (t == 0 && this->user_serializer_ != 0)
        s = this->user_serializer_;
      else if (this->user_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->user_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::orcid_person_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::orcid_person_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("user");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for cell_origin_sskel.
  //
  void cell_origin_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // BTO_ID
    //
    if (this->BTO_ID_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->BTO_ID ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->BTO_ID_serializer_ != 0)
        s = this->BTO_ID_serializer_;
      else if (this->BTO_ID_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->BTO_ID_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("BTO_ID");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // CLO_ID
    //
    if (this->CLO_ID_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->CLO_ID ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->CLO_ID_serializer_ != 0)
        s = this->CLO_ID_serializer_;
      else if (this->CLO_ID_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->CLO_ID_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("CLO_ID");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // species
    //
    if (this->species_present ())
    {
      ctx.type_id (0);
      const ::metadata::species& r = this->species ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::species_sskel* s = 0;

      if (t == 0 && this->species_serializer_ != 0)
        s = this->species_serializer_;
      else if (this->species_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->species_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::species_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::species_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("species");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // strain
    //
    if (this->strain_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->strain ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->strain_serializer_ != 0)
        s = this->strain_serializer_;
      else if (this->strain_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->strain_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("strain");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // organ
    //
    if (this->organ_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->organ ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->organ_serializer_ != 0)
        s = this->organ_serializer_;
      else if (this->organ_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->organ_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("organ");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // disease
    //
    if (this->disease_present ())
    {
      ctx.type_id (0);
      const ::metadata::disease& r = this->disease ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::disease_sskel* s = 0;

      if (t == 0 && this->disease_serializer_ != 0)
        s = this->disease_serializer_;
      else if (this->disease_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->disease_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::disease_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::disease_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("disease");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // morphology
    //
    if (this->morphology_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->morphology ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->morphology_serializer_ != 0)
        s = this->morphology_serializer_;
      else if (this->morphology_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->morphology_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("morphology");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // patient_derived
    //
    if (this->patient_derived_present ())
    {
      ctx.type_id (0);
      const ::metadata::patient_derived& r = this->patient_derived ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::patient_derived_sskel* s = 0;

      if (t == 0 && this->patient_derived_serializer_ != 0)
        s = this->patient_derived_serializer_;
      else if (this->patient_derived_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->patient_derived_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::patient_derived_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::patient_derived_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("patient_derived");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for MultiCellDB_sskel.
  //
  void MultiCellDB_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // ID
    //
    if (this->ID_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->ID ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->ID_serializer_ != 0)
        s = this->ID_serializer_;
      else if (this->ID_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->ID_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("ID");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // name
    //
    if (this->name_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->name ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->name_serializer_ != 0)
        s = this->name_serializer_;
      else if (this->name_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->name_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("name");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for rights_sskel.
  //
  void rights_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // license
    //
    {
      size_t i = 0;
      for (; this->license_next (); ++i)
      {
        ctx.type_id (0);
        const ::metadata::license& r = this->license ();

        const void* t = ctx.type_id ();
        const char* dt = 0;
        ::metadata::license_sskel* s = 0;

        if (t == 0 && this->license_serializer_ != 0)
          s = this->license_serializer_;
        else if (this->license_serializer_map_ != 0)
        {
          ::xml_schema::serializer_base* b = this->license_serializer_map_->find (t);

          if (b != 0)
          {
            dt = b->_dynamic_type ();
            const char* st = ::metadata::license_sskel::_static_type ();

            if (strcmp (dt, st) == 0)
              dt = 0;

            if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
            {
              ctx.schema_error (::xsde::cxx::schema_error::not_derived);
              return;
            }

            s = static_cast< ::metadata::license_sskel* > (b);
          }
        }

        if (s)
        {
          s->pre (r);
          this->_start_element ("license");
          if (dt != 0)
            this->_set_type (dt);

          s->_pre_impl (ctx);

          if (ctx.error_type ())
            return;

          s->_serialize_attributes ();

          if (ctx.error_type ())
            return;

          s->_serialize_content ();

          if (ctx.error_type ())
            return;

          s->_post_impl ();

          if (ctx.error_type ())
            return;

          this->_end_element ();
          s->post ();
        }
        else
        {
          this->_schema_error (::xsde::cxx::schema_error::expected_element);
          return;
        }
      }

      if (i < 1UL)
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for license_sskel.
  //
  void license_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // LicenseDocument
    //
    {
      ctx.type_id (0);
      const ::metadata::LicenseDocument& r = this->LicenseDocument ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::LicenseDocument_sskel* s = 0;

      if (t == 0 && this->LicenseDocument_serializer_ != 0)
        s = this->LicenseDocument_serializer_;
      else if (this->LicenseDocument_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->LicenseDocument_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::LicenseDocument_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::LicenseDocument_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("LicenseDocument");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    // notes
    //
    if (this->notes_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->notes ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->notes_serializer_ != 0)
        s = this->notes_serializer_;
      else if (this->notes_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->notes_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("notes");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for LicenseDocument_sskel.
  //
  void LicenseDocument_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // name
    //
    {
      ctx.type_id (0);
      const ::std::string& r = this->name ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->name_serializer_ != 0)
        s = this->name_serializer_;
      else if (this->name_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->name_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("name");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    // URL
    //
    if (this->URL_present ())
    {
      ctx.type_id (0);
      const ::metadata::URL& r = this->URL ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::URL_sskel* s = 0;

      if (t == 0 && this->URL_serializer_ != 0)
        s = this->URL_serializer_;
      else if (this->URL_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->URL_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::URL_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::URL_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("URL");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }

  // Element validation and serialization for metadata_sskel.
  //
  void metadata_sskel::
  _serialize_content ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // MultiCellDB
    //
    if (this->MultiCellDB_present ())
    {
      ctx.type_id (0);
      const ::metadata::MultiCellDB& r = this->MultiCellDB ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::MultiCellDB_sskel* s = 0;

      if (t == 0 && this->MultiCellDB_serializer_ != 0)
        s = this->MultiCellDB_serializer_;
      else if (this->MultiCellDB_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->MultiCellDB_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::MultiCellDB_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::MultiCellDB_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("MultiCellDB");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // description
    //
    if (this->description_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->description ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->description_serializer_ != 0)
        s = this->description_serializer_;
      else if (this->description_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->description_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("description");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // software
    //
    if (this->software_present ())
    {
      ctx.type_id (0);
      const ::metadata::software& r = this->software ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::software_sskel* s = 0;

      if (t == 0 && this->software_serializer_ != 0)
        s = this->software_serializer_;
      else if (this->software_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->software_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::software_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::software_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("software");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // citation
    //
    if (this->citation_present ())
    {
      ctx.type_id (0);
      const ::metadata::citation& r = this->citation ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::citation_sskel* s = 0;

      if (t == 0 && this->citation_serializer_ != 0)
        s = this->citation_serializer_;
      else if (this->citation_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->citation_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::citation_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::citation_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("citation");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // curation
    //
    if (this->curation_present ())
    {
      ctx.type_id (0);
      const ::metadata::curation& r = this->curation ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::curation_sskel* s = 0;

      if (t == 0 && this->curation_serializer_ != 0)
        s = this->curation_serializer_;
      else if (this->curation_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->curation_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::curation_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::curation_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("curation");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // data_origins
    //
    if (this->data_origins_present ())
    {
      ctx.type_id (0);
      const ::metadata::data_origins& r = this->data_origins ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::data_origins_sskel* s = 0;

      if (t == 0 && this->data_origins_serializer_ != 0)
        s = this->data_origins_serializer_;
      else if (this->data_origins_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->data_origins_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::data_origins_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::data_origins_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("data_origins");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // data_analysis
    //
    while (this->data_analysis_next ())
    {
      ctx.type_id (0);
      const ::metadata::data_analysis& r = this->data_analysis ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::data_analysis_sskel* s = 0;

      if (t == 0 && this->data_analysis_serializer_ != 0)
        s = this->data_analysis_serializer_;
      else if (this->data_analysis_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->data_analysis_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::data_analysis_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::data_analysis_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("data_analysis");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // rights
    //
    {
      ctx.type_id (0);
      const ::metadata::rights& r = this->rights ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::rights_sskel* s = 0;

      if (t == 0 && this->rights_serializer_ != 0)
        s = this->rights_serializer_;
      else if (this->rights_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->rights_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::rights_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::rights_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("rights");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::expected_element);
        return;
      }
    }

    // cell_origin
    //
    if (this->cell_origin_present ())
    {
      ctx.type_id (0);
      const ::metadata::cell_origin& r = this->cell_origin ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::metadata::cell_origin_sskel* s = 0;

      if (t == 0 && this->cell_origin_serializer_ != 0)
        s = this->cell_origin_serializer_;
      else if (this->cell_origin_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->cell_origin_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::metadata::cell_origin_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::metadata::cell_origin_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("cell_origin");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // current_time
    //
    if (this->current_time_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->current_time ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->current_time_serializer_ != 0)
        s = this->current_time_serializer_;
      else if (this->current_time_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->current_time_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("current_time");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // current_runtime
    //
    if (this->current_runtime_present ())
    {
      ctx.type_id (0);
      const ::common::units_decimal_nonnegative& r = this->current_runtime ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::units_decimal_nonnegative_sskel* s = 0;

      if (t == 0 && this->current_runtime_serializer_ != 0)
        s = this->current_runtime_serializer_;
      else if (this->current_runtime_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->current_runtime_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::units_decimal_nonnegative_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::units_decimal_nonnegative_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("current_runtime");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // created
    //
    if (this->created_present ())
    {
      ctx.type_id (0);
      const ::xml_schema::date_time& r = this->created ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::date_time_sskel* s = 0;

      if (t == 0 && this->created_serializer_ != 0)
        s = this->created_serializer_;
      else if (this->created_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->created_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::date_time_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::date_time_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("created");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // last_modified
    //
    if (this->last_modified_present ())
    {
      ctx.type_id (0);
      const ::xml_schema::date_time& r = this->last_modified ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::date_time_sskel* s = 0;

      if (t == 0 && this->last_modified_serializer_ != 0)
        s = this->last_modified_serializer_;
      else if (this->last_modified_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->last_modified_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::date_time_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::date_time_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("last_modified");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // notes
    //
    if (this->notes_present ())
    {
      ctx.type_id (0);
      const ::std::string& r = this->notes ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::xml_schema::string_sskel* s = 0;

      if (t == 0 && this->notes_serializer_ != 0)
        s = this->notes_serializer_;
      else if (this->notes_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->notes_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::xml_schema::string_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::xml_schema::string_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("notes");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }

    // custom
    //
    if (this->custom_present ())
    {
      ctx.type_id (0);
      const ::common::custom& r = this->custom ();

      const void* t = ctx.type_id ();
      const char* dt = 0;
      ::common::custom_sskel* s = 0;

      if (t == 0 && this->custom_serializer_ != 0)
        s = this->custom_serializer_;
      else if (this->custom_serializer_map_ != 0)
      {
        ::xml_schema::serializer_base* b = this->custom_serializer_map_->find (t);

        if (b != 0)
        {
          dt = b->_dynamic_type ();
          const char* st = ::common::custom_sskel::_static_type ();

          if (strcmp (dt, st) == 0)
            dt = 0;

          if (dt != 0 && !::xsde::cxx::serializer::validating::inheritance_map_instance ().check (dt, st))
          {
            ctx.schema_error (::xsde::cxx::schema_error::not_derived);
            return;
          }

          s = static_cast< ::common::custom_sskel* > (b);
        }
      }

      if (s)
      {
        s->pre (r);
        this->_start_element ("custom");
        if (dt != 0)
          this->_set_type (dt);

        s->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        s->_serialize_attributes ();

        if (ctx.error_type ())
          return;

        s->_serialize_content ();

        if (ctx.error_type ())
          return;

        s->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_element ();
        s->post ();
      }
    }
  }
}

namespace metadata
{
  // Attribute validation and serialization for curation_sskel.
  //
  void curation_sskel::
  _serialize_attributes ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // curated
    //
    if (this->curated_present ())
    {
      bool r = this->curated ();

      if (this->curated_serializer_)
      {
        this->curated_serializer_->pre (r);
        this->_start_attribute ("curated");
        this->curated_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->curated_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->curated_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->curated_serializer_->post ();
      }
    }

    while (this->any_attribute_next ())
    {
      ::std::string ns, name;
      this->any_attribute (ns, name);

      if (!name.empty ())
      {
        if (ns.empty ())
        {
          this->_start_attribute (name.c_str ());
        }
        else
        {
          this->_start_attribute (ns.c_str (), name.c_str ());
        }

        this->serialize_any_attribute ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
      }
      else
      {
        this->_schema_error (::xsde::cxx::schema_error::unexpected_attribute);
        return;
      }
    }
  }

  // Attribute validation and serialization for data_origin_sskel.
  //
  void data_origin_sskel::
  _serialize_attributes ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    // ID
    //
    if (this->ID_present ())
    {
      unsigned long long r = this->ID ();

      if (this->ID_serializer_)
      {
        this->ID_serializer_->pre (r);
        this->_start_attribute ("ID");
        this->ID_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->ID_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->ID_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->ID_serializer_->post ();
      }
    }
  }

  // Attribute validation and serialization for species_sskel.
  //
  void species_sskel::
  _serialize_attributes ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    typedef ::xml_schema::string_sskel base;
    base::_serialize_attributes ();

    if (ctx.error_type ())
      return;

    // MeSH_ID
    //
    if (this->MeSH_ID_present ())
    {
      const ::std::string& r = this->MeSH_ID ();

      if (this->MeSH_ID_serializer_)
      {
        this->MeSH_ID_serializer_->pre (r);
        this->_start_attribute ("MeSH_ID");
        this->MeSH_ID_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->MeSH_ID_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->MeSH_ID_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->MeSH_ID_serializer_->post ();
      }
    }
  }

  // Attribute validation and serialization for disease_sskel.
  //
  void disease_sskel::
  _serialize_attributes ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    typedef ::xml_schema::string_sskel base;
    base::_serialize_attributes ();

    if (ctx.error_type ())
      return;

    // EFO_ID
    //
    if (this->EFO_ID_present ())
    {
      const ::std::string& r = this->EFO_ID ();

      if (this->EFO_ID_serializer_)
      {
        this->EFO_ID_serializer_->pre (r);
        this->_start_attribute ("EFO_ID");
        this->EFO_ID_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->EFO_ID_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->EFO_ID_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->EFO_ID_serializer_->post ();
      }
    }

    // DOID_ID
    //
    if (this->DOID_ID_present ())
    {
      const ::std::string& r = this->DOID_ID ();

      if (this->DOID_ID_serializer_)
      {
        this->DOID_ID_serializer_->pre (r);
        this->_start_attribute ("DOID_ID");
        this->DOID_ID_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->DOID_ID_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->DOID_ID_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->DOID_ID_serializer_->post ();
      }
    }
  }

  // Attribute validation and serialization for patient_derived_sskel.
  //
  void patient_derived_sskel::
  _serialize_attributes ()
  {
    ::xsde::cxx::serializer::context& ctx = this->_context ();

    typedef ::xml_schema::boolean_sskel base;
    base::_serialize_attributes ();

    if (ctx.error_type ())
      return;

    // patient_ID
    //
    if (this->patient_ID_present ())
    {
      const ::std::string& r = this->patient_ID ();

      if (this->patient_ID_serializer_)
      {
        this->patient_ID_serializer_->pre (r);
        this->_start_attribute ("patient_ID");
        this->patient_ID_serializer_->_pre_impl (ctx);

        if (ctx.error_type ())
          return;

        this->patient_ID_serializer_->_serialize_content ();

        if (ctx.error_type ())
          return;

        this->patient_ID_serializer_->_post_impl ();

        if (ctx.error_type ())
          return;

        this->_end_attribute ();
        this->patient_ID_serializer_->post ();
      }
    }
  }
}

// Begin epilogue.
//
//
// End epilogue.

