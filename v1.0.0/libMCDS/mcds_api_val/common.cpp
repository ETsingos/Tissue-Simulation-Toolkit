// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "common.hpp"

#include <stdlib.h>
#include <new>

#include <xsde/cxx/guard.hxx>

namespace common
{
  // custom
  //

  custom::
  custom ()
  {
  }

  custom::
  ~custom ()
  {
  }

  void custom::
  _copy (custom& c) const
  {
    XSDE_UNUSED (c);

    this->custom_data_.copy (c.custom_data_);
  }

  custom* custom::
  _clone () const
  {
    custom* c = new custom;
    ::xsde::cxx::guard< custom > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // double_list
  //

  void double_list::
  _copy (double_list& c) const
  {
    const ::xsde::cxx::hybrid::pod_sequence< double >& b = *this;
    b.copy (c);
  }

  double_list* double_list::
  _clone () const
  {
    double_list* c = new double_list;
    ::xsde::cxx::guard< double_list > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // unsigned_int_list
  //

  void unsigned_int_list::
  _copy (unsigned_int_list& c) const
  {
    const ::xsde::cxx::hybrid::pod_sequence< unsigned int >& b = *this;
    b.copy (c);
  }

  unsigned_int_list* unsigned_int_list::
  _clone () const
  {
    unsigned_int_list* c = new unsigned_int_list;
    ::xsde::cxx::guard< unsigned_int_list > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // two_doubles
  //

  two_doubles::
  two_doubles ()
  {
  }

  void two_doubles::
  _copy (two_doubles& c) const
  {
    XSDE_UNUSED (c);

    const ::common::double_list& b = *this;
    b._copy (c);
  }

  two_doubles* two_doubles::
  _clone () const
  {
    two_doubles* c = new two_doubles;
    ::xsde::cxx::guard< two_doubles > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // units_double_list
  //

  units_double_list::
  units_double_list ()
  {
    this->units_present_ = false;
    this->measurement_type_present_ = false;
    this->uncertainty_present_ = false;
    this->negative_uncertainty_present_ = false;
    this->positive_uncertainty_present_ = false;
    this->uncertainty_percentage_present_ = false;
    this->negative_uncertainty_percentage_present_ = false;
    this->positive_uncertainty_percentage_present_ = false;
    this->median_present_ = false;
    this->standard_deviation_present_ = false;
    this->interquartile_range_ = 0;
    this->range_ = 0;
    this->min_present_ = false;
    this->max_present_ = false;
    this->standard_error_present_ = false;
    this->standard_error_of_the_mean_present_ = false;
    this->number_obs_present_ = false;
    this->skewnesss_present_ = false;
    this->kurtosis_present_ = false;
  }

  units_double_list::
  ~units_double_list ()
  {
    delete this->interquartile_range_;
    delete this->range_;
  }

  void units_double_list::
  _copy (units_double_list& c) const
  {
    XSDE_UNUSED (c);

    const ::common::double_list& b = *this;
    b._copy (c);
    if (this->units_present ())
      c.units (this->units ());

    if (this->measurement_type_present ())
      c.measurement_type (this->measurement_type ());

    if (this->uncertainty_present ())
      c.uncertainty (this->uncertainty ());

    if (this->negative_uncertainty_present ())
      c.negative_uncertainty (this->negative_uncertainty ());

    if (this->positive_uncertainty_present ())
      c.positive_uncertainty (this->positive_uncertainty ());

    if (this->uncertainty_percentage_present ())
      c.uncertainty_percentage (this->uncertainty_percentage ());

    if (this->negative_uncertainty_percentage_present ())
      c.negative_uncertainty_percentage (this->negative_uncertainty_percentage ());

    if (this->positive_uncertainty_percentage_present ())
      c.positive_uncertainty_percentage (this->positive_uncertainty_percentage ());

    if (this->median_present ())
      c.median (this->median ());

    if (this->standard_deviation_present ())
      c.standard_deviation (this->standard_deviation ());

    if (this->interquartile_range_present ())
    {
      ::common::two_doubles* m = this->interquartile_range ()._clone ();
      c.interquartile_range (m);
    }

    if (this->range_present ())
    {
      ::common::two_doubles* m = this->range ()._clone ();
      c.range (m);
    }

    if (this->min_present ())
      c.min (this->min ());

    if (this->max_present ())
      c.max (this->max ());

    if (this->standard_error_present ())
      c.standard_error (this->standard_error ());

    if (this->standard_error_of_the_mean_present ())
      c.standard_error_of_the_mean (this->standard_error_of_the_mean ());

    if (this->number_obs_present ())
      c.number_obs (this->number_obs ());

    if (this->skewnesss_present ())
      c.skewnesss (this->skewnesss ());

    if (this->kurtosis_present ())
      c.kurtosis (this->kurtosis ());
  }

  units_double_list* units_double_list::
  _clone () const
  {
    units_double_list* c = new units_double_list;
    ::xsde::cxx::guard< units_double_list > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // delimited_list
  //

  delimited_list::
  delimited_list ()
  {
    this->delimiter_present_ = false;
  }

  delimited_list::
  ~delimited_list ()
  {
  }

  delimited_list::
  delimited_list (const delimited_list& x)
  : ::std::string (x)
  {
    XSDE_UNUSED (x);
    this->delimiter_present_ = x.delimiter_present_;
    if (this->delimiter_present_)
      this->delimiter_ = x.delimiter_;
  }

  delimited_list& delimited_list::
  operator= (const delimited_list& x)
  {
    XSDE_UNUSED (x);
    static_cast< ::std::string& > (*this) = x;
    this->delimiter_present_ = x.delimiter_present_;
    if (this->delimiter_present_)
      this->delimiter_ = x.delimiter_;
    return *this;
  }

  // units_delimited_list
  //

  units_delimited_list::
  units_delimited_list ()
  {
    this->units_present_ = false;
    this->measurement_type_present_ = false;
    this->uncertainty_present_ = false;
    this->negative_uncertainty_present_ = false;
    this->positive_uncertainty_present_ = false;
    this->uncertainty_percentage_present_ = false;
    this->negative_uncertainty_percentage_present_ = false;
    this->positive_uncertainty_percentage_present_ = false;
    this->median_present_ = false;
    this->standard_deviation_present_ = false;
    this->interquartile_range_ = 0;
    this->range_ = 0;
    this->min_present_ = false;
    this->max_present_ = false;
    this->standard_error_present_ = false;
    this->standard_error_of_the_mean_present_ = false;
    this->number_obs_present_ = false;
    this->skewnesss_present_ = false;
    this->kurtosis_present_ = false;
  }

  units_delimited_list::
  ~units_delimited_list ()
  {
    delete this->interquartile_range_;
    delete this->range_;
  }

  void units_delimited_list::
  _copy (units_delimited_list& c) const
  {
    XSDE_UNUSED (c);

    static_cast< ::common::delimited_list& > (c) = *this;
    if (this->units_present ())
      c.units (this->units ());

    if (this->measurement_type_present ())
      c.measurement_type (this->measurement_type ());

    if (this->uncertainty_present ())
      c.uncertainty (this->uncertainty ());

    if (this->negative_uncertainty_present ())
      c.negative_uncertainty (this->negative_uncertainty ());

    if (this->positive_uncertainty_present ())
      c.positive_uncertainty (this->positive_uncertainty ());

    if (this->uncertainty_percentage_present ())
      c.uncertainty_percentage (this->uncertainty_percentage ());

    if (this->negative_uncertainty_percentage_present ())
      c.negative_uncertainty_percentage (this->negative_uncertainty_percentage ());

    if (this->positive_uncertainty_percentage_present ())
      c.positive_uncertainty_percentage (this->positive_uncertainty_percentage ());

    if (this->median_present ())
      c.median (this->median ());

    if (this->standard_deviation_present ())
      c.standard_deviation (this->standard_deviation ());

    if (this->interquartile_range_present ())
    {
      ::common::two_doubles* m = this->interquartile_range ()._clone ();
      c.interquartile_range (m);
    }

    if (this->range_present ())
    {
      ::common::two_doubles* m = this->range ()._clone ();
      c.range (m);
    }

    if (this->min_present ())
      c.min (this->min ());

    if (this->max_present ())
      c.max (this->max ());

    if (this->standard_error_present ())
      c.standard_error (this->standard_error ());

    if (this->standard_error_of_the_mean_present ())
      c.standard_error_of_the_mean (this->standard_error_of_the_mean ());

    if (this->number_obs_present ())
      c.number_obs (this->number_obs ());

    if (this->skewnesss_present ())
      c.skewnesss (this->skewnesss ());

    if (this->kurtosis_present ())
      c.kurtosis (this->kurtosis ());
  }

  units_delimited_list* units_delimited_list::
  _clone () const
  {
    units_delimited_list* c = new units_delimited_list;
    ::xsde::cxx::guard< units_delimited_list > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // units_decimal
  //

  units_decimal::
  units_decimal ()
  {
    this->units_present_ = false;
    this->measurement_type_present_ = false;
    this->uncertainty_present_ = false;
    this->negative_uncertainty_present_ = false;
    this->positive_uncertainty_present_ = false;
    this->uncertainty_percentage_present_ = false;
    this->negative_uncertainty_percentage_present_ = false;
    this->positive_uncertainty_percentage_present_ = false;
    this->median_present_ = false;
    this->standard_deviation_present_ = false;
    this->interquartile_range_ = 0;
    this->range_ = 0;
    this->min_present_ = false;
    this->max_present_ = false;
    this->standard_error_present_ = false;
    this->standard_error_of_the_mean_present_ = false;
    this->number_obs_present_ = false;
    this->skewnesss_present_ = false;
    this->kurtosis_present_ = false;
  }

  units_decimal::
  ~units_decimal ()
  {
    delete this->interquartile_range_;
    delete this->range_;
  }

  void units_decimal::
  _copy (units_decimal& c) const
  {
    XSDE_UNUSED (c);

    static_cast< ::xml_schema::double_base& > (c) = *this;
    if (this->units_present ())
      c.units (this->units ());

    if (this->measurement_type_present ())
      c.measurement_type (this->measurement_type ());

    if (this->uncertainty_present ())
      c.uncertainty (this->uncertainty ());

    if (this->negative_uncertainty_present ())
      c.negative_uncertainty (this->negative_uncertainty ());

    if (this->positive_uncertainty_present ())
      c.positive_uncertainty (this->positive_uncertainty ());

    if (this->uncertainty_percentage_present ())
      c.uncertainty_percentage (this->uncertainty_percentage ());

    if (this->negative_uncertainty_percentage_present ())
      c.negative_uncertainty_percentage (this->negative_uncertainty_percentage ());

    if (this->positive_uncertainty_percentage_present ())
      c.positive_uncertainty_percentage (this->positive_uncertainty_percentage ());

    if (this->median_present ())
      c.median (this->median ());

    if (this->standard_deviation_present ())
      c.standard_deviation (this->standard_deviation ());

    if (this->interquartile_range_present ())
    {
      ::common::two_doubles* m = this->interquartile_range ()._clone ();
      c.interquartile_range (m);
    }

    if (this->range_present ())
    {
      ::common::two_doubles* m = this->range ()._clone ();
      c.range (m);
    }

    if (this->min_present ())
      c.min (this->min ());

    if (this->max_present ())
      c.max (this->max ());

    if (this->standard_error_present ())
      c.standard_error (this->standard_error ());

    if (this->standard_error_of_the_mean_present ())
      c.standard_error_of_the_mean (this->standard_error_of_the_mean ());

    if (this->number_obs_present ())
      c.number_obs (this->number_obs ());

    if (this->skewnesss_present ())
      c.skewnesss (this->skewnesss ());

    if (this->kurtosis_present ())
      c.kurtosis (this->kurtosis ());
  }

  units_decimal* units_decimal::
  _clone () const
  {
    units_decimal* c = new units_decimal;
    ::xsde::cxx::guard< units_decimal > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // units_decimal_nonnegative
  //

  units_decimal_nonnegative::
  units_decimal_nonnegative ()
  {
  }

  void units_decimal_nonnegative::
  _copy (units_decimal_nonnegative& c) const
  {
    XSDE_UNUSED (c);

    const ::common::units_decimal& b = *this;
    b._copy (c);
  }

  units_decimal_nonnegative* units_decimal_nonnegative::
  _clone () const
  {
    units_decimal_nonnegative* c = new units_decimal_nonnegative;
    ::xsde::cxx::guard< units_decimal_nonnegative > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // units_unsignedShort
  //

  units_unsignedShort::
  units_unsignedShort ()
  {
    this->measurement_type_present_ = false;
    this->units_present_ = false;
  }

  units_unsignedShort::
  ~units_unsignedShort ()
  {
  }

  units_unsignedShort::
  units_unsignedShort (const units_unsignedShort& x)
  : ::xml_schema::unsigned_short_base (x)
  {
    XSDE_UNUSED (x);
    this->measurement_type_present_ = x.measurement_type_present_;
    if (this->measurement_type_present_)
      this->measurement_type_ = x.measurement_type_;
    this->units_present_ = x.units_present_;
    if (this->units_present_)
      this->units_ = x.units_;
  }

  units_unsignedShort& units_unsignedShort::
  operator= (const units_unsignedShort& x)
  {
    XSDE_UNUSED (x);
    static_cast< ::xml_schema::unsigned_short_base& > (*this) = x;
    this->measurement_type_present_ = x.measurement_type_present_;
    if (this->measurement_type_present_)
      this->measurement_type_ = x.measurement_type_;
    this->units_present_ = x.units_present_;
    if (this->units_present_)
      this->units_ = x.units_;
    return *this;
  }

  // units_boolean
  //

  units_boolean::
  units_boolean ()
  {
    this->units_present_ = false;
  }

  units_boolean::
  ~units_boolean ()
  {
  }

  units_boolean::
  units_boolean (const units_boolean& x)
  : ::xml_schema::boolean_base (x)
  {
    XSDE_UNUSED (x);
    this->units_present_ = x.units_present_;
    if (this->units_present_)
      this->units_ = x.units_;
  }

  units_boolean& units_boolean::
  operator= (const units_boolean& x)
  {
    XSDE_UNUSED (x);
    static_cast< ::xml_schema::boolean_base& > (*this) = x;
    this->units_present_ = x.units_present_;
    if (this->units_present_)
      this->units_ = x.units_;
    return *this;
  }

  // fraction
  //

  fraction::
  fraction ()
  {
  }

  // units_fraction
  //

  units_fraction::
  units_fraction ()
  {
  }

  void units_fraction::
  _copy (units_fraction& c) const
  {
    XSDE_UNUSED (c);

    const ::common::units_decimal& b = *this;
    b._copy (c);
  }

  units_fraction* units_fraction::
  _clone () const
  {
    units_fraction* c = new units_fraction;
    ::xsde::cxx::guard< units_fraction > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // units_string
  //

  units_string::
  units_string ()
  {
    this->units_present_ = false;
    this->measurement_type_present_ = false;
    this->uncertainty_present_ = false;
    this->negative_uncertainty_present_ = false;
    this->positive_uncertainty_present_ = false;
    this->uncertainty_percentage_present_ = false;
    this->negative_uncertainty_percentage_present_ = false;
    this->positive_uncertainty_percentage_present_ = false;
    this->median_present_ = false;
    this->standard_deviation_present_ = false;
    this->interquartile_range_ = 0;
    this->range_ = 0;
    this->min_present_ = false;
    this->max_present_ = false;
    this->standard_error_present_ = false;
    this->standard_error_of_the_mean_present_ = false;
    this->number_obs_present_ = false;
    this->skewnesss_present_ = false;
    this->kurtosis_present_ = false;
  }

  units_string::
  ~units_string ()
  {
    delete this->interquartile_range_;
    delete this->range_;
  }

  void units_string::
  _copy (units_string& c) const
  {
    XSDE_UNUSED (c);

    static_cast< ::std::string& > (c) = *this;
    if (this->units_present ())
      c.units (this->units ());

    if (this->measurement_type_present ())
      c.measurement_type (this->measurement_type ());

    if (this->uncertainty_present ())
      c.uncertainty (this->uncertainty ());

    if (this->negative_uncertainty_present ())
      c.negative_uncertainty (this->negative_uncertainty ());

    if (this->positive_uncertainty_present ())
      c.positive_uncertainty (this->positive_uncertainty ());

    if (this->uncertainty_percentage_present ())
      c.uncertainty_percentage (this->uncertainty_percentage ());

    if (this->negative_uncertainty_percentage_present ())
      c.negative_uncertainty_percentage (this->negative_uncertainty_percentage ());

    if (this->positive_uncertainty_percentage_present ())
      c.positive_uncertainty_percentage (this->positive_uncertainty_percentage ());

    if (this->median_present ())
      c.median (this->median ());

    if (this->standard_deviation_present ())
      c.standard_deviation (this->standard_deviation ());

    if (this->interquartile_range_present ())
    {
      ::common::two_doubles* m = this->interquartile_range ()._clone ();
      c.interquartile_range (m);
    }

    if (this->range_present ())
    {
      ::common::two_doubles* m = this->range ()._clone ();
      c.range (m);
    }

    if (this->min_present ())
      c.min (this->min ());

    if (this->max_present ())
      c.max (this->max ());

    if (this->standard_error_present ())
      c.standard_error (this->standard_error ());

    if (this->standard_error_of_the_mean_present ())
      c.standard_error_of_the_mean (this->standard_error_of_the_mean ());

    if (this->number_obs_present ())
      c.number_obs (this->number_obs ());

    if (this->skewnesss_present ())
      c.skewnesss (this->skewnesss ());

    if (this->kurtosis_present ())
      c.kurtosis (this->kurtosis ());
  }

  units_string* units_string::
  _clone () const
  {
    units_string* c = new units_string;
    ::xsde::cxx::guard< units_string > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // data_storage_formats
  //

  static const char* _xsde_data_storage_formats_enumerators_[] = 
  {
    "xml",
    "XML",
    "matlab",
    "Matlab",
    "MATLAB",
    "hdf5",
    "HDF5"
  };

  const char* data_storage_formats::
  string () const
  {
    return _xsde_data_storage_formats_enumerators_[value_];
  }

  // threshold_type
  //

  static const char* _xsde_threshold_type_enumerators_[] = 
  {
    "positive",
    "non_positive",
    "negative",
    "non_negative",
    "lower_bound",
    "upper_bound"
  };

  const char* threshold_type::
  string () const
  {
    return _xsde_threshold_type_enumerators_[value_];
  }

  // transition_threshold
  //

  transition_threshold::
  transition_threshold ()
  {
    this->variable_ID_present_ = false;
  }

  transition_threshold::
  ~transition_threshold ()
  {
  }

  void transition_threshold::
  _copy (transition_threshold& c) const
  {
    XSDE_UNUSED (c);

    const ::common::units_decimal& b = *this;
    b._copy (c);
    c.quantity (this->quantity ());

    c.type (this->type ());

    if (this->variable_ID_present ())
      c.variable_ID (this->variable_ID ());
  }

  transition_threshold* transition_threshold::
  _clone () const
  {
    transition_threshold* c = new transition_threshold;
    ::xsde::cxx::guard< transition_threshold > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

