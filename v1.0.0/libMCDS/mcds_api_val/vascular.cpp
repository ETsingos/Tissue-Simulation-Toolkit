// Copyright (c) 2005-2016 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD/e, an XML Schema
// to C++ data binding compiler for embedded systems.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#include <xsde/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "vascular.hpp"

#include <stdlib.h>
#include <new>

#include <xsde/cxx/guard.hxx>

namespace vascular
{
  // vascular_node
  //

  vascular_node::
  vascular_node ()
  {
    this->boundary_node_present_ = false;
  }

  vascular_node::
  ~vascular_node ()
  {
  }

  void vascular_node::
  _copy (vascular_node& c) const
  {
    XSDE_UNUSED (c);

    const ::mesh::node& b = *this;
    b._copy (c);
    if (this->boundary_node_present ())
      c.boundary_node (this->boundary_node ());
  }

  vascular_node* vascular_node::
  _clone () const
  {
    vascular_node* c = new vascular_node;
    ::xsde::cxx::guard< vascular_node > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  static const ::std::string _xsde_vascular_node_static_type_ = "vascular_node vascular";

  const ::std::string& vascular_node::
  _static_type ()
  {
    return _xsde_vascular_node_static_type_;
  }

  const ::std::string& vascular_node::
  _dynamic_type () const
  {
    return _static_type ();
  }

  // list_of_vascular_nodes
  //

  list_of_vascular_nodes::
  list_of_vascular_nodes ()
  {
    this->custom_ = 0;
  }

  list_of_vascular_nodes::
  ~list_of_vascular_nodes ()
  {
    delete this->custom_;
  }

  void list_of_vascular_nodes::
  _copy (list_of_vascular_nodes& c) const
  {
    XSDE_UNUSED (c);

    this->vascular_node ().copy (c.vascular_node ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  list_of_vascular_nodes* list_of_vascular_nodes::
  _clone () const
  {
    list_of_vascular_nodes* c = new list_of_vascular_nodes;
    ::xsde::cxx::guard< list_of_vascular_nodes > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // boundary_node
  //

  boundary_node::
  boundary_node ()
  {
    this->node_ID_present_ = false;
    this->fluid_flow_velocity_ = 0;
    this->variables_ = 0;
    this->boundary_conditions_ = 0;
    this->custom_ = 0;
  }

  boundary_node::
  ~boundary_node ()
  {
    delete this->fluid_flow_velocity_;
    delete this->variables_;
    delete this->boundary_conditions_;
    delete this->custom_;
  }

  void boundary_node::
  _copy (boundary_node& c) const
  {
    XSDE_UNUSED (c);

    if (this->node_ID_present ())
      c.node_ID (this->node_ID ());

    if (this->fluid_flow_velocity_present ())
    {
      ::common::units_decimal* m = this->fluid_flow_velocity ()._clone ();
      c.fluid_flow_velocity (m);
    }

    if (this->variables_present ())
    {
      ::variables::list_of_variables* m = this->variables ()._clone ();
      c.variables (m);
    }

    if (this->boundary_conditions_present ())
    {
      ::vascular::boundary_conditions* m = this->boundary_conditions ()._clone ();
      c.boundary_conditions (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  boundary_node* boundary_node::
  _clone () const
  {
    boundary_node* c = new boundary_node;
    ::xsde::cxx::guard< boundary_node > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // list_of_boundary_nodes
  //

  list_of_boundary_nodes::
  list_of_boundary_nodes ()
  {
    this->custom_ = 0;
  }

  list_of_boundary_nodes::
  ~list_of_boundary_nodes ()
  {
    delete this->custom_;
  }

  void list_of_boundary_nodes::
  _copy (list_of_boundary_nodes& c) const
  {
    XSDE_UNUSED (c);

    this->boundary_node ().copy (c.boundary_node ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  list_of_boundary_nodes* list_of_boundary_nodes::
  _clone () const
  {
    list_of_boundary_nodes* c = new list_of_boundary_nodes;
    ::xsde::cxx::guard< list_of_boundary_nodes > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // boundary_conditions
  //

  boundary_conditions::
  boundary_conditions ()
  {
    this->ID_present_ = false;
    this->custom_ = 0;
  }

  boundary_conditions::
  ~boundary_conditions ()
  {
    delete this->custom_;
  }

  void boundary_conditions::
  _copy (boundary_conditions& c) const
  {
    XSDE_UNUSED (c);

    if (this->ID_present ())
      c.ID (this->ID ());

    this->boundary_condition ().copy (c.boundary_condition ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  boundary_conditions* boundary_conditions::
  _clone () const
  {
    boundary_conditions* c = new boundary_conditions;
    ::xsde::cxx::guard< boundary_conditions > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // boundary_type
  //

  static const char* _xsde_boundary_type_enumerators_[] = 
  {
    "Neumann",
    "Dirichlet",
    "Periodic",
    "Anti-Periodic",
    "Reflecting",
    "Anti-Reflecting"
  };

  const char* boundary_type::
  string () const
  {
    return _xsde_boundary_type_enumerators_[value_];
  }

  // boundary_condition
  //

  boundary_condition::
  boundary_condition ()
  {
    this->ID_present_ = false;
    this->value_ = 0;
    this->direction_present_ = false;
    this->custom_ = 0;
  }

  boundary_condition::
  ~boundary_condition ()
  {
    delete this->value_;
    delete this->custom_;
  }

  void boundary_condition::
  _copy (boundary_condition& c) const
  {
    XSDE_UNUSED (c);

    if (this->ID_present ())
      c.ID (this->ID ());

    c.variable_ID (this->variable_ID ());

    c.boundary_type (this->boundary_type ());

    if (this->value_present ())
    {
      ::common::units_decimal* m = this->value ()._clone ();
      c.value (m);
    }

    if (this->direction_present ())
      c.direction (this->direction ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  boundary_condition* boundary_condition::
  _clone () const
  {
    boundary_condition* c = new boundary_condition;
    ::xsde::cxx::guard< boundary_condition > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // vascular_segments
  //

  vascular_segments::
  vascular_segments ()
  {
    this->custom_ = 0;
  }

  vascular_segments::
  ~vascular_segments ()
  {
    delete this->custom_;
  }

  void vascular_segments::
  _copy (vascular_segments& c) const
  {
    XSDE_UNUSED (c);

    this->vascular_segment ().copy (c.vascular_segment ());

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  vascular_segments* vascular_segments::
  _clone () const
  {
    vascular_segments* c = new vascular_segments;
    ::xsde::cxx::guard< vascular_segments > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // vascular_segment
  //

  vascular_segment::
  vascular_segment ()
  {
    this->endpoint_1_ = 0;
    this->endpoint_2_ = 0;
    this->surface_ = 0;
    this->interior_ = 0;
    this->custom_ = 0;
  }

  vascular_segment::
  ~vascular_segment ()
  {
    delete this->endpoint_1_;
    delete this->endpoint_2_;
    delete this->surface_;
    delete this->interior_;
    delete this->custom_;
  }

  void vascular_segment::
  _copy (vascular_segment& c) const
  {
    XSDE_UNUSED (c);

    {
      ::vascular::endpoint* m = this->endpoint_1 ()._clone ();
      c.endpoint_1 (m);
    }

    {
      ::vascular::endpoint* m = this->endpoint_2 ()._clone ();
      c.endpoint_2 (m);
    }

    if (this->surface_present ())
    {
      ::vascular::surface_properties* m = this->surface ()._clone ();
      c.surface (m);
    }

    if (this->interior_present ())
    {
      ::vascular::volume_properties* m = this->interior ()._clone ();
      c.interior (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  vascular_segment* vascular_segment::
  _clone () const
  {
    vascular_segment* c = new vascular_segment;
    ::xsde::cxx::guard< vascular_segment > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // endpoint
  //

  endpoint::
  endpoint ()
  {
    this->node_ID_present_ = false;
    this->lengths_ = 0;
    this->areas_ = 0;
    this->fluid_flow_velocity_ = 0;
    this->custom_ = 0;
  }

  endpoint::
  ~endpoint ()
  {
    delete this->lengths_;
    delete this->areas_;
    delete this->fluid_flow_velocity_;
    delete this->custom_;
  }

  void endpoint::
  _copy (endpoint& c) const
  {
    XSDE_UNUSED (c);

    if (this->node_ID_present ())
      c.node_ID (this->node_ID ());

    if (this->lengths_present ())
    {
      ::phenotype_common::lengths* m = this->lengths ()._clone ();
      c.lengths (m);
    }

    if (this->areas_present ())
    {
      ::phenotype_common::areas_2D* m = this->areas ()._clone ();
      c.areas (m);
    }

    if (this->fluid_flow_velocity_present ())
    {
      ::common::units_decimal* m = this->fluid_flow_velocity ()._clone ();
      c.fluid_flow_velocity (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  endpoint* endpoint::
  _clone () const
  {
    endpoint* c = new endpoint;
    ::xsde::cxx::guard< endpoint > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // surface_properties
  //

  surface_properties::
  surface_properties ()
  {
    this->areas_ = 0;
    this->fluid_flow_velocity_ = 0;
    this->mechanics_ = 0;
    this->permeability_ = 0;
    this->surface_proteins_ = 0;
    this->custom_ = 0;
  }

  surface_properties::
  ~surface_properties ()
  {
    delete this->areas_;
    delete this->fluid_flow_velocity_;
    delete this->mechanics_;
    delete this->permeability_;
    delete this->surface_proteins_;
    delete this->custom_;
  }

  void surface_properties::
  _copy (surface_properties& c) const
  {
    XSDE_UNUSED (c);

    if (this->areas_present ())
    {
      ::phenotype_common::areas_3D* m = this->areas ()._clone ();
      c.areas (m);
    }

    if (this->fluid_flow_velocity_present ())
    {
      ::common::units_decimal* m = this->fluid_flow_velocity ()._clone ();
      c.fluid_flow_velocity (m);
    }

    if (this->mechanics_present ())
    {
      ::phenotype_common::mechanics* m = this->mechanics ()._clone ();
      c.mechanics (m);
    }

    if (this->permeability_present ())
    {
      ::common::units_decimal* m = this->permeability ()._clone ();
      c.permeability (m);
    }

    if (this->surface_proteins_present ())
    {
      ::variables::list_of_variables* m = this->surface_proteins ()._clone ();
      c.surface_proteins (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  surface_properties* surface_properties::
  _clone () const
  {
    surface_properties* c = new surface_properties;
    ::xsde::cxx::guard< surface_properties > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // volume_properties
  //

  volume_properties::
  volume_properties ()
  {
    this->fluid_flow_velocity_ = 0;
    this->variables_ = 0;
    this->volumes_ = 0;
    this->custom_ = 0;
  }

  volume_properties::
  ~volume_properties ()
  {
    delete this->fluid_flow_velocity_;
    delete this->variables_;
    delete this->volumes_;
    delete this->custom_;
  }

  void volume_properties::
  _copy (volume_properties& c) const
  {
    XSDE_UNUSED (c);

    if (this->fluid_flow_velocity_present ())
    {
      ::common::units_decimal* m = this->fluid_flow_velocity ()._clone ();
      c.fluid_flow_velocity (m);
    }

    if (this->variables_present ())
    {
      ::variables::list_of_variables* m = this->variables ()._clone ();
      c.variables (m);
    }

    if (this->volumes_present ())
    {
      ::phenotype_common::volumes* m = this->volumes ()._clone ();
      c.volumes (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  volume_properties* volume_properties::
  _clone () const
  {
    volume_properties* c = new volume_properties;
    ::xsde::cxx::guard< volume_properties > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }

  // vascular_network
  //

  vascular_network::
  vascular_network ()
  {
    this->ID_present_ = false;
    this->keywords_present_ = false;
    this->name_present_ = false;
    this->vascular_nodes_ = 0;
    this->boundary_nodes_ = 0;
    this->vascular_segments_ = 0;
    this->voxels_ = 0;
    this->custom_ = 0;
  }

  vascular_network::
  ~vascular_network ()
  {
    delete this->vascular_nodes_;
    delete this->boundary_nodes_;
    delete this->vascular_segments_;
    delete this->voxels_;
    delete this->custom_;
  }

  void vascular_network::
  _copy (vascular_network& c) const
  {
    XSDE_UNUSED (c);

    if (this->ID_present ())
      c.ID (this->ID ());

    if (this->keywords_present ())
      c.keywords (this->keywords ());

    if (this->name_present ())
      c.name (this->name ());

    if (this->vascular_nodes_present ())
    {
      ::vascular::list_of_vascular_nodes* m = this->vascular_nodes ()._clone ();
      c.vascular_nodes (m);
    }

    if (this->boundary_nodes_present ())
    {
      ::vascular::list_of_boundary_nodes* m = this->boundary_nodes ()._clone ();
      c.boundary_nodes (m);
    }

    if (this->vascular_segments_present ())
    {
      ::vascular::vascular_segments* m = this->vascular_segments ()._clone ();
      c.vascular_segments (m);
    }

    if (this->voxels_present ())
    {
      ::mesh::int_list_xpath* m = this->voxels ()._clone ();
      c.voxels (m);
    }

    if (this->custom_present ())
    {
      ::common::custom* m = this->custom ()._clone ();
      c.custom (m);
    }
  }

  vascular_network* vascular_network::
  _clone () const
  {
    vascular_network* c = new vascular_network;
    ::xsde::cxx::guard< vascular_network > g (c);
    this->_copy (*c);
    g.release ();
    return c;
  }
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsde/cxx/post.hxx>

